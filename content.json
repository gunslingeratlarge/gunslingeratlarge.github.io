{"meta":{"title":"gunslingeratlarge's blog","subtitle":null,"description":null,"author":"gsal","url":"http://gunslingeratlarge.github.io"},"pages":[{"title":"About","date":"2018-06-25T10:21:01.934Z","updated":"2018-06-25T10:21:01.934Z","comments":true,"path":"about/index.html","permalink":"http://gunslingeratlarge.github.io/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2018-06-25T10:21:01.935Z","updated":"2018-06-25T10:21:01.935Z","comments":true,"path":"categories/index.html","permalink":"http://gunslingeratlarge.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-03-17T07:25:51.000Z","updated":"2018-06-25T10:21:02.001Z","comments":true,"path":"tags/index.html","permalink":"http://gunslingeratlarge.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"springboot如何读取外部配置信息","slug":"springboot如何读取外部配置信息","date":"2018-06-20T12:31:00.000Z","updated":"2018-06-25T10:24:40.618Z","comments":true,"path":"2018/06/20/springboot如何读取外部配置信息/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/06/20/springboot如何读取外部配置信息/","excerpt":"在resources文件夹下添加datasource.properites文件，对应properties中的属性写一个pojo。这个pojo将被注入，pojo上不用加@Component标注，因为我们等下用JavaConfig的方式统一进行。写一个Config类，比如叫PropertyConfig，加@Configuration，加@PropertySource(“classpath:datasource.properties”)，并配置一个PropertySourcesPlaceholderConfigurer，注意其@Bean的方法要是静态方法。为什么我也不知道，不是静态方法就会报错。思路是这样的，PropertySourcesPlaceholderConfigurer读取配置文件，并生成键值对，而Config类中的属性通过@Value(${user})的形式取得键值对的值，并注入到自己的变量中，而刚才写的那个pojo可以拿到这些值并注册到Spring容器中。","text":"在resources文件夹下添加datasource.properites文件，对应properties中的属性写一个pojo。这个pojo将被注入，pojo上不用加@Component标注，因为我们等下用JavaConfig的方式统一进行。写一个Config类，比如叫PropertyConfig，加@Configuration，加@PropertySource(“classpath:datasource.properties”)，并配置一个PropertySourcesPlaceholderConfigurer，注意其@Bean的方法要是静态方法。为什么我也不知道，不是静态方法就会报错。思路是这样的，PropertySourcesPlaceholderConfigurer读取配置文件，并生成键值对，而Config类中的属性通过@Value(${user})的形式取得键值对的值，并注入到自己的变量中，而刚才写的那个pojo可以拿到这些值并注册到Spring容器中。 示例代码12345678910111213141516171819202122232425@Configuration@PropertySource(\"classpath:datasource.properties\")public class PropertyConfig &#123; @Value(\"$&#123;user&#125;\") String user; @Value(\"$&#123;password&#125;\") String password; @Value(\"$&#123;url&#125;\") String url; //读取文件并生成键值对,PropertySourcesPlaceholderConfigurer @Bean public static PropertySourcesPlaceholderConfigurer configurer() &#123; return new PropertySourcesPlaceholderConfigurer(); &#125; @Bean public DataSourceInfo dataSourceInfo() &#123; DataSourceInfo info = new DataSourceInfo(); info.setUser(user); info.setPassword(password); info.setUrl(url); return info; &#125;&#125; DataSourceInfo12345678910111213141516171819202122232425package cn.kvmial.DIDemo.examplebean;public class DataSourceInfo &#123; private String user; private String password; private String url; public String getUser() &#123; return user; &#125; public void setUser(String user) &#123; this.user = user; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://gunslingeratlarge.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://gunslingeratlarge.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://gunslingeratlarge.github.io/tags/Spring/"}]},{"title":"springboot初始化","slug":"springboot初始化","date":"2018-06-20T04:30:00.000Z","updated":"2018-06-25T10:21:01.914Z","comments":true,"path":"2018/06/20/springboot初始化/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/06/20/springboot初始化/","excerpt":"","text":"配置springboot几乎不需要配置，它其实就是使用了spring加springmvc加hibernate，最终功能还是它们在做，只是boot确实开始起来很方便。只需要到start.spring.io选择对应的版本就可以了。选择maven版本直接导入到eclipse中就可以直接运行了。springboot内置了tomcat，并且可以直接打包成jar包运行，可以把它当做是一个java应用，因为它的入口就是main方法。 注意有一些版本号启动之后内置的tomcat不会启动，现在能用的有1.5.9.RELEASE，2.0.0.RELEASE，具体是什么原因我也不太清楚。我也是自己摸索出来的。还有注意在启动之后企图访问thymeleaf模板的时候可能会报ClassNotFoundException，这是用反射加载某个类的时候找不到这个类报的错，仔细阅读它的错误日志会发现是有一个thymeleaf的依赖没有添加进去，所以在maven仓库中找到这个依赖然后在pom.xml中添加进去就可以了。本来按理说只要添加了thymeleaf的依赖就可以了，我也不知道怎么回事。反正这样子是可以解决这个问题了暂时。springboot只从main方法所在的类往下找component，所以注解的时候要注意。 注解springboot里似乎没有spring里面的ApplicationContext.xml这个配置文件了，很多都是使用注解完成配置了。确实也比较方便也更加直观。@Controller可以配合@RequestMapping({&quot;/&quot;,&quot;&quot;})使用，而只需要一个public方法就可以完成视图与model的绑定。这比之前springmvc的ModelAndView要方便不少了。 12345678@Controllerpublic class JokeController &#123; @RequestMapping(\"/joke\") public String showJoke(Model model) &#123; model.addAttribute(\"message\", \"here you are\"); return \"joke\"; &#125;&#125; 返回的虽然只是一个“joke”字符串，但是springboot就会去找joke.html,然后将该填充的内容填充进去。 一个可以使用的pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;guru.springframework.joke&lt;/groupId&gt; &lt;artifactId&gt;jokeapp&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;jokeapp&lt;/name&gt; &lt;description&gt;Joke App for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.0.RELEASE&lt;/version&gt; &lt;relativePath /&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-thymeleaf --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;version&gt;2.0.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.attoparser/attoparser --&gt; &lt;dependency&gt; &lt;groupId&gt;org.attoparser&lt;/groupId&gt; &lt;artifactId&gt;attoparser&lt;/artifactId&gt; &lt;version&gt;2.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.unbescape/unbescape --&gt; &lt;dependency&gt; &lt;groupId&gt;org.unbescape&lt;/groupId&gt; &lt;artifactId&gt;unbescape&lt;/artifactId&gt; &lt;version&gt;1.1.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-snapshots&lt;/id&gt; &lt;name&gt;Spring Snapshots&lt;/name&gt; &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-snapshots&lt;/id&gt; &lt;name&gt;Spring Snapshots&lt;/name&gt; &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt;&lt;/project&gt;","categories":[{"name":"Java","slug":"Java","permalink":"http://gunslingeratlarge.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://gunslingeratlarge.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://gunslingeratlarge.github.io/tags/Spring/"}]},{"title":"78. Subsets","slug":"78-Subsets","date":"2018-06-11T11:32:00.000Z","updated":"2018-06-25T10:21:01.889Z","comments":true,"path":"2018/06/11/78-Subsets/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/06/11/78-Subsets/","excerpt":"78. SubsetsDifficulty: Medium Given a set of distinct integers, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: 123456789101112**Input:** nums = [1,2,3]**Output:**[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []]","text":"78. SubsetsDifficulty: Medium Given a set of distinct integers, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: 123456789101112**Input:** nums = [1,2,3]**Output:**[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] Solution123456789101112131415161718192021222324252627282930//另外一种解决的思路是不使用回溯（递归)，而是用位的方式来模拟，化递归树结构为线性结构，这样就可以在循环中使用了//比如说你的nums中有三个数，1,2,3，那么你可以从0 - 111 这样的方式来模拟取了的情况，即从0到2^n - 1,n为nums.size().然后你把每一个三位数//比如101,都拿出来，并生成对应的集合，并放到res中去就可以了。 但是有一个关键的问题是，你如何把101对应到nums中的第一个数和第三个数。这就需要位运算了。//没有办法一下子运算出来的，需要从右往左运算。与001进行按位与，然后与010按位与，然后与100按位与。所以还要有一个循环。​class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; ArrayList&lt;Integer&gt; item = null; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); //i从0到7 for (int i = 0; i &lt;= Math.pow(2,nums.length) - 1; i++) &#123; item = new ArrayList&lt;Integer&gt;(); int k = 0;​ for (int j = 1;j &lt;= Math.pow(2, nums.length - 1);j = j &lt;&lt; 1, k++) &#123; if ((i &amp; j)!= 0) &#123; item.add(nums[k]); &#125;​ &#125; List&lt;Integer&gt; itemclone = (List&lt;Integer&gt;)item.clone(); res.add(itemclone); &#125; return res; &#125;&#125; 采用递归进行回溯123456789101112131415161718192021222324252627282930313233//结合回溯法进行思考。 //用循环写困难的地方在于你没办法分叉，就是你没办法考虑两种情况，考虑选和不选两种情况，就是你只能一直执行，也没办法说我选了，我可以回到这个位置重新不选。//如果只生成[1],[2],[3],困难吗？ 就很简单，因为你不需要回溯，回到这个做决定的地方，然后不选1，因为所有的情况都是选择了1的。就不是一个树形结构，而是一个线性结构//用循环的方法写是简单的，但是能不能用递归的方法来只生成[1][1,2][1,2,3]?//可以试探完一个再试探另一个，比如可以选择了1然后后续的元素继续选择， 然后又可以回溯到对1做选择的位置，因为递归的每一层都保留了当前层的状态，所以你可以利用递归回到当前的状态然后做不一样的选择。 //list里面嵌套添加list，要注意只是添加了引用进去，而不是添加整个数组的元素进去。引用的话如果被引用数组内容改变了你就尴尬了。 class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); List&lt;Integer&gt; item = new ArrayList&lt;&gt;(); backtrack(0,nums,(ArrayList&lt;Integer&gt;)item,(ArrayList&lt;List&lt;Integer&gt;&gt;)res); res.add(new ArrayList&lt;Integer&gt;()); return res; &#125; public void backtrack (int i, int[] nums, ArrayList&lt;Integer&gt; item, ArrayList&lt;List&lt;Integer&gt;&gt; res) &#123; if (i &gt;= nums.length) &#123; return; &#125; //选择当前元素 item.add(nums[i]); ArrayList&lt;Integer&gt; temp = (ArrayList&lt;Integer&gt;)item.clone(); res.add(temp); //进行下一个元素的选与不选 backtrack(i + 1, nums,item,res); //去掉当前元素 item.remove(item.size() - 1); //进行下一个元素的选与不选 backtrack(i + 1, nums,item,res); &#125;&#125;","categories":[{"name":"刷题","slug":"刷题","permalink":"http://gunslingeratlarge.github.io/categories/刷题/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://gunslingeratlarge.github.io/tags/leetcode/"},{"name":"刷题","slug":"刷题","permalink":"http://gunslingeratlarge.github.io/tags/刷题/"},{"name":"medium","slug":"medium","permalink":"http://gunslingeratlarge.github.io/tags/medium/"}]},{"title":"Random Forest Regression Cheatsheet","slug":"Random-Forest-Regression-Cheatsheet","date":"2018-06-06T12:02:00.000Z","updated":"2018-06-25T10:21:01.897Z","comments":true,"path":"2018/06/06/Random-Forest-Regression-Cheatsheet/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/06/06/Random-Forest-Regression-Cheatsheet/","excerpt":"","text":"介绍随机森林就是从训练集中随机取k个数据，然后训练很多棵这样的树，最后取每颗树预测值的平均值。但是不是说森林中树越多就会从跳跃的图像变成连续的图像了，最后会converge到一定的阶梯数目。不过结果可能会越来越精确也说不定。其实真正的运用随机森林的地方就三句话… 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# -*- coding: utf-8 -*-# Regression Template# Importing the librariesimport numpy as npimport matplotlib.pyplot as pltimport pandas as pd# Importing the datasetdataset = pd.read_csv('Position_Salaries.csv')X = dataset.iloc[:, 1:2].valuesy = dataset.iloc[:, 2].values# Splitting the dataset into the Training set and Test set\"\"\"from sklearn.cross_validation import train_test_splitX_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 0)\"\"\"# Feature Scaling\"\"\"from sklearn.preprocessing import StandardScalersc_X = StandardScaler()X_train = sc_X.fit_transform(X_train)X_test = sc_X.transform(X_test)sc_y = StandardScaler()y_train = sc_y.fit_transform(y_train)\"\"\"# Fitting the Regression Model to the dataset# Create your regressor here#Decision Tree Don't need feature scalingfrom sklearn.ensemble import RandomForestRegressorregressor = RandomForestRegressor(n_estimators = 300, random_state=0)regressor.fit(X,y)# Predicting a new resulty_pred = regressor.predict(6.5)# Visualising the Regression resultsplt.scatter(X, y, color = 'red')plt.plot(X, regressor.predict(X), color = 'blue')plt.title('Truth or Bluff (Regression Model)')plt.xlabel('Position level')plt.ylabel('Salary')plt.show()# Visualising the Regression results (for higher resolution and smoother curve)X_grid = np.arange(min(X), max(X), 0.005)X_grid = X_grid.reshape((len(X_grid), 1))plt.scatter(X, y, color = 'red')plt.plot(X_grid, regressor.predict(X_grid), color = 'blue')plt.title('Truth or Bluff (Regression Model)')plt.xlabel('Position level')plt.ylabel('Salary')plt.show()","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://gunslingeratlarge.github.io/categories/机器学习/"}],"tags":[{"name":"python","slug":"python","permalink":"http://gunslingeratlarge.github.io/tags/python/"},{"name":"机器学习","slug":"机器学习","permalink":"http://gunslingeratlarge.github.io/tags/机器学习/"}]},{"title":"Decision Tree Cheat Sheet","slug":"Design-Tree-Cheat-Sheet","date":"2018-06-06T10:33:00.000Z","updated":"2018-06-25T10:21:01.891Z","comments":true,"path":"2018/06/06/Design-Tree-Cheat-Sheet/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/06/06/Design-Tree-Cheat-Sheet/","excerpt":"","text":"注意Design Tree本身是不需要feature scaling的，只是在绘图的时候要注意用更高分辨率的展示。Design Tree是按照自变量的不同取值来划分区域的，这样就为数据集增加了新的信息。我们拿到一个新的样本，想要去预测它的因变量的值，最原始的做法是去求所有已有的数据的平均值，然后作为这个新的待预测的样本的值。但是现在我们可以将这些样本分成不同的区间上的，而新的样本落在某个区间上，就取这整个区间的平均值就可以了。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# Regression Template# Importing the librariesimport numpy as npimport matplotlib.pyplot as pltimport pandas as pd# Importing the datasetdataset = pd.read_csv('Position_Salaries.csv')X = dataset.iloc[:, 1:2].valuesy = dataset.iloc[:, 2].values# Splitting the dataset into the Training set and Test set\"\"\"from sklearn.cross_validation import train_test_splitX_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 0)\"\"\"# Feature Scaling\"\"\"from sklearn.preprocessing import StandardScalersc_X = StandardScaler()X_train = sc_X.fit_transform(X_train)X_test = sc_X.transform(X_test)sc_y = StandardScaler()y_train = sc_y.fit_transform(y_train)\"\"\"# Fitting the Regression Model to the dataset# Create your regressor here#Decision Tree Don't need feature scalingfrom sklearn.tree import DecisionTreeRegressorregressor = DecisionTreeRegressor(random_state=42)regressor.fit(X,y)# Predicting a new resulty_pred = regressor.predict(6.5)# Visualising the Regression resultsplt.scatter(X, y, color = 'red')plt.plot(X, regressor.predict(X), color = 'blue')plt.title('Truth or Bluff (Regression Model)')plt.xlabel('Position level')plt.ylabel('Salary')plt.show()# Visualising the Regression results (for higher resolution and smoother curve)X_grid = np.arange(min(X), max(X), 0.005)X_grid = X_grid.reshape((len(X_grid), 1))plt.scatter(X, y, color = 'red')plt.plot(X_grid, regressor.predict(X_grid), color = 'blue')plt.title('Truth or Bluff (Regression Model)')plt.xlabel('Position level')plt.ylabel('Salary')plt.show()","categories":[{"name":"python","slug":"python","permalink":"http://gunslingeratlarge.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://gunslingeratlarge.github.io/tags/python/"},{"name":"机器学习","slug":"机器学习","permalink":"http://gunslingeratlarge.github.io/tags/机器学习/"}]},{"title":"Support Vector Regression Cheatsheet","slug":"support-vector-regression-cheatsheet","date":"2018-06-06T07:51:00.000Z","updated":"2018-06-25T10:21:01.915Z","comments":true,"path":"2018/06/06/support-vector-regression-cheatsheet/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/06/06/support-vector-regression-cheatsheet/","excerpt":"","text":"概念svr本身不像sklearn的线性模型会帮你做feature_scaling，所以需要你自己进行放缩，在fit完regressor之后预测的时候要对输入（X）进行放缩，最后出来之后要对y进行放缩。即要预测要先进行特征放缩，然后得到了预测值之后还要放缩回去。可以通过array.reshape(-1,1)将一个向量转成一个一列的矩阵。通过dataframe.values将DataFrame转成ndarray。可以通过np.array([[1,2,3],[2,3,4]])构建一个2×3的矩阵。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546# -*- coding: utf-8 -*-# SVR# Importing the librariesimport numpy as npimport matplotlib.pyplot as pltimport pandas as pd# Importing the datasetdataset = pd.read_csv('Position_Salaries.csv')X = dataset.iloc[:, 1:2].valuesy = dataset.iloc[:, 2].values# Splitting the dataset into the Training set and Test set\"\"\"from sklearn.cross_validation import train_test_splitX_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 0)\"\"\"# Feature Scalingfrom sklearn.preprocessing import StandardScalersc_X = StandardScaler()sc_y = StandardScaler()X_scaled = sc_X.fit_transform(X)#turn y into an arrayy_scaled = sc_y.fit_transform(y.reshape(-1,1))y_scaled = y_scaled[:,-1]#after scaling, fit to svr modelfrom sklearn.svm import SVRregressor = SVR(kernel=\"rbf\")regressor.fit(X_scaled,y_scaled)X_grid = np.arange(min(X_scaled),max(X_scaled),0.1)X_grid = X_grid.reshape(-1,1)plt.scatter(X_scaled,y_scaled,c=\"r\")plt.plot(X_grid, regressor.predict(X_grid),c =\"b\")plt.show()#to predict value, we need to reverse the scale process#y_predict = sc_y.inverse_transform(sc_X.transform(regressor.predict(np.array(6.5).reshape(-1,1))))#要预测要先进行特征放缩，然后得到了预测值之后还要放缩回去xx = np.array([[6.5]])xx = sc_X.transform(xx)yy = regressor.predict(xx)yy.reshape(-1,1)yy = sc_y.inverse_transform(yy)","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://gunslingeratlarge.github.io/categories/机器学习/"}],"tags":[{"name":"python","slug":"python","permalink":"http://gunslingeratlarge.github.io/tags/python/"},{"name":"机器学习","slug":"机器学习","permalink":"http://gunslingeratlarge.github.io/tags/机器学习/"}]},{"title":"Polynomial Regression Cheatsheet","slug":"polynomial-regression-cheatsheet","date":"2018-06-06T05:59:00.000Z","updated":"2018-06-25T10:21:01.913Z","comments":true,"path":"2018/06/06/polynomial-regression-cheatsheet/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/06/06/polynomial-regression-cheatsheet/","excerpt":"","text":"就是把原来的一个x的特征矩阵扩充为x和x的2次，3次…有一个参数degree就是用来选次数的这个回归的方式PolynomialFeatures会自动帮你加上一列1在前面，你就不用自己搞了 12345678910111213141516171819202122232425262728293031323334353637383940414243#importing librariesimport numpy as npimport pandas as pdimport matplotlib.pyplot as plt#loading datadataset = pd.read_csv(\"Position_Salaries.csv\")X = dataset.iloc[:,1:2].valuesy = dataset.iloc[:,-1].values#adding polynomial featuresfrom sklearn.preprocessing import PolynomialFeaturesreg_poly = PolynomialFeatures(degree = 4)X_poly = reg_poly.fit_transform(X)#simple linear regressionfrom sklearn.linear_model import LinearRegressionlin_reg = LinearRegression()lin_reg = lin_reg.fit(X,y)#plot simple linear regressionplt.scatter(X,y,color=\"red\")plt.title(\"predict salary by level\")plt.xlabel(\"level\")plt.ylabel(\"salary\")plt.plot(X, lin_reg.predict(X),c=\"b\")plt.show()#polynomial linear regressionpoly_lin_reg = LinearRegression()poly_lin_reg.fit(X_poly,y)#plot polynomial linear regressionX_grid = np.arange(min(X),max(X),0.1)X_grid = np.reshape(X_grid,(len(X_grid),1))plt.scatter(X,y,color=\"red\")plt.title(\"predict salary by level(polynomial regression)\")plt.xlabel(\"level\")plt.ylabel(\"salary\")plt.plot(X_grid, poly_lin_reg.predict(reg_poly.fit_transform(X_grid)),c=\"b\")plt.show()","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://gunslingeratlarge.github.io/tags/python/"},{"name":"机器学习","slug":"机器学习","permalink":"http://gunslingeratlarge.github.io/tags/机器学习/"}]},{"title":"Multiple Linear Regression Cheatsheet","slug":"multiple-linear-regression-cheatsheet","date":"2018-06-06T02:20:00.000Z","updated":"2018-06-25T10:21:01.911Z","comments":true,"path":"2018/06/06/multiple-linear-regression-cheatsheet/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/06/06/multiple-linear-regression-cheatsheet/","excerpt":"","text":"多元线性回归线性不是用来讲x的，是用来讲系数的。需要注意要省略掉dummy variable中的一位来避免dummy variable trap。import matplotlib.pyplot as plt 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# -*- coding: utf-8 -*-\"\"\"Created on Tue Jun 5 16:45:51 2018@author: Gunslinger\"\"\"#import librariesimport numpy as npimport pandas as pd#readfile -pddataset = pd.read_csv(\"50_Startups.csv\")X = dataset.iloc[:,:-1].valuesy = dataset.iloc[:,-1].values#one hot encodefrom sklearn.preprocessing import LabelEncoder,OneHotEncoderlabelencoder = LabelEncoder()X[:,-1] = labelencoder.fit_transform(X[:,-1])onehotencoder = OneHotEncoder(categorical_features=[3])X = onehotencoder.fit_transform(X).toarray()#avoid dummy variable trapX = X[:,1:]# train test splitfrom sklearn.cross_validation import train_test_splitX_train, X_test, y_train, y_test = train_test_split(X,y,test_size=0.2,random_state = 44)#fit model (adding ones before the first column to address the const value)import statsmodels.formula.api as smX = np.append(np.ones((50,1)).astype(int),X,axis=1)X_opt = X[:,[0,1,2,3,4,5]]regressor_OLS = sm.OLS(endog = y, exog=X_opt).fit()regressor_OLS.summary()#delete x2:dummy 2X_opt = X[:,[0,1,3,4,5]]regressor_OLS = sm.OLS(endog = y, exog=X_opt).fit()regressor_OLS.summary()#delete x1X_opt = X[:,[0,3,4,5]]regressor_OLS = sm.OLS(endog = y, exog=X_opt).fit()regressor_OLS.summary()#delete x1X_opt = X[:,[0,3,5]]regressor_OLS = sm.OLS(endog = y, exog=X_opt).fit()regressor_OLS.summary()","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://gunslingeratlarge.github.io/categories/机器学习/"}],"tags":[{"name":"python","slug":"python","permalink":"http://gunslingeratlarge.github.io/tags/python/"},{"name":"机器学习","slug":"机器学习","permalink":"http://gunslingeratlarge.github.io/tags/机器学习/"}]},{"title":"Simple Linear Regression Cheatsheet","slug":"simple-linear-regression-cheatsheet","date":"2018-06-05T01:35:00.000Z","updated":"2018-06-25T10:21:01.913Z","comments":true,"path":"2018/06/05/simple-linear-regression-cheatsheet/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/06/05/simple-linear-regression-cheatsheet/","excerpt":"","text":"介绍非常简单，只需要将训练数据（包括X和y喂给regressor就可以了） cheatsheet1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# Simple Linear Regression# Importing the librariesimport numpy as npimport matplotlib.pyplot as pltimport pandas as pd# Importing the datasetdataset = pd.read_csv('Salary_Data.csv')X = dataset.iloc[:, :-1].valuesy = dataset.iloc[:, 1].values# Splitting the dataset into the Training set and Test setfrom sklearn.cross_validation import train_test_splitX_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 1/3, random_state = 0)# Feature Scaling\"\"\"from sklearn.preprocessing import StandardScalersc_X = StandardScaler()X_train = sc_X.fit_transform(X_train)X_test = sc_X.transform(X_test)sc_y = StandardScaler()y_train = sc_y.fit_transform(y_train)\"\"\"# Fitting Simple Linear Regression to the Training setfrom sklearn.linear_model import LinearRegressionregressor = LinearRegression()regressor.fit(X_train, y_train)# Predicting the Test set resultsy_pred = regressor.predict(X_test)# Visualising the Training set resultsplt.scatter(X_train, y_train, color = 'red')plt.plot(X_train, regressor.predict(X_train), color = 'blue')plt.title('Salary vs Experience (Training set)')plt.xlabel('Years of Experience')plt.ylabel('Salary')plt.show()# Visualising the Test set resultsplt.scatter(X_test, y_test, color = 'red')plt.plot(X_train, regressor.predict(X_train), color = 'blue')plt.title('Salary vs Experience (Test set)')plt.xlabel('Years of Experience')plt.ylabel('Salary')plt.show() 如果直接plot的话就是画线，而scatter则是画散点图。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://gunslingeratlarge.github.io/categories/机器学习/"}],"tags":[{"name":"python","slug":"python","permalink":"http://gunslingeratlarge.github.io/tags/python/"},{"name":"机器学习","slug":"机器学习","permalink":"http://gunslingeratlarge.github.io/tags/机器学习/"}]},{"title":"Data Preprocessing Cheatsheet","slug":"data-preprocessing-cheatsheet","date":"2018-06-04T13:28:00.000Z","updated":"2018-06-25T10:21:01.900Z","comments":true,"path":"2018/06/04/data-preprocessing-cheatsheet/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/06/04/data-preprocessing-cheatsheet/","excerpt":"数据预处理流程首先是读取数据，数据读完了之后有缺失数据，那肯定要把缺失数据补充完整。数据补充完整之后对于categorical的变量要将它转成numerical的或者是one-hot编码（dummy variables）。这样我们的数据看起来就比较舒服。接下来就要划分好自变量和因变量，并且划分训练集和测试集，那么最后再做一下feature scaling，将这些特征都放缩到差不多的范围里来。","text":"数据预处理流程首先是读取数据，数据读完了之后有缺失数据，那肯定要把缺失数据补充完整。数据补充完整之后对于categorical的变量要将它转成numerical的或者是one-hot编码（dummy variables）。这样我们的数据看起来就比较舒服。接下来就要划分好自变量和因变量，并且划分训练集和测试集，那么最后再做一下feature scaling，将这些特征都放缩到差不多的范围里来。 完整的预处理代码数据的预处理可以有很多种方式，这里给出的只是一种，并且对于复杂的情况可能也无法处理。就需要在此基础上不断补充，举一反三了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# -*- coding: utf-8 -*-\"\"\"Created on Sat Jun 2 19:44:53 2018@author: Gunslinger\"\"\"#import librariesimport numpy as npimport matplotlib.pyplot as pltimport pandas as pd#load datadataset = pd.read_csv(\"Data.csv\")X = dataset.iloc[:,:-1].valuesY = dataset.iloc[:,3].values#import Imputer to fill the missing datafrom sklearn.preprocessing import Imputerimputer = Imputer(missing_values=\"NaN\",strategy=\"mean\",axis=0)imputer = imputer.fit(X[:,1:3])X[:,1:3] = imputer.transform(X[:,1:3]) #Encoding categorical data from sklearn.preprocessing import LabelEncoderlabelencoder_x = LabelEncoder()X[:,0] = labelencoder_x.fit_transform(X[:,0])labelencoder_y = LabelEncoder()Y =labelencoder_y.fit_transform(Y)#onehot encodefrom sklearn.preprocessing import OneHotEncoderonehotencoder = OneHotEncoder(categorical_features=[0])X = onehotencoder.fit_transform(X).toarray()#train-test-splittingfrom sklearn.cross_validation import train_test_splitX_train, X_test, Y_train, Y_test = train_test_split(X,Y,test_size=0.2, random_state = 0)#Feture Scalingfrom sklearn.preprocessing import StandardScalersc_X = StandardScaler()#FIT means to compute nessecary numbers and variables to modify the XX_train = sc_X.fit_transform(X_train)X_test = sc_X.transform(X_test) 其他这里提一下其他的一些收获和知识点。 下载anaconda然后无脑安装，打开spyder就可以直接开始写代码，不用下载各种乱七八糟的库了，都已经给你准备好了。 ctrl + I 可以调出某个方法的帮助文档，非常有用 ctrl + enter 执行选中的代码段 注意到X = dataset.iloc[:,:-1].values与Y = dataset.iloc[:,3].values的区别。如果直接是[:,3]那只会得到一个数组，是一维的。而如果[:,3:4]还是拿的一列，但是会得到一个一列的matrix。这是一个比较微妙的区别 onehot编码在训练模型的时候一定要省略掉一位。因为不省略掉信息就冗余了。 fit和transform的意思是将这个工具（encoder，imputer之类的）根据你输入的矩阵、数组进行操作，然后再转换形式。也说不清，反正都是一起用的好像。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://gunslingeratlarge.github.io/categories/机器学习/"}],"tags":[{"name":"python","slug":"python","permalink":"http://gunslingeratlarge.github.io/tags/python/"},{"name":"机器学习","slug":"机器学习","permalink":"http://gunslingeratlarge.github.io/tags/机器学习/"}]},{"title":"如何build一个模型","slug":"如何build一个模型","date":"2018-06-03T10:57:00.000Z","updated":"2018-06-25T10:21:01.923Z","comments":true,"path":"2018/06/03/如何build一个模型/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/06/03/如何build一个模型/","excerpt":"","text":"步骤 All-in 后向消去（Backword Elimination） 正向选择（Forward Selection） 双向选择 分数比较 思路我们怎样去从非常多的feature中挑选出那些有用的特征呢？这个pdf讲的很清楚我们就不多说了。 http://www.superdatascience.com/wp-content/uploads/2017/02/Step-by-step-Blueprints-For-Building-Models.pdf这里的P值和significance level（显著性水平）是统计学里的概念，p &lt; sl是显著的，一般sl取0.05。比较快速的挑选feature的方法是backword elimilation。 Backword Elimination 把所有的feature都扔进去，训练出一个模型 找出这个模型对应的p值最高的特征，如果大于0.05，扔掉，训练一个新的模型重复这个过程，直到没有特征的p值大于0.05","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://gunslingeratlarge.github.io/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://gunslingeratlarge.github.io/tags/机器学习/"}]},{"title":"java构造方法调用","slug":"java构造方法调用","date":"2018-06-02T08:36:00.000Z","updated":"2018-06-25T10:21:01.901Z","comments":true,"path":"2018/06/02/java构造方法调用/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/06/02/java构造方法调用/","excerpt":"","text":"无论是子类的有参构造方法还是无参构造方法都会隐含调用（如果没有显式调用）super()即父类的无参构造方法。请看代码示例。123456789101112131415161718192021222324252627282930package superDemo;public class Father &#123; public Father() &#123; System.out.println(\"father的无参数构造方法\"); &#125; public Father(String name) &#123; System.out.println(\"Father的有参构造方法\"); &#125;&#125;package superDemo;public class Son extends Father&#123; public Son() &#123; System.out.println(\"son的无参构造方法\"); &#125; public Son(String name) &#123; System.out.println(\"son的有参构造方法\"); &#125; public static void main(String[] args) &#123; Son s = new Son(\"son's name\"); &#125;&#125; 输出为：12father的无参数构造方法 son的有参构造方法","categories":[{"name":"Java","slug":"Java","permalink":"http://gunslingeratlarge.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://gunslingeratlarge.github.io/tags/Java/"}]},{"title":"java类加载器","slug":"java类加载器","date":"2018-06-02T05:02:00.000Z","updated":"2018-06-25T10:21:01.902Z","comments":true,"path":"2018/06/02/java类加载器/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/06/02/java类加载器/","excerpt":"概念类加载器就是加载.class字节码文件，有三种classloader，bootstrap，extclassloader和appclassloader，其中最后一个类加载器就是用来加载用户和第三方jar包的类加载器。当Class对象被加载到内存中以后，我们可以通过Class对象拿到它的类加载器，即Class对象记得是谁加载它的。而我们怎么获得字节码对象呢？（即Class对象）。回顾反射，有三种方式，Object.getClass(),类名.class，Class.forName()。通过ClassLoader 字节码对象.getClassLoader()获得类加载器，能够获得src（对应的存放class文件的位置：classes文件夹/bin文件夹）下任何一个资源文件。classLoader.getResource(&quot;&quot;),而这个参数是对于classLoader来说的，所以是相对于src的，所以src下的一个jdbc.properties可以直接用getResource(&quot;jdbc.properties&quot;)来得到。那么classloader的根目录是哪里呢？是null，即不能这样写。","text":"概念类加载器就是加载.class字节码文件，有三种classloader，bootstrap，extclassloader和appclassloader，其中最后一个类加载器就是用来加载用户和第三方jar包的类加载器。当Class对象被加载到内存中以后，我们可以通过Class对象拿到它的类加载器，即Class对象记得是谁加载它的。而我们怎么获得字节码对象呢？（即Class对象）。回顾反射，有三种方式，Object.getClass(),类名.class，Class.forName()。通过ClassLoader 字节码对象.getClassLoader()获得类加载器，能够获得src（对应的存放class文件的位置：classes文件夹/bin文件夹）下任何一个资源文件。classLoader.getResource(&quot;&quot;),而这个参数是对于classLoader来说的，所以是相对于src的，所以src下的一个jdbc.properties可以直接用getResource(&quot;jdbc.properties&quot;)来得到。那么classloader的根目录是哪里呢？是null，即不能这样写。我们有时还会看到这样一种用法，Class.getResource()，这又是怎么一回事呢？它又是从何处加载的呢？让我们一起来揭开它的神秘面纱吧。 path不以’/‘开头时，默认是从此类所在的包下取资源 path 以’/‘开头时，则是从ClassPath(即web项目的classes目录，java项目的bin目录)根下获取 我们有这样的目录结构：12345project -src -package lab11 -Demo.java -person.txt 下面这三种方式都可以获取到person.txt12345678910111213141516package lab11;public class Demo &#123; public static void main(String[] args) &#123; Class&lt;Demo&gt; demoClazz = Demo.class; ClassLoader classLoader = demoClazz.getClassLoader(); String path = classLoader.getResource(\"lab11/person.txt\").getPath(); System.out.println(path); String path2 = demoClazz.getResource(\"person.txt\").getPath(); System.out.println(path2); String path3 = demoClazz.getResource(\"/lab11/person.txt\").getPath(); System.out.println(path3); &#125;&#125; 这里，我们就对怎样通过classloader加载资源搞清楚了。鼓掌！","categories":[{"name":"Java","slug":"Java","permalink":"http://gunslingeratlarge.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://gunslingeratlarge.github.io/tags/Java/"}]},{"title":"设计模式 part5 结构模式（下）","slug":"设计模式-part5-结构模式（下）","date":"2018-05-31T08:07:00.000Z","updated":"2018-06-25T10:21:01.933Z","comments":true,"path":"2018/05/31/设计模式-part5-结构模式（下）/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/05/31/设计模式-part5-结构模式（下）/","excerpt":"外观模式（Facade）外观模式很简单。一个比较好的比喻就是基金和股票。以前需要用户自己去买股票，需要了解很多关于股票啊，国债之类的信息，后来由基金经理统一管理，这里的基金就是Facade，这样用户只需要和基金打交道就可以了。非常舒服。什么时候用外观模式？有遗留老系统，新的开发团队分两组，一组在老系统之上写一个Facade，另一组基于新的Facade接口作开发。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112Camara.java package facade; public class Camara &#123; public void turnOn() &#123; System.out.println(\"开启摄像头！\"); &#125; public void turnOff() &#123; System.out.println(\"关闭摄像头！\"); &#125; &#125; Light.java package facade; public class Light &#123; public void turnOn() &#123; System.out.println(\"开灯！\"); &#125; public void turnOff() &#123; System.out.println(\"关灯！\"); &#125; &#125; Sensor.java package facade; public class Sensor &#123; public void activate() &#123; System.out.println(\"开启感应器！\"); &#125; public void deactivate() &#123; System.out.println(\"关闭感应器！\"); &#125; &#125; MyFacade.java package facade; public class MyFacade &#123; private static Camara c1, c2; private static Light l1, l2, l3; private static Sensor s; static &#123; c1 = new Camara(); c2 = new Camara(); l1 = new Light(); l2 = new Light(); l3 = new Light(); s = new Sensor(); &#125; public static void activate() &#123; c1.turnOn(); c2.turnOn(); l1.turnOn(); l2.turnOn(); l3.turnOn(); s.activate(); &#125; public static void deactivate() &#123; c1.turnOff(); c2.turnOff(); l1.turnOff(); l2.turnOff(); l3.turnOff(); s.deactivate(); &#125; &#125; ClientTest.java package facade; public class ClientTest &#123; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub //打开 MyFacade.activate(); //关闭 MyFacade.deactivate(); &#125; &#125;","text":"外观模式（Facade）外观模式很简单。一个比较好的比喻就是基金和股票。以前需要用户自己去买股票，需要了解很多关于股票啊，国债之类的信息，后来由基金经理统一管理，这里的基金就是Facade，这样用户只需要和基金打交道就可以了。非常舒服。什么时候用外观模式？有遗留老系统，新的开发团队分两组，一组在老系统之上写一个Facade，另一组基于新的Facade接口作开发。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112Camara.java package facade; public class Camara &#123; public void turnOn() &#123; System.out.println(\"开启摄像头！\"); &#125; public void turnOff() &#123; System.out.println(\"关闭摄像头！\"); &#125; &#125; Light.java package facade; public class Light &#123; public void turnOn() &#123; System.out.println(\"开灯！\"); &#125; public void turnOff() &#123; System.out.println(\"关灯！\"); &#125; &#125; Sensor.java package facade; public class Sensor &#123; public void activate() &#123; System.out.println(\"开启感应器！\"); &#125; public void deactivate() &#123; System.out.println(\"关闭感应器！\"); &#125; &#125; MyFacade.java package facade; public class MyFacade &#123; private static Camara c1, c2; private static Light l1, l2, l3; private static Sensor s; static &#123; c1 = new Camara(); c2 = new Camara(); l1 = new Light(); l2 = new Light(); l3 = new Light(); s = new Sensor(); &#125; public static void activate() &#123; c1.turnOn(); c2.turnOn(); l1.turnOn(); l2.turnOn(); l3.turnOn(); s.activate(); &#125; public static void deactivate() &#123; c1.turnOff(); c2.turnOff(); l1.turnOff(); l2.turnOff(); l3.turnOff(); s.deactivate(); &#125; &#125; ClientTest.java package facade; public class ClientTest &#123; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub //打开 MyFacade.activate(); //关闭 MyFacade.deactivate(); &#125; &#125; 享元模式享元模式使得我们可以共享一些轻量级的对象，跟多例模式有点像。但是享元模式会把对象的状态分为内部状态（所有的享元都不会变的）和外部状态（同一个享元的不同之处）。共享的其实是享元的内部状态。外部状态作为参数传入进享元中。举个围棋的例子，围棋很多棋子，如果每一粒棋子都是对象，那么一盘围棋就有几百个对象。所以棋子能不能就创建两个对象呢？一个黑棋，一个白棋，然后将棋子的坐标作为外部状态传入到享元中，这样就用两个对象，但是使用这些棋子的时候有不同的位置了。享元模式由客户端，抽象享元类，具体享元类，和享元工厂组成的。对象由享元工厂制造。有时候会使得系统比较复杂，并且需要将状态外部化，可能比较复杂。享元模式与多例模式的区别？ 享元模式状态分为外部状态和状态，共享之间也可以有不同，但是多例模式共享是相同的。 示例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129package com.zcr.flyweight2;public class User&#123; private String name; public User(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; &#125; package com.zcr.flyweight2;//享元设计模式实现//网站抽象类public abstract class WebSite&#123; //“使用”方法需要传递“用户”对象 public abstract void Use(User user);&#125; package com.zcr.flyweight2;//具体的网站类public class ConcreteWebSite extends WebSite&#123; private String name = \"\"; public ConcreteWebSite(String name) &#123; this.name = name; &#125; @Override public void Use(User user) &#123; System.out.println(\"网站分类：\"+name+\"用户名：\"+user.getName()); &#125;&#125; package com.zcr.flyweight2;import java.util.Hashtable;//网站工厂public class WebsiteFactory&#123; private Hashtable&lt;String,WebSite&gt; flyweights = new Hashtable&lt;String, WebSite&gt;(); //获得网站分类 public WebSite GetWebSiteCategory(String key) &#123; //判断是否存在这个对象，如果存在则直接返回，若不存在，则实例化它再返回 if(!flyweights.contains(key)) &#123; flyweights.put(key, new ConcreteWebSite(key)); &#125; return flyweights.get(key); &#125; //获取网站分类的总数 public int GetWebSiteCount() &#123; return flyweights.size(); &#125;&#125; package com.zcr.flyweight2;public class FlyweightTest&#123; public static void main(String[] args) &#123; WebsiteFactory f = new WebsiteFactory(); WebSite fx = f.GetWebSiteCategory(\"产品展示\"); fx.Use(new User(\"小菜\")); WebSite fy = f.GetWebSiteCategory(\"产品展示\"); fy.Use(new User(\"大烟笼\")); WebSite fz = f.GetWebSiteCategory(\"产品展示\"); fz.Use(new User(\"大菜\")); WebSite fl = f.GetWebSiteCategory(\"博客\"); fl.Use(new User(\"老顽童\")); WebSite fm = f.GetWebSiteCategory(\"博客\"); fm.Use(new User(\"肥菜\")); WebSite fn = f.GetWebSiteCategory(\"博客\"); fn.Use(new User(\"小小斌\")); System.out.println(\"网站分类总数为：\" + f.GetWebSiteCount()); &#125;&#125; 运行结果 代理模式（非常重要）代理模式与装饰者模式的区别Proxy and Decorator both have the same interface as their wrapped types, but the proxy creates an instance under the hood, whereas the decorator takes an instance in the constructor即代理模式在初始化的时候自己创建了一个被代理对象，而装饰者模式是动态地给装饰者类传入了被装饰对象。所以这就导致了装饰者模式可以动态地对对象进行装饰，而代理模式则是在编译级别就确定好了对谁进行代理。用户不知道自己是给谁发的消息，因为都实现了同一个接口。 使用场景虚拟代理：如插入图像，可以先不加载。代理先打出”正在加载。。”，等到真正需要这个图片的时候再去读取这个图片。起到一个延迟加载的功能。远程代理安全代理：起到一些安全检查的功能 动态代理比较好的参考资料：https://www.bilibili.com/video/av23094347/?p=7运行时生成一个类（不是对象），java中的InvocationHandler就是一个生成代理类的接口。为什么要用动态代理：用户访问需要代理进行权限检查，所以有User和UserProxy，订单访问可能也需要代理进行权限检查，所以有Order和OrderProxy，文件访问也需要进行权限检查，所以有File和FileProxy，而UserProxy和OrderProxy以及FileProxy都进行的是权限检查功能，所以功能比较重复，因此我们想将它们简化到 一起，从而出现了动态代理。获得动态的代理对象—— 运行时动态地为Target对象（被代理对象）创建一个虚拟的代理对象。之所以说是动态的，是因为不再是在代码编写的层面来修改类了，而是在运行时通过反射在内存中动态地去修改Class字节码对象的一些功能。Proxy类（reflect包下）的类有一个静态方法叫newProxyInstance(),返回一个代理对象（这个代理对象就是动态生成的了），而它是谁的代理对象呢，根据参数来确定。我们先看一个简单的例子：这里的Target是目标对象的类，TargetInterface是目标对象实现的接口，我们动态生成的代理对象也应该是这个接口。（要不然没法代理）。所以要告诉Proxy的newProxyInstance这个静态方法，用哪个类加载器，有哪些接口，以及我方法怎么样去扩充（动态生成的代理对象是哪个类（by InvocationHandler））。 1234567891011121314151617181920212223242526272829public class ProxyTest &#123; @Test public void test1() &#123; //现在要动态地为Target创建一个代理，在Target的method前后进行一些操作 TargetInterface newProxyInstance = (TargetInterface) Proxy.newProxyInstance( Target.class.getClassLoader(), new Class[]&#123;TargetInterface.class&#125;, new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //这里proxy是干嘛的先不考虑，不要一步吃成胖子 System.out.println(\"调用目标对象的方法前我做一些事情...\"); //method就是对应的目标对象的那个方法（的字节码对象?），这里你要告诉method调用哪个对象的这个方法c Object invoke = method.invoke(new Target(),args); System.out.println(\"调用目标对象的方法后我做一些事情...\"); //返回目标对象的方法 return invoke; &#125; &#125; ); newProxyInstance.method1(); String method2 = newProxyInstance.method2(); System.out.println(method2); &#125;&#125; 也可以用target.getClass().getInterfaces()来获得接口的Class[]数组。代理对象调用接口响应的方法都是调用在InvocationHandler的匿名内部类中定义的invode方法。invoke的三个参数：proxy：就是代理对象。为什么要传入这个代理对象？若想知道，请看下面这篇文章，若不想知道，也不必过多管它。 简单来说就是你可以返回这个proxy以达成连续调用这个代理对象，因为如果不这样做的话你就没办法去得到它（this返回的是这个new InvocationHandler()对象）。实际开发中不会使用到。https://blog.csdn.net/bu2_int/article/details/60150319method：代表的是目标方法的字节码对象args:method所传入的参数 匿名内部类调用外部的局部变量需要定义为final，即不可被修改。（jdk1.8后可以不定义为final，但是还是不可被修改）我们还可以对method进行判断，实现对特定的方法进行功能增强。JDK的Proxy方法实现动态代理只能对接口进行动态代理，CGLIB可以实现对类的动态代理。下面给出一个动态代理的示例代码，有两个类分别是对数据库和磁盘进行增删改查，他们的代理类具有同样的功能即对查询方法进行增强，去cache中查找是否命中，若不命中再去对应的数据库或者磁盘上查找。代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139第五周作业1.AbstractDbOperator.javapackage hm5;public interface AbstractDbOperator &#123; public abstract void query(); public abstract void insert(); public abstract void delete(); public abstract void update();&#125;2.AbstractFileOperator.javapackage hm5;public interface AbstractFileOperator &#123; public abstract void query(); public abstract void insert(); public abstract void delete(); public abstract void update();&#125;3.CacheHandler.javapackage hm5;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class CacheHandler implements InvocationHandler&#123; private Object target; public CacheHandler(Object target) &#123; this.target = target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(\"判断是否是查询数据...\"); String methodName = method.getName(); if (methodName.equals(\"query\")) &#123; System.out.println(\"是查询数据，对cache进行查询。\"); //这里其实应该是if(cache为命中) System.out.println(\"cache未命中,执行原有方法\"); return method.invoke(target, args); &#125; else &#123; System.out.println(\"不是查询数据，正常执行。\"); return method.invoke(target, args); &#125; &#125;&#125;4.FileOperator.javapackage hm5;public class FileOperator implements AbstractFileOperator&#123; @Override public void query() &#123; System.out.println(\"对磁盘数据进行查询...\"); &#125; @Override public void insert() &#123; System.out.println(\"对磁盘进行插入...\"); &#125; @Override public void update() &#123; System.out.println(\"对磁盘进行更新...\"); &#125; @Override public void delete() &#123; System.out.println(\"对磁盘进行删除...\"); &#125;&#125;5.MysqlOperator.javapackage hm5;public class MysqlOperator implements AbstractDbOperator&#123; @Override public void query() &#123; System.out.println(\"对mysql数据库进行查询...\"); &#125; @Override public void insert() &#123; System.out.println(\"对mysql数据库进行插入...\"); &#125; @Override public void update() &#123; System.out.println(\"对mysql数据库进行更新...\"); &#125; @Override public void delete() &#123; System.out.println(\"对mysql数据库进行删除...\"); &#125;&#125;6.Test.javapackage hm5;import java.lang.reflect.Proxy;public class Test &#123; public static void main(String[] args) &#123; AbstractDbOperator dbOperator = new MysqlOperator(); AbstractFileOperator fileOperator = new FileOperator(); //动态生成的代理对象 AbstractDbOperator dbProxy= (AbstractDbOperator) Proxy.newProxyInstance( dbOperator.getClass().getClassLoader(), dbOperator.getClass().getInterfaces(), new CacheHandler(dbOperator) ); AbstractFileOperator fileProxy= (AbstractFileOperator)Proxy.newProxyInstance( fileOperator.getClass().getClassLoader(), fileOperator.getClass().getInterfaces(), new CacheHandler(fileOperator) ); dbProxy.update(); fileProxy.update(); dbProxy.delete(); fileProxy.delete(); dbProxy.query(); fileProxy.query(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://gunslingeratlarge.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://gunslingeratlarge.github.io/tags/Java/"},{"name":"设计模式","slug":"设计模式","permalink":"http://gunslingeratlarge.github.io/tags/设计模式/"}]},{"title":"BMI Calculator","slug":"BMI-Calculator","date":"2018-05-30T08:33:27.000Z","updated":"2018-06-25T10:21:01.890Z","comments":true,"path":"2018/05/30/BMI-Calculator/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/05/30/BMI-Calculator/","excerpt":"","text":"不显示title部分primaryStage.initStylt(stageStyle.UNDECORATED)String类型保留两位小数String.format(&quot;%.2f&quot;,num)好看的ui需要引入jfoenix这个库，真的好看 我怎样才能拖动一个undecorated的窗口呢？https://stackoverflow.com/questions/11780115/moving-an-undecorated-stage-in-javafx-21234567891011121314151617181920// allow the clock background to be used to drag the clock around.final Delta dragDelta = new Delta();layout.setOnMousePressed(new EventHandler&lt;MouseEvent&gt;() &#123; @Override public void handle(MouseEvent mouseEvent) &#123; // record a delta distance for the drag and drop operation. dragDelta.x = stage.getX() - mouseEvent.getScreenX(); dragDelta.y = stage.getY() - mouseEvent.getScreenY(); &#125;&#125;);layout.setOnMouseDragged(new EventHandler&lt;MouseEvent&gt;() &#123; @Override public void handle(MouseEvent mouseEvent) &#123; stage.setX(mouseEvent.getScreenX() + dragDelta.x); stage.setY(mouseEvent.getScreenY() + dragDelta.y); &#125;&#125;);...// records relative x and y co-ordinates.class Delta &#123; double x, y; &#125; 问题：我怎样才能在controller类里面拿到window对象呢？https://stackoverflow.com/questions/13015537/javafx-class-controller-stage-window-reference 1234@FXMLprivate Button closeBtn;Stage currentStage = (Stage)closeBtn.getScene().getWindow();currentStage.close();","categories":[],"tags":[]},{"title":"javafx","slug":"avafx-p","date":"2018-05-28T13:19:00.000Z","updated":"2018-06-25T10:21:01.899Z","comments":true,"path":"2018/05/28/avafx-p/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/05/28/avafx-p/","excerpt":"","text":"TreeView树形列表，树的每一个节点都是TreeItem,总的这棵树是TreeView1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import javafx.application.Application;import javafx.geometry.Insets;import javafx.scene.Scene;import javafx.scene.control.Button;import javafx.scene.control.TreeItem;import javafx.scene.control.TreeView;import javafx.scene.layout.VBox;import javafx.stage.Stage;public class Main extends Application &#123; Stage window; public static void main(String[] args) &#123; launch(args); &#125; @Override public void start(Stage primaryStage) throws Exception &#123; primaryStage.setTitle(\"What's for dinner?\"); window = primaryStage; //control TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(); root.setExpanded(true); TreeView&lt;String&gt; tree = new TreeView&lt;&gt;(root); tree.setShowRoot(false); TreeItem&lt;String&gt; vegetables, meat, onion, banana, tomato, beef, chicken; vegetables = makeBranch(\"vegetables\",root); meat = makeBranch(\"meat\",root); makeBranch(\"onion\",vegetables); makeBranch(\"banana\",vegetables); makeBranch(\"tomato\",vegetables); makeBranch(\"beef\",meat); makeBranch(\"chicken\",meat); tree.getSelectionModel().selectedItemProperty().addListener( (e, oldValue, newValue) -&gt; &#123; System.out.println(newValue.getValue()); &#125; ); Button b = new Button(\"choose\"); b.setOnAction(e -&gt; &#123; TreeItem&lt;String&gt; item = tree.getSelectionModel().getSelectedItem(); System.out.println(item.getValue()); &#125;); //layout VBox layout = new VBox(10); layout.setPadding(new Insets(20,20,20,20)); layout.getChildren().addAll(tree,b); Scene scene = new Scene(layout,300,300); window.setScene(scene); window.show(); &#125; //make branch: a leaf is also a branch(a TreeItem object) private TreeItem&lt;String&gt; makeBranch(String title, TreeItem&lt;String&gt; parent) &#123; TreeItem&lt;String&gt; item = new TreeItem&lt;&gt;(title); parent.getChildren().add(item); parent.setExpanded(true); return item; &#125;&#125; TableViewtableview还是比较简单的，主要是有几个column需要添加进去。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167import javafx.application.Application;import javafx.collections.FXCollections;import javafx.collections.ObservableList;import javafx.geometry.Insets;import javafx.scene.Scene;import javafx.scene.control.Button;import javafx.scene.control.SelectionMode;import javafx.scene.control.TableColumn;import javafx.scene.control.TableView;import javafx.scene.control.TextField;import javafx.scene.control.cell.PropertyValueFactory;import javafx.scene.layout.HBox;import javafx.scene.layout.VBox;import javafx.stage.Stage;public class Main extends Application &#123; Stage window; TextField nameInput; TextField quantityInput; TextField priceInput; TableView&lt;Product&gt; table; public static void main(String[] args) &#123; launch(args); &#125; @Override public void start(Stage primaryStage) throws Exception &#123; primaryStage.setTitle(&quot;What&apos;s for dinner?&quot;); window = primaryStage; //control //table columns: column name, data source, column data type //name column: TableColumn&lt;Product, String&gt; nameColumn = new TableColumn&lt;&gt;(&quot;商品名称&quot;); nameColumn.setMinWidth(200); nameColumn.setCellValueFactory(new PropertyValueFactory&lt;&gt;(&quot;name&quot;)); TableColumn&lt;Product, Integer&gt; quantityColumn = new TableColumn&lt;&gt;(&quot;商品数量&quot;); quantityColumn.setMinWidth(100); quantityColumn.setCellValueFactory(new PropertyValueFactory&lt;&gt;(&quot;quantity&quot;)); TableColumn&lt;Product, Double&gt; priceColumn = new TableColumn&lt;&gt;(&quot;商品价格&quot;); priceColumn.setMinWidth(150); priceColumn.setCellValueFactory(new PropertyValueFactory&lt;&gt;(&quot;price&quot;)); //add columns to tableview:add items(data source),add columns table = new TableView&lt;&gt;(); table.setItems(getProducts()); table.getColumns().addAll(nameColumn,quantityColumn,priceColumn); table.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE); //add edit area in hbox HBox hbox = new HBox(10); hbox.setPadding(new Insets(10,10,10,10)); hbox.setSpacing(10); //nameInput, quantityInput, priceInput, addButton, deleteButton nameInput = new TextField(); nameInput.setPromptText(&quot;商品名称&quot;); nameInput.setMinWidth(150); quantityInput = new TextField(); quantityInput.setPromptText(&quot;商品数量&quot;); quantityInput.setMinWidth(150); priceInput = new TextField(); priceInput.setPromptText(&quot;价格&quot;); quantityInput.setMinWidth(150); //button Button addButton = new Button(&quot;添加&quot;); Button deleteButton = new Button(&quot;删除&quot;); addButton.setOnAction(e -&gt; &#123; addButtonClicked(); &#125;); deleteButton.setOnAction(e -&gt; &#123; deleteButtonClicked(); &#125;); hbox.getChildren().addAll(nameInput,quantityInput,priceInput,addButton,deleteButton); //layout VBox layout = new VBox(); //layout.setPadding(new Insets(20,20,20,20)); layout.getChildren().addAll(table,hbox); layout.setMaxHeight(500); Scene scene = new Scene(layout); window.setScene(scene); window.show(); &#125; private void addButtonClicked() &#123; Product p = new Product(); p.setName(nameInput.getText()); p.setQuantity(Integer.parseInt(quantityInput.getText())); p.setPrice(Double.parseDouble(priceInput.getText())); table.getItems().add(p); nameInput.clear(); quantityInput.clear(); priceInput.clear(); &#125; private void deleteButtonClicked() &#123; ObservableList&lt;Product&gt; selected,allProducts; allProducts = FXCollections.observableArrayList(); selected = table.getSelectionModel().getSelectedItems(); for (Product p: table.getItems()) &#123; allProducts.add(p); &#125; for (Product p: selected) &#123; System.out.print(&quot;this is selected:&quot;); System.out.println(p.getName()); &#125; for (Product p: selected) &#123; System.out.println(&quot;going to delete: &quot; + p.getName()); allProducts.remove(p); &#125; System.out.println(&quot;deleted:&quot;); for (Product p: allProducts) &#123; System.out.println(p.getName()); &#125; System.out.println(&quot;---------&quot;); table.setItems(allProducts); &#125; //prepare data for tableview public ObservableList&lt;Product&gt; getProducts() &#123; ObservableList&lt;Product&gt; products = FXCollections.observableArrayList(); products.add(new Product(&quot;laptop&quot;,20,2000d)); products.add(new Product(&quot;soap&quot;,10,3d)); products.add(new Product(&quot;watermelon&quot;,2,40d)); products.add(new Product(&quot;bread&quot;,5,20d)); products.add(new Product(&quot;glasses&quot;,8,180d)); return products; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://gunslingeratlarge.github.io/categories/java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://gunslingeratlarge.github.io/tags/Java/"},{"name":"javafx","slug":"javafx","permalink":"http://gunslingeratlarge.github.io/tags/javafx/"},{"name":"gui","slug":"gui","permalink":"http://gunslingeratlarge.github.io/tags/gui/"}]},{"title":"NLTK p.2","slug":"NLTK-p-2","date":"2018-05-28T04:15:00.000Z","updated":"2018-06-25T10:21:01.893Z","comments":true,"path":"2018/05/28/NLTK-p-2/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/05/28/NLTK-p-2/","excerpt":"","text":"Chunking123456789101112131415161718192021222324252627282930import nltkfrom nltk.corpus import state_unionfrom nltk.tokenize import PunktSentenceTokenizertrain_text = state_union.raw(\"2005-GWBush.txt\")sample_text = state_union.raw(\"2006-GWBush.txt\")custom_sent_tokenizer = PunktSentenceTokenizer(train_text)tokenized = custom_sent_tokenizer.tokenize(sample_text)def process_content(): try: for i in tokenized: words = nltk.word_tokenize(i) tagged = nltk.pos_tag(words) chunkGram = r\"\"\"Chunk: &#123;&lt;RB.?&gt;*&lt;VB.?&gt;*&lt;NNP&gt;+&lt;NN&gt;?&#125;\"\"\" chunkParser = nltk.RegexpParser(chunkGram) chunked = chunkParser.parse(tagged) print(chunked) for subtree in chunked.subtrees(filter=lambda t: t.label() == 'Chunk'): print(subtree) chunked.draw() except Exception as e: print(str(e))process_content() Chinking从chunk得到的结果中去除掉某一些部分。1234567891011121314151617181920212223242526272829import nltkfrom nltk.corpus import state_unionfrom nltk.tokenize import PunktSentenceTokenizertrain_text = state_union.raw(\"2005-GWBush.txt\")sample_text = state_union.raw(\"2006-GWBush.txt\")custom_sent_tokenizer = PunktSentenceTokenizer(train_text)tokenized = custom_sent_tokenizer.tokenize(sample_text)def process_content(): try: for i in tokenized[5:]: words = nltk.word_tokenize(i) tagged = nltk.pos_tag(words) chunkGram = r\"\"\"Chunk: &#123;&lt;.*&gt;+&#125; &#125;&lt;VB.?|IN|DT|TO&gt;+&#123;\"\"\" chunkParser = nltk.RegexpParser(chunkGram) chunked = chunkParser.parse(tagged) chunked.draw() except Exception as e: print(str(e))process_content() 主要的区别就在于那个chunkGram里面加多了用反大括号括起来的部分。 Name Entity Recognition识别出命名实体1234567891011121314151617181920212223import nltkfrom nltk.corpus import state_unionfrom nltk.tokenize import PunktSentenceTokenizertrain_text = state_union.raw(\"2005-GWBush.txt\")sample_text = state_union.raw(\"2006-GWBush.txt\")custom_sent_tokenizer = PunktSentenceTokenizer(train_text)tokenized = custom_sent_tokenizer.tokenize(sample_text)def process_content(): try: for i in tokenized[5:]: words = nltk.word_tokenize(i) tagged = nltk.pos_tag(words) namedEnt = nltk.ne_chunk(tagged, binary=True) namedEnt.draw() except Exception as e: print(str(e))process_content() Lemmatizing类似stem，但是不同stem的是它的结果不再可能是一个不存在的词了，lemmatize的结果肯定是一个存在的词。如果必要的话可以通过pos=””属性来指定这个词的part of speech，如果不指定默认为noun。通常来说，lemmatize要比stem效果好。12345678910111213from nltk.stem import WordNetLemmatizerlemmatizer = WordNetLemmatizer()print(lemmatizer.lemmatize(\"cats\"))print(lemmatizer.lemmatize(\"cacti\"))print(lemmatizer.lemmatize(\"geese\"))print(lemmatizer.lemmatize(\"rocks\"))print(lemmatizer.lemmatize(\"python\"))print(lemmatizer.lemmatize(\"better\", pos=\"a\"))print(lemmatizer.lemmatize(\"best\", pos=\"a\"))print(lemmatizer.lemmatize(\"run\"))print(lemmatizer.lemmatize(\"run\",'v')) wordnetwordnet能够让我们很方便地找到近义词（或者反义词）1234567891011121314151617181920212223242526272829303132333435from nltk.corpus import wordnetsyns = wordnet.synsets(\"program\")print(syns[0].name())print(syns[0].lemmas()[0].name())print(syns[0].definition())print(syns[0].examples())synonyms = []antonyms = []for syn in wordnet.synsets(\"good\"): for l in syn.lemmas(): synonyms.append(l.name()) if l.antonyms(): antonyms.append(l.antonyms()[0].name())print(set(synonyms))print(set(antonyms))w1 = wordnet.synset('ship.n.01')w2 = wordnet.synset('boat.n.01')print(w1.wup_similarity(w2))## 0.9090909090909091w1 = wordnet.synset('ship.n.01')w2 = wordnet.synset('car.n.01')print(w1.wup_similarity(w2))## 0.6956521739130435w1 = wordnet.synset('ship.n.01')w2 = wordnet.synset('cat.n.01')print(w1.wup_similarity(w2))## 0.38095238095238093 text-classification文本分类的第一步，导入并随机化语料。这里导入的是两千条电影评论。12345678910111213141516171819import nltkimport randomfrom nltk.corpus import movie_reviewsdocuments = [(list(movie_reviews.words(fileid)), category) for category in movie_reviews.categories() for fileid in movie_reviews.fileids(category)]random.shuffle(documents)print(documents[1])all_words = []for w in movie_reviews.words(): all_words.append(w.lower())all_words = nltk.FreqDist(all_words)print(all_words.most_common(15))print(all_words[\"stupid\"])","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://gunslingeratlarge.github.io/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://gunslingeratlarge.github.io/tags/机器学习/"},{"name":"nltk","slug":"nltk","permalink":"http://gunslingeratlarge.github.io/tags/nltk/"},{"name":"nlp","slug":"nlp","permalink":"http://gunslingeratlarge.github.io/tags/nlp/"}]},{"title":"NLTK ","slug":"NLTK","date":"2018-05-28T02:37:00.000Z","updated":"2018-06-25T10:21:01.893Z","comments":true,"path":"2018/05/28/NLTK/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/05/28/NLTK/","excerpt":"介绍conda install nltk tokenize：分词 stopwords：停用词 stem：取词根 part of speech tagging：词性标注 chunking：分块 chinking： 分块的对立面，从chunking中去除某些部分 Name Entity Recognition：识别名词（词组）本篇笔记基于https://pythonprogramming.net/tokenizing-words-sentences-nltk-tutorial/ 完成。","text":"介绍conda install nltk tokenize：分词 stopwords：停用词 stem：取词根 part of speech tagging：词性标注 chunking：分块 chinking： 分块的对立面，从chunking中去除某些部分 Name Entity Recognition：识别名词（词组）本篇笔记基于https://pythonprogramming.net/tokenizing-words-sentences-nltk-tutorial/ 完成。 tokenize12import nltk nltk.download() 下载nltk的数据包，或者直接下载完整的nltk_data文件放到对应的路径下。2018.05.18 update：链接: https://pan.baidu.com/s/1UfJhJY9bJ9hqeTuzKxgQvw 密码: 2ce51234567from nltk.tokenize import sent_tokenize, word_tokenizeEXAMPLE_TEXT = \"Hello Mr. Smith, how are you doing today? The weather is great, and Python is awesome. The sky is pinkish-blue. You shouldn't eat cardboard.\"print(sent_tokenize(EXAMPLE_TEXT))print(word_tokenize(EXAMPLE_TEXT)) stopwords12345678910111213141516171819from nltk.corpus import stopwordsfrom nltk.tokenize import word_tokenizeexample_sent = \"This is a sample sentence, showing off the stop words filtration.\"stop_words = set(stopwords.words('english'))word_tokens = word_tokenize(example_sent)filtered_sentence = [w for w in word_tokens if not w in stop_words]filtered_sentence = []for w in word_tokens: if w not in stop_words: filtered_sentence.append(w)print(word_tokens)print(filtered_sentence) stemstem出来的效果感觉并不是很好。而且这个只是英文文本才有的变化，中文里没有各种时态和语态1234567891011121314from nltk.stem import PorterStemmerfrom nltk.tokenize import sent_tokenize, word_tokenizeps = PorterStemmer()example_words = [\"python\",\"pythoner\",\"pythoning\",\"pythoned\",\"pythonly\"]for w in example_words: print(ps.stem(w)) new_text = \"It is important to by very pythonly while you are pythoning with python. All pythoners have pythoned poorly at least once.\"words = word_tokenize(new_text)for w in words: print(ps.stem(w)) part of speech tagging词性标注也属于英文特有吧。将一个句子里的每一个成分都标注出来，后面的chunking和chinking也会用到。12345678910111213141516171819202122232425262728293031323334353637POS tag list:CC coordinating conjunctionCD cardinal digitDT determinerEX existential there (like: &quot;there is&quot; ... think of it like &quot;there exists&quot;)FW foreign wordIN preposition/subordinating conjunctionJJ adjective &apos;big&apos;JJR adjective, comparative &apos;bigger&apos;JJS adjective, superlative &apos;biggest&apos;LS list marker 1)MD modal could, willNN noun, singular &apos;desk&apos;NNS noun plural &apos;desks&apos;NNP proper noun, singular &apos;Harrison&apos;NNPS proper noun, plural &apos;Americans&apos;PDT predeterminer &apos;all the kids&apos;POS possessive ending parent\\&apos;sPRP personal pronoun I, he, shePRP$ possessive pronoun my, his, hersRB adverb very, silently,RBR adverb, comparative betterRBS adverb, superlative bestRP particle give upTO to go &apos;to&apos; the store.UH interjection errrrrrrrmVB verb, base form takeVBD verb, past tense tookVBG verb, gerund/present participle takingVBN verb, past participle takenVBP verb, sing. present, non-3d takeVBZ verb, 3rd person sing. present takesWDT wh-determiner whichWP wh-pronoun who, whatWP$ possessive wh-pronoun whoseWRB wh-abverb where, when 使用的代码：12345678910111213141516171819202122import nltkfrom nltk.corpus import state_unionfrom nltk.tokenize import PunktSentenceTokenizertrain_text = state_union.raw(\"2005-GWBush.txt\")sample_text = state_union.raw(\"2006-GWBush.txt\")custom_sent_tokenizer = PunktSentenceTokenizer(train_text)tokenized = custom_sent_tokenizer.tokenize(sample_text)def process_content(): try: for i in tokenized[:5]: words = nltk.word_tokenize(i) tagged = nltk.pos_tag(words) print(tagged) except Exception as e: print(str(e))process_content()","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://gunslingeratlarge.github.io/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://gunslingeratlarge.github.io/tags/机器学习/"},{"name":"nlp","slug":"nlp","permalink":"http://gunslingeratlarge.github.io/tags/nlp/"}]},{"title":"SVD","slug":"SVD","date":"2018-05-27T05:04:00.000Z","updated":"2018-06-25T10:21:01.898Z","comments":true,"path":"2018/05/27/SVD/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/05/27/SVD/","excerpt":"","text":"介绍SVD指的是Singular Value Decomposition，奇异值分解。简单理解就是把一个矩阵（m × n）的矩阵分解为3部分，即$u∑v^t$。SVD是PCA即主成分分析的一种，就是保留矩阵中比较重要的部分信息，去掉不那么重要的信息。这里面的u和t是正交矩阵，v是对角线矩阵（diagonal matrix），并且每一个元素非负。https://www.youtube.com/watch?v=mBcLRGuAFUk 这个视频在简短的时间对svd作了介绍。 如何进行SVD呢？https://www.youtube.com/watch?v=cOUTpqlX-Xs 这个视频很好地演示了如何对一个简单的矩阵手动进行svd。主要的思路就是在等式两边同时乘以v的转置，就把问题转化为了就特征向量和特征值的问题了。目前我还没有搞清楚的点是，正交矩阵有些什么特点，为什么 A\\cdot A^t = I以及求出某个矩阵的特征值之后怎样求出它的特征向量？除此之外SVD是怎样应用到机器学习上的，也值得进一步的了解。 正交矩阵首先，什么是正交矩阵。正交矩阵一定是一个方阵。它的每一列都是一个向量，这个向量和其他的这个矩阵里的列向量是正交的。（点乘起来是0，自己和自己点乘是1（这个列向量单位化为1））。正交矩阵的性质： Q\\cdot Q^t = I也就是Q^{-1} = Q^t","categories":[{"name":"数学","slug":"数学","permalink":"http://gunslingeratlarge.github.io/categories/数学/"},{"name":"线性代数","slug":"数学/线性代数","permalink":"http://gunslingeratlarge.github.io/categories/数学/线性代数/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://gunslingeratlarge.github.io/tags/机器学习/"},{"name":"线性代数","slug":"线性代数","permalink":"http://gunslingeratlarge.github.io/tags/线性代数/"}]},{"title":"设计模式 part4  结构模式 （上）","slug":"设计模式-part4-结构模式-（上）","date":"2018-05-23T04:06:00.000Z","updated":"2018-06-25T10:21:01.932Z","comments":true,"path":"2018/05/23/设计模式-part4-结构模式-（上）/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/05/23/设计模式-part4-结构模式-（上）/","excerpt":"分类适配器 桥接 组合 装饰者 适配器（Adapter）把一个类的接口变换成客户端所期待的另一种接口，使因接口不匹配的类能一起工作。变压器模式——把一种电压变换成另一种电压。或者类似我们出国用的插口转换器。又如HDMI转VGA。又叫包装模式，wrapper模式。一般是将被适配者包在里面。 分类类适配器：需要利用多重继承对象适配器：Adapter把Adaptee包进来，聚合进来。用得比较广泛。比类适配器用得更多。因为多重继承是不太好的。","text":"分类适配器 桥接 组合 装饰者 适配器（Adapter）把一个类的接口变换成客户端所期待的另一种接口，使因接口不匹配的类能一起工作。变压器模式——把一种电压变换成另一种电压。或者类似我们出国用的插口转换器。又如HDMI转VGA。又叫包装模式，wrapper模式。一般是将被适配者包在里面。 分类类适配器：需要利用多重继承对象适配器：Adapter把Adaptee包进来，聚合进来。用得比较广泛。比类适配器用得更多。因为多重继承是不太好的。 使用条件希望使用一个现有已存在的类，它的接口又与希望的接口不匹配。要产生一个中间类。 例子桥模式（Bridge）将抽象化与实现化脱耦。用组合聚合来代替继承关系，从而使两者可以相对独立地变化。实际上就是对变化的封装。桥模式和适配器模式有什么区别？ 感觉都有聚合/组合，即包含的关系。 两种变化维度就要考虑桥模式。就会设计到排列组合。比如加奶咖啡和不加奶咖啡，大杯咖啡，小贝咖啡。一个好的设计没有两个以上的变化因素。 组合模式抽象节点 树叶节点 树枝节点树枝节点可能含有其他的树叶节点或者树枝节点。树叶节点就像文件，树枝节点可能包含树叶和其他树枝节点。树枝节点就像文件夹，可以包含其他文件和文件夹。组合模式有一点递归的感觉。 组合模式最常见的也是最好理解的例子就是文件夹了。https://www.cnblogs.com/lfxiao/p/6816026.html 装饰者模式是继承关系的一个替代方案。在不创造更多子类的情况下，将对象的功能加以扩展。给对象而不是类添加功能。扩展功能更为灵活。比如给Text对象加边框或者加滚动条。 在运行时改变对象的行为。装饰者has a 并且是 is a。从奶茶的例子讲起，如果你有很多款奶茶，你怎么样实现给奶茶添加很多的料，比如奶盖，波霸，珍珠，加不加冰之类的？如果你使用继承，那么你会有很多子类，并且会有子类的排列组合，比如奶盖奶茶，波霸奶茶，奶盖波霸奶茶，奶盖珍珠奶茶。。会造成类爆炸的现象。所以这个时候就是装饰者模式出手了。 装饰者模式就是一层套一层的，每一层都是上一层的装饰。看这张uml图： 在装饰者模式中，所有的类都是Tea（也就是Component），而装饰者也是Tea，并且装饰者里面有变量Tea，这样的好处是一层包一层，装饰者里面包的Tea也可以是装饰者。而不同的具体装饰者就可以有不同的处理方法，比如说定不同的价格。但是实际上装饰者模式更适用于每一个装饰者与装饰者之间差别比较大，不仅仅是值的差别的时候。如果像我们给出的这个例子只是价格不同的话，其实在创建Tea的时候传入一个addons的列表就可以了，然后在Tea中计算价格的时候就遍历一下这个列表就可以了。这里我们还是回到我们的这个例子，我们要一个加冰的MilkTea的时候，就将MilkTea传入IceDecorator，如果还要加珍珠，就将上一个IceDecorator传入到PearlDecorator里面就可以了。更详细的内容请看https://www.youtube.com/watch?v=GCraGHx6gso。 组合模式示例代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231.AbstractFile.javapackage hm4;public abstract class AbstractFile &#123; public void add(AbstractFile abstractFile) &#123; throw new UnsupportedOperationException(\"不支持该操作\"); &#125;; public void remove(AbstractFile abstractFile) &#123; throw new UnsupportedOperationException(\"不支持该操作\"); &#125; public AbstractFile getChild(int i) &#123; throw new UnsupportedOperationException(\"不支持该操作\"); &#125; //对文件执行操作 public abstract void operation();&#125;2.File.javapackage hm4;public class File extends AbstractFile&#123; private String name; public File(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public void operation() &#123; System.out.println(\"对文件\"+ name +\"执行相应操作\"); &#125;&#125;3.Folder.javapackage hm4;import java.util.ArrayList;import java.util.List;public class Folder extends AbstractFile &#123; List&lt;AbstractFile&gt; files = new ArrayList&lt;&gt;(); private String name; public Folder(String name) &#123; this.name = name; &#125; public List&lt;AbstractFile&gt; getFiles() &#123; return files; &#125; public void setFiles(List&lt;AbstractFile&gt; files) &#123; this.files = files; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public void add(AbstractFile file) &#123; files.add(file); &#125; @Override public void remove(AbstractFile file) &#123; files.remove(file); &#125; public AbstractFile get(int i) &#123; return files.get(i); &#125; @Override public void operation() &#123; System.out.println(\"对文件夹\" + name + \"进行操作！\"); for (AbstractFile file : files) &#123; file.operation(); &#125; &#125;&#125;4.Test.javapackage hm4;public class Test &#123; public static void main(String[] args) &#123; AbstractFile totalFolder = new Folder(\"总文件夹\"); AbstractFile folder1 = new Folder(\"文本文件\"); AbstractFile folder2 = new Folder(\"图片文件\"); AbstractFile img1 = new File(\"图片1\"); AbstractFile img2 = new File(\"图片2\"); AbstractFile txt1 = new File(\"文本1\"); AbstractFile txt2 = new File(\"文本2\"); folder1.add(txt1); folder1.add(txt2); folder2.add(img1); folder2.add(img2); totalFolder.add(folder1); totalFolder.add(folder2); totalFolder.operation(); &#125;&#125; 装饰者模式示例代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131.AbstractDbOperator.javapackage hm4_2;public abstract class AbstractDbOperator &#123; public abstract void query(); public abstract void insert(); public abstract void delete(); public abstract void update();&#125;2.DbOperator.javapackage hm4_2;public class DbOperator extends AbstractDbOperator&#123; @Override public void query() &#123; System.out.println(\"对数据库进行查询...\"); &#125; @Override public void insert() &#123; System.out.println(\"对数据库进行插入...\"); &#125; @Override public void update() &#123; System.out.println(\"对数据库进行更新...\"); &#125; @Override public void delete() &#123; System.out.println(\"对数据库进行删除...\"); &#125;&#125;3.AbstractDecorator.javapackage hm4_2;public abstract class AbstractDecorator extends AbstractDbOperator &#123; private AbstractDbOperator operator; public AbstractDecorator(AbstractDbOperator operator) &#123; this.operator = operator; &#125; @Override public void query() &#123; operator.query(); &#125; @Override public void insert() &#123; operator.insert(); &#125; @Override public void update() &#123; operator.update(); &#125; @Override public void delete() &#123; operator.delete(); &#125;&#125;4.CacheDecorator.javapackage hm4_2;public class CacheDecorator extends AbstractDecorator&#123; public CacheDecorator(AbstractDbOperator operator) &#123; super(operator); &#125; @Override public void query() &#123; System.out.println(\"进行缓存查询...\"); //如果缓存中没有，再进行这一步 super.query(); &#125;&#125;5.SafeDecorator.javapackage hm4_2;public class SafeDecorator extends AbstractDecorator&#123; public SafeDecorator(AbstractDbOperator operator) &#123; super(operator); &#125; @Override public void update() &#123; System.out.println(\"进行安全检查...\"); super.update(); &#125;&#125;6.Test.javapackage hm4_2;public class Test &#123; public static void main(String[] args) &#123; AbstractDbOperator operator = new DbOperator(); AbstractDecorator cached = new CacheDecorator(operator); cached.query(); cached.update(); AbstractDecorator safeCheck = new SafeDecorator(cached); safeCheck.query(); safeCheck.update(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://gunslingeratlarge.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://gunslingeratlarge.github.io/tags/Java/"},{"name":"设计模式","slug":"设计模式","permalink":"http://gunslingeratlarge.github.io/tags/设计模式/"}]},{"title":"一个完整的DAO类的示例代码","slug":"一个完整的DAO类的示例代码","date":"2018-05-22T12:01:00.000Z","updated":"2018-06-25T10:21:01.917Z","comments":true,"path":"2018/05/22/一个完整的DAO类的示例代码/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/05/22/一个完整的DAO类的示例代码/","excerpt":"一个DAO类，一般包括对对应的POJO类的增删改查操作。有这么几个注意点： 引入的是java.sql.xxx，以mysql开头的一律不引入。 可以用PreparedStatement也可以用Statement，如果要设置参数就用PreparedStatement，不设置参数就用Statement try(){}catch(){}这种结构是1.7之后出现的，可以自动帮你关闭在try之后小括号中实现了Closeble接口的对象。 如何在dao中加入了一条数据之后马上获得它的id？通过ps.getGeneratedKeys()获取到自增长id","text":"一个DAO类，一般包括对对应的POJO类的增删改查操作。有这么几个注意点： 引入的是java.sql.xxx，以mysql开头的一律不引入。 可以用PreparedStatement也可以用Statement，如果要设置参数就用PreparedStatement，不设置参数就用Statement try(){}catch(){}这种结构是1.7之后出现的，可以自动帮你关闭在try之后小括号中实现了Closeble接口的对象。 如何在dao中加入了一条数据之后马上获得它的id？通过ps.getGeneratedKeys()获取到自增长id 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136package mymall.dao;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;import java.util.ArrayList;import java.util.List;import mymall.utils.DBUtil;import mytmall.bean.Category;public class CategoryDao &#123; //提供对category的CRUD add delete update get list list(start,count), gettotal //后面全是查，查一个，列所有，最后两个是为了分页用的 public void add(Category bean) &#123; String sql = \"insert into category values(null,?)\"; try( Connection c = DBUtil.getConnection(); PreparedStatement ps = c.prepareStatement(sql); ) &#123; ps.setString(1, bean.getName()); ps.execute(); ResultSet rs = ps.getGeneratedKeys(); if (rs.next()) &#123; bean.setId(rs.getInt(1)); &#125; &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; public void delete(int id) &#123; String sql = \"delete from category where id = ?\"; try( Connection c = DBUtil.getConnection(); PreparedStatement ps = c.prepareStatement(sql); ) &#123; ps.setInt(1, id); ps.execute(); &#125; catch(SQLException e) &#123; e.printStackTrace(); &#125; &#125;; public void update(Category bean) &#123; String sql = \"update category set name = ? where id = ?\"; try( Connection c = DBUtil.getConnection(); PreparedStatement ps = c.prepareStatement(sql); ) &#123; ps.setInt(2, bean.getId()); ps.setString(1, bean.getName()); ps.execute(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; //get单个，查找list，gettotal public Category get(int id) &#123; String sql = \"select * from category where id = \" + id; Category bean = new Category(); try(Connection c = DBUtil.getConnection(); Statement s = c.createStatement();) &#123; ResultSet rs = s.executeQuery(sql); if (rs.next()) &#123; bean.setId(rs.getInt(1)); bean.setName(rs.getString(2)); &#125; &#125; catch(SQLException e) &#123; e.printStackTrace(); &#125; return bean; &#125; //查询所有 public List&lt;Category&gt; list() &#123; return list(0,Short.MAX_VALUE); &#125; //分页查询 public List&lt;Category&gt; list(int start, int count) &#123; String sql = \"select * from category order by id desc limit ?, ?\"; List&lt;Category&gt; beans = new ArrayList&lt;Category&gt;(); try(Connection c = DBUtil.getConnection(); PreparedStatement ps = c.prepareStatement(sql); ) &#123; ps.setInt(1,start); ps.setInt(2,count); ResultSet rs = ps.executeQuery(); while(rs.next()) &#123; Category bean = new Category(); bean.setId(rs.getInt(\"id\")); bean.setName(rs.getString(\"name\")); beans.add(bean); &#125; &#125;catch(SQLException e) &#123; e.printStackTrace(); &#125; return beans; &#125; public int getTotal() &#123; String sql = \"select count(*) from category\"; int total = 0; try(Connection c = DBUtil.getConnection(); Statement s = c.createStatement();) &#123; ResultSet rs = s.executeQuery(sql); if (rs.next()) &#123; total = rs.getInt(1); &#125; &#125; catch(SQLException e) &#123; e.printStackTrace(); &#125; return total; &#125; public static void main(String[] args) &#123; CategoryDao dao = new CategoryDao(); Category category = dao.get(1); System.out.println(category.getName()); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://gunslingeratlarge.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://gunslingeratlarge.github.io/tags/Java/"}]},{"title":"数据库范式","slug":"数据库范式","date":"2018-05-21T11:47:00.000Z","updated":"2018-06-25T10:21:01.928Z","comments":true,"path":"2018/05/21/数据库范式/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/05/21/数据库范式/","excerpt":"","text":"详细的内容见https://www.zhihu.com/question/24696366 我的一些小总结第一范式（1NF）第一范式是所有关系型数据库天然满足的，即每个属性（每一列）不可再分割了。但能不能再分割也是你说了算，比如中国人的姓名可能就不用分割了，但是外国人可能姓和名单独拿出来有不同的用途，就可以分割。 第二范式（2NF）第二范式在第一范式的基础上满足：所有的非主属性对码是完全依赖的。也就是说一个非主属性，不能只由码中的一部分就完全确定了。这个时候就要进行模式分解了。 第三范式（3NF）在第二范式的基础上消除了非主属性对于码的传递依赖。比如说一张学生表有学号，宿舍号，宿舍地址等等信息，宿舍号依赖于学号，然后宿舍地址又依赖于宿舍号，所以宿舍地址对于学号就有传递依赖，因此就不满足第三范式。当不满足第三范式的时候会出现两个问题：如果你删除了所有的学生信息，全部的宿舍信息都烟消云散了，第二个问题是如果你要添加空的宿舍信息你也无从下手。","categories":[],"tags":[]},{"title":"设计模式 part3 创建模式 下","slug":"设计模式-part3-创建模式-下","date":"2018-05-15T02:34:00.000Z","updated":"2018-06-25T10:21:01.932Z","comments":true,"path":"2018/05/15/设计模式-part3-创建模式-下/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/05/15/设计模式-part3-创建模式-下/","excerpt":"建造者（builder）模式理解建造者模式其实是把一个复杂对象的各个部分的建造和这各个部分建造的顺序和整体的构建算法（如何体现？）。Director中封装的就是构建的过程，这些通常是不变的。 参与者抽象建造者（Builder）：建造者的抽象接口。需要建造的对象里面有多少个零件就规定了多少个方法，除此之外再有一个RetrieveResult()方法，返回最终产品对象。指导者（Director）:负责与用户进行沟通，并实例化建造者。这样用户就不知道你要建造的对象是由几部分组成了。并且可以将构建的顺序放到director中。Director是知道你要先造什么，后造什么的。比如你要造一个机器人，这个机器人有四部分，builder只知道每部分怎么造，以及我怎么样将各部分组装到正确的位置，但是先造什么，后造什么，builder是不知道的。要靠Director来指挥。具体建造者（ConcreteteBuilder）：实现了抽象建造者的build各个部分的方法。处理具体建造各部分的逻辑。产品（Product）：需要建造的复杂对象","text":"建造者（builder）模式理解建造者模式其实是把一个复杂对象的各个部分的建造和这各个部分建造的顺序和整体的构建算法（如何体现？）。Director中封装的就是构建的过程，这些通常是不变的。 参与者抽象建造者（Builder）：建造者的抽象接口。需要建造的对象里面有多少个零件就规定了多少个方法，除此之外再有一个RetrieveResult()方法，返回最终产品对象。指导者（Director）:负责与用户进行沟通，并实例化建造者。这样用户就不知道你要建造的对象是由几部分组成了。并且可以将构建的顺序放到director中。Director是知道你要先造什么，后造什么的。比如你要造一个机器人，这个机器人有四部分，builder只知道每部分怎么造，以及我怎么样将各部分组装到正确的位置，但是先造什么，后造什么，builder是不知道的。要靠Director来指挥。具体建造者（ConcreteteBuilder）：实现了抽象建造者的build各个部分的方法。处理具体建造各部分的逻辑。产品（Product）：需要建造的复杂对象 示例代码建造一个机器人，由四部分组成，机器人头，机器人身体，机器人脚，机器人手臂。 Director12345678public class Director &#123; public void construct(RobotBuilder builder)&#123; builder.buildHead(); builder.buildBody(); builder.buildArms(); builder.buildLegs(); &#125;&#125; Director中负责构造的顺序（其实还有其他复杂的组建的逻辑，但是我不知道可以怎样体现出来），一定是先头-&gt;身体-&gt;手臂-&gt;脚的这个顺序。 Builder1234567public abstract class RobotBuilder &#123; public abstract void buildHead(); public abstract void buildBody(); public abstract void buildArms(); public abstract void buildLegs(); public abstract Robot getRobot();&#125; ConcreteBuilder1234567891011121314151617181920212223 public class LegoRobotBuilder extends RobotBuilder &#123; Robot robot = new Robot(); public void buildHead()&#123; System.out.println(\"组装头部\"); robot.add(\"头部\"); &#125; public void buildBody()&#123; System.out.println(\"组装身子\"); robot.add(\"身子\"); &#125; public void buildArms()&#123; System.out.println(\"组装手臂\"); robot.add(\"手臂\"); &#125; public void buildLegs()&#123; System.out.println(\"组装腿部\"); robot.add(\"腿部\"); &#125; public Robot getRobot() &#123; return robot; &#125;&#125; 原型模式待续… 单例模式特点每一个类只能创造一个对象，将构造函数私有化，通过 多例模式","categories":[{"name":"Java","slug":"Java","permalink":"http://gunslingeratlarge.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://gunslingeratlarge.github.io/tags/Java/"},{"name":"设计模式","slug":"设计模式","permalink":"http://gunslingeratlarge.github.io/tags/设计模式/"}]},{"title":"设计模式part1 简介","slug":"设计模式part1-简介","date":"2018-05-08T10:24:29.000Z","updated":"2018-06-25T10:21:01.933Z","comments":true,"path":"2018/05/08/设计模式part1-简介/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/05/08/设计模式part1-简介/","excerpt":"","text":"四个基本要素模式名称、问题、解决方案、后果 模式分类 代码模式 设计模式 创建模式 结构性模式 行为模式 架构模式 设计原则提高系统复用性的设计原则。设计模式是招式，而这些是内功。 开-闭原则真正的宗旨和目标。一个实体应该对扩展开放，对修改关闭。即在设计一个模块的时候，应当使这个模块可以在较小修改的前提下被扩展。并可以在不必修改源代码的情况下改变这个模块的行为。解决方案：抽象化。系统定义一个不可更改的抽象层。开闭原则的工程思想：对可变性的封装。一种可变性不应当与另一种可变性混合。所有的类图的继承结构一般都不会超过两层，不然就意味着将两种不同的可变性混合。将条件转移语句改写为多态（谨慎使用，可能会造成多态污染） 里氏代换原则在所有场合，子类必须能够替代父类。method(father）必然可以method(son)。 （问题：java里的多态不就天然满足这一条了吗？）。违反里氏代换原则必然违背开闭原则，反之则不然。里氏代换对编程的要求： 子类必须具备基类的全部接口 子类必须包括比基类型更宽的接口。（private-&gt;protected-&gt;public） 在语义上也必须满足里氏代换原则。即鸟为基类有飞的方法，然后子类有fly方法，但是一调用就throw异常，这会通过编译器的检查（syntax），但是语义上就不正确，因此要自己保证，必须是扩展子类的方法。 依赖倒转原则要依赖于抽象，不要依赖于实现。比如要依赖于List，不要依赖于ArrayList。再比如一个网站有登录的功能，可能是扫描人脸登录，指纹登录，或者用户名密码登录，如果说你整个系统都是依赖于用户名密码登录的，那么就不满足这个原则了，因为你的抽象层次依赖于了具体的层次。正确的做法是依赖于登录的接口，就可以更容易地更改登录的实现。做法：面向接口编程。比如以下情况：声明变量类型、声明方法的返回类型、数据类型的转换等等。比如声明一个List而不是一个ArrayList，表示我关注的只是一个List，而不是ArrayList。耦合关系： 零耦合 抽象耦合 具体耦合 依赖倒转可以从具体耦合到抽象耦合。不容易实现：会导致大量的类，维护难度大。不排除有一些具体类相当稳定。 接口隔离原则一个类对另一个类的依赖性应当建立在最小的接口上。比如A依赖B中的一个方法，结果你给我10个方法，我只用到1个方法。尽可能让一个类依赖少的东西。使用多个专门的接口比使用一个接口更好。 合成/聚合复用原则尽量使用合成/聚合而不是继承来达到对实现的复用。继承只使用于”is a”关系，比如大杯咖啡是不加奶咖啡吗？不是，所以最好不用要继承。继承的缺点：将超类的实现细节暴露给子类；超类的改变，使得子类的实现也不得不发生改变（自动就随之而变了）。这里注意，子类里面不能访问父类的private方法和变量，但是如果子类继承了父类的public方法，而这个方法又调用了父类的private变量是可以的。而遵循合成/聚合复用法则的话，就可以将已有的对象纳入到新对象中，成为新对象的一部分，新的对象可以调用已有对象的功能。比如人（新对象）有一双手（成分对象），这里手就是一个接口。优点： 黑盒复用 需要的依赖较少 每一个新的类可以聚焦 可以动态修改 缺点： 类比较多 合成与聚合的区别聚合：整体与部分的关系——鸟与鸟群合成：强得多的拥有关系——人与脑袋，部分和整体的生命周期相同。新对象拥有对组成部分的支配权 迪米特法则一个对象应当对其他对象有尽可能少的了解。最少知识原则表述： 只与你直接的朋友们通信 不要与陌生人说话如果两个类不必彼此直接通信，那么应该通过第三个类来调用方法。再比如员工与区域经理与总经理，员工不要与总经理直接通信，不要越权操作。（怎么判断越权操作了呢？） 设计原则应用实例分析题目：用类FileName描述文件名。有人认为FileName是string类的特殊情况．因此应当把FileName设计成string类的子类，然后加上FileName类所需的方法。请用里氏代换原则分析这个做法是否正确。 回答：里氏代换原则：如果一个方法对一个基类成立的话．那么一定适用于其子类。FileName类如果是string的子类，那么应实现string的所有方法。string有方法add:string+string→string。但 add:FileName+FileName不一定成立即文件名相加却不一定给出一个新的有效 文件名。即 FileName对象并不能实现 striog 对象的所有行为。（Filename是字符串，但是不是String类）。 题目：用迪米特法则考察下列说法用迪米特法则考察下面的说法： 你走你的阳关道，我走我的独木桥。 井水不犯河水。 城门失火，殃及池鱼 四海之内皆兄弟。 答案:1 ． 2 ．ＯＫ这两个说法都是建议减少与外界的联系。这样一旦外界出现变化，不会立即波及到自身。它们都是迪米特法则的同义语3 ．这个说法是从反面说明迪米特法则的重要性。当城门失火的时候，人们会使月护城河的水救火，自然就会影响到护城何中的鱼。聪明的鱼应当生活在远离城门的地方．这是来自迪米特法则的建议。4 ．是违背迪米特法则的，如果系统的软件模块都像兄弟一样“亲近”，系统的设计就是失败的。","categories":[],"tags":[]},{"title":"mybatis快速入门 part3","slug":"mybatis快速入门-part3","date":"2018-05-07T07:38:00.000Z","updated":"2018-06-25T10:21:01.912Z","comments":true,"path":"2018/05/07/mybatis快速入门-part3/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/05/07/mybatis快速入门-part3/","excerpt":"","text":"关联查询一对多查找所有的类别的商品。category类有：id，name，List&lt;Product&gt;,Product类有name，id。sql语句：1select c.id 'cid', p.id 'pid', c.name 'cname', p.name 'pname', p.price price from category_ c left join product_ p on c.id = p.cid 注意关联查询on一定要写，不能不写条件，syntax层面就有问题。这里查询的返回结果使用resultMap来接收，因为对于这种关联查询的情况mybatis不能很好地对应到pojo中，需要你自己来写一下。Category.xml123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.how2java.pojo\"&gt; &lt;resultMap type=\"Category\" id=\"categoryBean\"&gt; &lt;id property=\"id\" column=\"cid\" /&gt; &lt;result property=\"name\" column=\"cname\" /&gt; &lt;collection property=\"products\" ofType=\"Product\"&gt; &lt;id property=\"id\" column=\"pid\"/&gt; &lt;result property=\"name\" column=\"pname\"/&gt; &lt;result property=\"price\" column=\"price\"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=\"listCategory\" resultMap=\"categoryBean\"&gt; select c.id 'cid', p.id 'pid', c.name 'cname', p.name 'pname', p.price price from category_ c left join product_ p on c.id = p.cid &lt;/select&gt; &lt;/mapper&gt; 多对一Category对Product就是一对多，Product对Category自然就是多对一。基本上和上面的相差不大，注意的就是写xml的时候是用的&lt;association property=&quot;category&quot; javaType=&quot;Category&quot;&gt;而不是collection，ofType也改为了javaType。 动态sql比较简单，这里就给出一些代码段即可： 使用if标签改造UserMapper.xml，如下：123456789101112131415161718192021222324252627282930313233343536&lt;!-- 根据条件查询用户 --&gt;&lt;select id=\"queryUserByWhere\" parameterType=\"user\" resultType=\"user\"&gt; SELECT id, username, birthday, sex, address FROM `user` WHERE 1=1 &lt;if test=\"sex != null and sex != ''\"&gt; AND sex = #&#123;sex&#125; &lt;/if&gt; &lt;if test=\"username != null and username != ''\"&gt; AND username LIKE '%$&#123;username&#125;%' &lt;/if&gt;&lt;/select&gt;``` 注意字符串类型的数据需要要做不等于空字符串校验。 #### Where标签上面的sql还有where 1=1 这样的语句，很麻烦可以使用where标签进行改造改造UserMapper.xml，如下 ``` xml&lt;!-- 根据条件查询用户 --&gt;&lt;select id=\"queryUserByWhere\" parameterType=\"user\" resultType=\"user\"&gt; SELECT id, username, birthday, sex, address FROM `user`&lt;!-- where标签可以自动添加where，同时处理sql语句中第一个and关键字 --&gt; &lt;where&gt; &lt;if test=\"sex != null\"&gt; AND sex = #&#123;sex&#125; &lt;/if&gt; &lt;if test=\"username != null and username != ''\"&gt; AND username LIKE '%$&#123;username&#125;%' &lt;/if&gt; &lt;/where&gt;&lt;/select&gt;","categories":[{"name":"java","slug":"java","permalink":"http://gunslingeratlarge.github.io/categories/java/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://gunslingeratlarge.github.io/tags/mybatis/"},{"name":"java","slug":"java","permalink":"http://gunslingeratlarge.github.io/tags/java/"}]},{"title":"mybatis快速入门 part2","slug":"mybatis快速入门-part2","date":"2018-05-07T03:01:00.000Z","updated":"2018-06-25T10:21:01.911Z","comments":true,"path":"2018/05/07/mybatis快速入门-part2/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/05/07/mybatis快速入门-part2/","excerpt":"DAO开发刚才part1只是实现了对数据库的处理，还没有涉及到DAO层。我们如何引入DAO开发呢。首先，我们之前的每个方法都是现开一个SqlSessionFactoryBuilder,SqlSessionFactory,SqlSession,这里我们就把Factory提出来放到类的变量中去，类的方法新开一个SqlSession即可。（注意SqlSession不能共享受用，是线程不安全的。）123456SqlSession session = sqlSessionFactory.openSession();try &#123; // do work&#125; finally &#123; session.close();&#125;","text":"DAO开发刚才part1只是实现了对数据库的处理，还没有涉及到DAO层。我们如何引入DAO开发呢。首先，我们之前的每个方法都是现开一个SqlSessionFactoryBuilder,SqlSessionFactory,SqlSession,这里我们就把Factory提出来放到类的变量中去，类的方法新开一个SqlSession即可。（注意SqlSession不能共享受用，是线程不安全的。）123456SqlSession session = sqlSessionFactory.openSession();try &#123; // do work&#125; finally &#123; session.close();&#125; 这里对dao开发不再赘述了，实际使用的也不多。只是这里给一些代码供不时之需。Dao接口 123456789101112131415161718192021222324public interface UserDao &#123; /** * 根据id查询用户 * * @param id * @return */ User queryUserById(int id); /** * 根据用户名模糊查询用户 * * @param username * @return */ List&lt;User&gt; queryUserByUsername(String username); /** * 保存用户 * * @param user */ void saveUser(User user);&#125; DAO实现123456789101112131415161718192021222324252627282930313233343536373839404142434445public class UserDaoImpl implements UserDao &#123; private SqlSessionFactory sqlSessionFactory; public UserDaoImpl(SqlSessionFactory sqlSessionFactory) &#123; super(); this.sqlSessionFactory = sqlSessionFactory; &#125; @Override public User queryUserById(int id) &#123; // 创建SqlSession SqlSession sqlSession = this.sqlSessionFactory.openSession(); // 执行查询逻辑 User user = sqlSession.selectOne(\"queryUserById\", id); // 释放资源 sqlSession.close(); return user; &#125; @Override public List&lt;User&gt; queryUserByUsername(String username) &#123; // 创建SqlSession SqlSession sqlSession = this.sqlSessionFactory.openSession(); // 执行查询逻辑 List&lt;User&gt; list = sqlSession.selectList(\"queryUserByUsername\", username); // 释放资源 sqlSession.close(); return list; &#125; @Override public void saveUser(User user) &#123; // 创建SqlSession SqlSession sqlSession = this.sqlSessionFactory.openSession(); // 执行保存逻辑 sqlSession.insert(\"saveUser\", user); // 提交事务 sqlSession.commit(); // 释放资源 sqlSession.close(); &#125;&#125; DAO测试测试一下DAO接口123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class UserDaoTest &#123; private SqlSessionFactory sqlSessionFactory; @Before public void init() throws Exception &#123; // 创建SqlSessionFactoryBuilder SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); // 加载SqlMapConfig.xml配置文件 InputStream inputStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); // 创建SqlsessionFactory this.sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream); &#125; @Test public void testQueryUserById() &#123; // 创建DAO UserDao userDao = new UserDaoImpl(this.sqlSessionFactory); // 执行查询 User user = userDao.queryUserById(1); System.out.println(user); &#125; @Test public void testQueryUserByUsername() &#123; // 创建DAO UserDao userDao = new UserDaoImpl(this.sqlSessionFactory); // 执行查询 List&lt;User&gt; list = userDao.queryUserByUsername(\"张\"); for (User user : list) &#123; System.out.println(user); &#125; &#125; @Test public void testSaveUser() &#123; // 创建DAO UserDao userDao = new UserDaoImpl(this.sqlSessionFactory); // 创建保存对象 User user = new User(); user.setUsername(\"刘备\"); user.setBirthday(new Date()); user.setSex(\"1\"); user.setAddress(\"蜀国\"); // 执行保存 userDao.saveUser(user); System.out.println(user); &#125;&#125; Mapper动态代理动态代理是什么?（先不管了） 在src文件夹下创建mapper包，里面的结构是这样的，一个xml文件对应一个类文件，比如UserMapper.java和UserMapper.xml，是一一对应的，UserMapper是一个接口，里面定义了关于所有的对User的数据库操作的方法，比如FindUserById，FindUserByUsername等等。除此之外还需要遵守以下规范：1、Mapper.xml文件中的namespace与mapper接口的类路径相同。2、Mapper接口方法名和Mapper.xml中定义的每个statement的id相同3、Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql的parameterType的类型相同4、Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同 时间关系，这里仅仅给出代码段UserMapper.xml123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapperPUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;!-- namespace：命名空间，用于隔离sql --&gt;&lt;!-- 还有一个很重要的作用，使用动态代理开发DAO，1. namespace必须和Mapper接口类路径一致 --&gt;&lt;mapper namespace=\"cn.itcast.mybatis.mapper.UserMapper\"&gt; &lt;!-- 根据用户id查询用户 --&gt; &lt;!-- 2. id必须和Mapper接口方法名一致 --&gt; &lt;!-- 3. parameterType必须和接口方法参数类型一致 --&gt; &lt;!-- 4. resultType必须和接口方法返回值类型一致 --&gt; &lt;select id=\"queryUserById\" parameterType=\"int\" resultType=\"cn.itcast.mybatis.pojo.User\"&gt; select * from user where id = #&#123;id&#125; &lt;/select&gt; &lt;!-- 根据用户名查询用户 --&gt; &lt;select id=\"queryUserByUsername\" parameterType=\"string\" resultType=\"cn.itcast.mybatis.pojo.User\"&gt; select * from user where username like '%$&#123;value&#125;%' &lt;/select&gt; &lt;!-- 保存用户 --&gt; &lt;insert id=\"saveUser\" parameterType=\"cn.itcast.mybatis.pojo.User\"&gt; &lt;selectKey keyProperty=\"id\" keyColumn=\"id\" order=\"AFTER\" resultType=\"int\"&gt; select last_insert_id() &lt;/selectKey&gt; insert into user(username,birthday,sex,address) values (#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;); &lt;/insert&gt;&lt;/mapper&gt; UserMapper(接口文件）123456789101112131415161718192021222324252627282930313233public interface UserMapper &#123; /** * 根据id查询 * * @param id * @return */ User queryUserById(int id); /** * 根据用户名查询用户 * * @param username * @return */ List&lt;User&gt; queryUserByUsername(String username); /** * 保存用户 * * @param user */ void saveUser(User user);&#125;``` 在SqlMapConfig.xml主配置文件里面，加载UserMapper.xml文件：``` xml &lt;!-- 加载映射文件 --&gt; &lt;mappers&gt; &lt;mapper resource=\"sqlmap/User.xml\" /&gt; &lt;!--这句是新加的，上面那句其实就没用了--&gt; &lt;mapper resource=\"mapper/UserMapper.xml\" /&gt; &lt;/mappers&gt; 测试：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class UserMapperTest &#123; private SqlSessionFactory sqlSessionFactory; @Before public void init() throws Exception &#123; // 创建SqlSessionFactoryBuilder SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); // 加载SqlMapConfig.xml配置文件 InputStream inputStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); // 创建SqlsessionFactory this.sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream); &#125; @Test public void testQueryUserById() &#123; // 获取sqlSession，和spring整合后由spring管理 SqlSession sqlSession = this.sqlSessionFactory.openSession(); // 从sqlSession中获取Mapper接口的代理对象 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); // 执行查询方法 User user = userMapper.queryUserById(1); System.out.println(user); // 和spring整合后由spring管理 sqlSession.close(); &#125; @Test public void testQueryUserByUsername() &#123; // 获取sqlSession，和spring整合后由spring管理 SqlSession sqlSession = this.sqlSessionFactory.openSession(); // 从sqlSession中获取Mapper接口的代理对象 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); // 执行查询方法 List&lt;User&gt; list = userMapper.queryUserByUsername(\"张\"); for (User user : list) &#123; System.out.println(user); &#125; // 和spring整合后由spring管理 sqlSession.close(); &#125; @Test public void testSaveUser() &#123; // 获取sqlSession，和spring整合后由spring管理 SqlSession sqlSession = this.sqlSessionFactory.openSession(); // 从sqlSession中获取Mapper接口的代理对象 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); // 创建保存对象 User user = new User(); user.setUsername(\"刘备\"); user.setBirthday(new Date()); user.setSex(\"1\"); user.setAddress(\"蜀国\"); // 执行查询方法 userMapper.saveUser(user); System.out.println(user); // 和spring整合后由spring管理 sqlSession.commit(); sqlSession.close(); &#125;&#125; mapper配置的几种方式&lt;mapper resource=&quot; &quot; /&gt;使用相对于类路径的资源（现在的使用方式）如：&lt;mapper resource=&quot;sqlmap/User.xml&quot; /&gt; 使用mapper接口类路径如：&lt;mapper class=&quot;cn.itcast.mybatis.mapper.UserMapper&quot;/&gt; 注意：此种方法要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中。 &lt;package name=&quot;&quot;/&gt;注册指定包下的所有mapper接口如：&lt;package name=&quot;cn.itcast.mybatis.mapper&quot;/&gt;注意：此种方法要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中。","categories":[{"name":"java","slug":"java","permalink":"http://gunslingeratlarge.github.io/categories/java/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://gunslingeratlarge.github.io/tags/mybatis/"},{"name":"java","slug":"java","permalink":"http://gunslingeratlarge.github.io/tags/java/"}]},{"title":"JavaScript 模块与继承","slug":"JavaScript对象","date":"2018-05-04T12:24:00.000Z","updated":"2018-06-25T10:21:01.892Z","comments":true,"path":"2018/05/04/JavaScript对象/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/05/04/JavaScript对象/","excerpt":"","text":"exports.a = a或者exports.add = add，既可以用来暴露自己的变量也可以用来暴露自己的方法。但是如果说方法是一个构造函数，那么按照这样的方法暴露出来并被引用的话会将该构造方法视为一个普通的方法，并返回undefined。实际上require方只能看到module.exports，而exports是对module.exports的引用，也就是说，exports.a = a 相当于module.exports.a = a，而且也可以用exports.Student = exports.Student来导出构造方法，用var xiaoming = new Stu.Student(“xiaoming”);来构造小明，只不过要带上模块名Stu，如果想要不带模块名，直接引出一个类的话，就用module.exports，这样子就能直接看到这个构造方法了。 继承要搞懂继承就必须要先弄明白prototype和__proto__，知乎上有一个非常浅显易懂的解释，https://www.zhihu.com/question/34183746/answer/58068402","categories":[{"name":"前端","slug":"前端","permalink":"http://gunslingeratlarge.github.io/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://gunslingeratlarge.github.io/tags/前端/"},{"name":"Js","slug":"Js","permalink":"http://gunslingeratlarge.github.io/tags/Js/"}]},{"title":"vue2.0 + Nodejs + MongoDB part2","slug":"vue2-0-Nodejs-MongoDB-part2","date":"2018-05-03T12:15:00.000Z","updated":"2018-06-25T10:21:01.916Z","comments":true,"path":"2018/05/03/vue2-0-Nodejs-MongoDB-part2/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/05/03/vue2-0-Nodejs-MongoDB-part2/","excerpt":"","text":"分模块开发每一个.vue文件就是一个模块，每一个模块分三部分，template、script、style，分别表示html的内容，逻辑和样式。而template标签下只能有一个大的根标签。 组件的数据不再只是一个对象了，而应该是一个方法，返回值为一个对象，（为什么呢？）应该写为 1234567export default &#123; data: function() &#123; return &#123; inputValue: '' &#125; &#125;&#125; 在ES6中可以简化为： 12data () &#123; &#125; vue-router用来开发spa。 路由的内容主要有两块，一块是router文件夹下index.js中的内容，一块是每个组件里面的内容。在index.js中：12345678910111213141516171819202122232425262728export default new Router(&#123; routes: [ &#123; path: '/goods/', name: 'GoodsList', component: GoodsList, children: [ &#123; path:'title', name: 'GoodTitle', component:GoodTitle &#125;, &#123; path:'image', name: 'GoodImage', component:GoodImage &#125; ] &#125;, &#123; path:'/cart', name:'cart', component:Cart &#125; ], mode: 'history'&#125;) 主要就是这个routes数组，这个数组是由几个对象组成的，每个对象都有自己的路径，还可以嵌套路径，一个路径对应一个组件。而这个组件放到哪里呢？放到其父组件的&lt;router-view&gt;&lt;/router-view&gt;位置。比如这里的GoodTitle就放到GoodsList的.vue文件中的&lt;router-view&gt;&lt;router-view&gt;位置。在每个组件里，跳转到某个地址的a连接不再是a了，改为用&lt;router-link&gt;&lt;/router-link&gt;，而路径也可以通过goods/:goodsId的形式传递给组件，在组件的模板中使用来获取。也可以直接通过编程式的路由在写跳转，如下：123456789101112131415 &lt;template&gt; &lt;button @click=\"goToCart\"&gt;通过编程式路由跳转到购物车&lt;/button&gt; &lt;/template&gt; &lt;script&gt; export default &#123; data() &#123; return &#123;&#125; &#125;, methods: &#123; goToCart() &#123; this.$router.push(&#123;path:'/cart?goodsId=123'&#125;); &#125; &#125; &#125;&lt;/script&gt; 命名路由1&lt;router-link v-bind:to\"&#123;name:'cart',params:&#123;cartId:123&#125;&#125;\"&gt;跳转到购物车页面&lt;/router-link&gt; 这个就对应着跳转到/cart/:cartId这个页面，并且把cartId=123作为params传递过去。","categories":[{"name":"前端","slug":"前端","permalink":"http://gunslingeratlarge.github.io/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://gunslingeratlarge.github.io/tags/vue/"}]},{"title":"javascript闭包","slug":"javascript闭包","date":"2018-05-03T02:35:00.000Z","updated":"2018-06-25T10:21:01.901Z","comments":true,"path":"2018/05/03/javascript闭包/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/05/03/javascript闭包/","excerpt":"理解我对闭包的理解是：一个函数返回另一个函数，另一个函数可以使用这个函数的局部变量。另一个函数可以之后再调用。为什么要使用闭包？ 因为在js中没有类，那怎么样制造私有变量和getter、setter的概念呢？","text":"理解我对闭包的理解是：一个函数返回另一个函数，另一个函数可以使用这个函数的局部变量。另一个函数可以之后再调用。为什么要使用闭包？ 因为在js中没有类，那怎么样制造私有变量和getter、setter的概念呢？可以这样写：1234567891011'use strict';function create_counter(initial) &#123; var x = initial || 0; return &#123; inc: function () &#123; x += 1; return x; &#125; &#125;&#125; 这样使用：123456789var c1 = create_counter();c1.inc(); // 1c1.inc(); // 2c1.inc(); // 3var c2 = create_counter(10);c2.inc(); // 11c2.inc(); // 12c2.inc(); // 13 还可以封装一些方法（给方法预置参数）比如:123456789101112var power_factory = function(n) &#123; return function(x) &#123; return Math.pow(x,n); &#125;&#125;var pow2 = power_factory(2);var pow3 = power_factory(3);console.log(pow2(6));console.log(pow3(5)); 参考:廖雪峰的博客","categories":[{"name":"前端","slug":"前端","permalink":"http://gunslingeratlarge.github.io/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://gunslingeratlarge.github.io/tags/前端/"},{"name":"js","slug":"js","permalink":"http://gunslingeratlarge.github.io/tags/js/"}]},{"title":"Node.js part4 数据库","slug":"Node-js-part4-数据库","date":"2018-05-02T05:01:00.000Z","updated":"2018-06-25T10:21:01.895Z","comments":true,"path":"2018/05/02/Node-js-part4-数据库/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/05/02/Node-js-part4-数据库/","excerpt":"","text":"Nodejs常使用mongodb，mongodb为nosql，里面存的也是json，所以就是js从前端到后端再到数据库一条龙全栈了。NoSQL是什么？Not Only SQL，有些nosql数据库也可以用sql语句。nosql数据库是非关系型的数据库，在大数据和实时的web应用中使用。具有弹性。 NoSQL的优势 能够处理大数据 具有弹性，没有事先定义的schema，没有事先定义的结构，不用定义行、列之类的 nosql能够处理非结构化的数据 Scaling-量级变化，随着数据量的增长的表现，scale-out scale-out:只用向原有的系统添加一个新机器scale-up:为了scale，需要添加组件，添加存储空间，内存，cpu，能源等等，更大更强的机器 关系型数据库的优点 更适用关系型数据 Normalization 正规化 语言支持（sql） 数据一致性（有外键等等约束） ACID的服从 NoSQL数据库的分类 文档数据库（MongoDB，CouchDB） 列数据库（Apache Cassandra） Key-Value （Redis，Couchbase Server） 大量数据，但是数据简单 Cache-Systems Graph Databases（Neo4J） 所有的数据都作为一个节点，跟其他数据相连","categories":[],"tags":[{"name":"node","slug":"node","permalink":"http://gunslingeratlarge.github.io/tags/node/"}]},{"title":"抽象代数中期复习","slug":"抽象代数中期复习","date":"2018-04-29T14:35:00.000Z","updated":"2018-06-25T10:21:01.927Z","comments":true,"path":"2018/04/29/抽象代数中期复习/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/04/29/抽象代数中期复习/","excerpt":"判定方法判断子群三个方法1、ab^(-1)∈H2、关于运算封闭并且a的逆在H中，当a属于H3、对于有限群来说，H关于运算封闭即可 判断环的方法阿贝尔群 plus 双律（分配律，结合律） 判断子环的方法 关于第一个运算满足子群 关于第二个运算满足封闭（因为结合律天然满足，只要封闭就可以） 判断理想的方法 关于第一个运算为子群 关于第二个运算任a∈I，r∈R，ar，ra∈I 相比子环就是连不在I中的元素也可以搞到I中了，所以理想必为子群。","text":"判定方法判断子群三个方法1、ab^(-1)∈H2、关于运算封闭并且a的逆在H中，当a属于H3、对于有限群来说，H关于运算封闭即可 判断环的方法阿贝尔群 plus 双律（分配律，结合律） 判断子环的方法 关于第一个运算满足子群 关于第二个运算满足封闭（因为结合律天然满足，只要封闭就可以） 判断理想的方法 关于第一个运算为子群 关于第二个运算任a∈I，r∈R，ar，ra∈I 相比子环就是连不在I中的元素也可以搞到I中了，所以理想必为子群。 判断域的方法两个运算都是阿贝尔群，尤其关注第二个元素是否有每个元素都有逆元 域的特征一、域的定义关于第一个运算为阿贝尔群，关于第二个运算也为阿贝尔群（除开零元没有逆元外） 二、域的特征ch(F)，取F的单位元1（一定非0）1 + 1 + 1 … + 1 需要加多少次才能够得到0? 取最小正整数如果不能够得到0，ch(F)则被定义为0举例： F_2 = { 0, 1 } ch(F_2) = 2域的特征永远不会为0 三、两个运算n·1表示将1相加n次(n·1) + (m·1) = (n + m)·1都是两个在域中的元素(n·1)×(m·1) = (n×m)·1 由于域关于加法满足分配率，所以可以得到m×n个1 四、域的特征定理ch(F) = 0 or 质数证明假设n = chF 不是质数 = ab ，根据特征数的定义： n·1 = 0 有(a×b)·1 = 0 根据上面的乘法就有(a·1） × (b · 1 ) = 0 。由于域没有零因子，所以只能a·1 为0或者b·1 =0，则与假设矛盾了，所以特征数只能为质数了。例如：ch(Z_p) = p ch（R） = 0 ch(C) = 0 域的扩展向量空间向量空间的特点：加法：向量相加可交换、有单位元、每个元素有逆元、满足结合律，这里形成一个阿贝尔群，群中的每个元素都是一个向量（可以看做是n个坐标构成一个向量）标量乘法:满足四个特点：两个分配律，一个结合律，单位元 我们上面定义的向量空间每一个vector都被我们看做是一个空间中的箭头，有n个坐标，但是我们想把它更抽象一点，扔掉它的物理意义，因此我们在抽象代数中这样定义向量空间：域K为域F的扩域，因此域K就是F上的向量空间。因为域K是阿贝尔群，因此域K中的元素（每一个被看做向量）关于加法满足向量空间的定义，因此现在就只需要考虑标量乘法的四个特点了。 dim(K) = [k:F] = K的扩张次数或者度数 在F上找一个不可约多项式(不为0），这个不可约多项式一定在F上没有根不然就一次项因子，p(x)∈F[x],所有的一次多项式都是不可约多项式。deg(p(x))≥ 2，因为deg为1的多项式在F上都有根。 不可约 deg(px) ≥ 2则在F上无根。则此时我们想要对F扩域，使得这个px在K上有根（即可以解得出来了）K = F[x]/(p(x)),K是F的扩域，对p(x)有根。问题: 为什么K就是F的扩域？或者说为什么F就是K的子域？ 素域charF = charK 且等于所有非零元的特征每一个域必定有有一个素子域，charF=0为Q，charF = p为Z_p","categories":[{"name":"数学","slug":"数学","permalink":"http://gunslingeratlarge.github.io/categories/数学/"},{"name":"抽象代数","slug":"数学/抽象代数","permalink":"http://gunslingeratlarge.github.io/categories/数学/抽象代数/"}],"tags":[{"name":"抽象代数","slug":"抽象代数","permalink":"http://gunslingeratlarge.github.io/tags/抽象代数/"}]},{"title":"Node.js part3 express","slug":"Node-js-part3-express","date":"2018-04-24T02:56:00.000Z","updated":"2018-06-25T10:21:01.895Z","comments":true,"path":"2018/04/24/Node-js-part3-express/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/04/24/Node-js-part3-express/","excerpt":"安装与overviewnpm install express --save安装express框架并自动改变package.json文件。 功能一： 路由1234var express = require(\"express\");var app = express();app.get(path,function(req, res)&#123;&#125;); path可以写路径，也可以写正则，还可以通过/student/:number来直接传入，用req.params/number来获得，或者通过正则表达式的小括号来获得。如123app.get(/^\\/student\\/([\\d]&#123;10&#125;)$/,function(req,res)&#123; res.send(\"学生信息，学号\" + req.params[0]);&#125;);","text":"安装与overviewnpm install express --save安装express框架并自动改变package.json文件。 功能一： 路由1234var express = require(\"express\");var app = express();app.get(path,function(req, res)&#123;&#125;); path可以写路径，也可以写正则，还可以通过/student/:number来直接传入，用req.params/number来获得，或者通过正则表达式的小括号来获得。如123app.get(/^\\/student\\/([\\d]&#123;10&#125;)$/,function(req,res)&#123; res.send(\"学生信息，学号\" + req.params[0]);&#125;); 注意，要使用正则要么就完全正则匹配，不要加双引号，整个路径就是一个正则。易犯的错误是加号搞成了逗号，弄成两个参数了。动手写代码的意义在于： 明确自己可能犯的错误 强化自己记忆不清楚的地方，确保自己需要的时候能复现除此之外的练习其实也不是必要的。 功能二：提供静态服务1app.use(express.static(\"./public\")); 可以直接用localhost:3000/访问public文件夹下的index.html，或者加上具体地路径如localhost:3000/abc.html就是访问public文件夹下的abc.html 功能三：与ejs配合使用先要设置view engine为ejs，将ejs模板文件放到views文件夹下，这样express会自动去views文件夹下找对应的ejs文件。与通常的路由不同的就是res.render部分了。123456app.set(\"view engine\",\"ejs\");app.get(\"/ejsdemo\",function (req,res) &#123; res.render(\"haha.ejs\",&#123; \"news\":[\"news1\",\"newstwo\",\"newsThree\"] &#125;);&#125;); 中间件匹配按照从上往下，如果有多个匹配，那么只匹配上面的，如果想下面的也一起匹配，需要多写一个next()方法。1234567app.get(\"/\",function(req,res,next)&#123; console.log(\"1\"); next();&#125;);app.get(\"/\",function(req,res)&#123; console.log(\"2\");&#125;); 下面这个路由会发生冲突：123456789app.get(\"/:username/:id\",function(req,res)&#123; console.log(\"1\"); res.send(\"用户信息\" + req.params.username);&#125;);app.get(\"/admin/login\",function(req,res)&#123; console.log(\"2\"); res.send(\"管理员登录\");&#125;); 因为admin可以当做用户名，login可以当做id，解决方法有两个 交换位置，匹配上第一个，就不会往下匹配了，具体的往上写，抽象的往下写。 123456789app.get(\"/admin/login\",function(req,res)&#123; console.log(\"2\"); res.send(\"管理员登录\");&#125;);app.get(\"/:username/:id\",function(req,res)&#123; console.log(\"1\"); res.send(\"用户信息\" + req.params.username);&#125;); 检索数据库，如果没有这个用户名那么就调用next() 123456789101112131415app.get(\"/:username/:id\",function(req,res,next)&#123; var username = req.params.username; //检索数据库，如果username不存在，那么next() if(检索数据库)&#123; console.log(\"1\"); res.send(\"用户信息\"); &#125;else&#123; next(); &#125;&#125;);app.get(\"/admin/login\",function(req,res)&#123; console.log(\"2\"); res.send(\"管理员登录\");&#125;); app.use()举例，app.use(“/admin”,callback),/admin可以匹配，/admin/aa可以，/admin/aa/bb也可以。而get和post都是精确的路由匹配。而use是只要/admin开头就可以. 123456app.use(\"/admin\",function(req,res)&#123; res.write(req.originalUrl + \"\\n\"); // /admin/aa/bb/cc/dd res.write(req.baseUrl + \"\\n\"); // /admin res.write(req.path + \"\\n\"); // /aa/bb/cc/dd res.end(\"你好\");&#125;); 一些需要注意的小点： 大多数情况下，渲染内容用res.render()，将会根据views中的模板文件进行渲染。如果不想使用views文件夹，想自己设置文件夹名字，那么app.set(“views”,”aaaa”); 如果想写一个快速测试页，当然可以使用res.send()。这个函数将根据内容，自动帮我们设置了Content-Type头部和200状态码。send()只能用一次，和end一样。和end不一样在哪里？能够自动设置MIME类型。 如果想使用不同的状态码，可以： res.status(404).send(‘Sorry, we cannot find that!’); 如果想使用不同的Content-Type，可以： res.set(‘Content-Type’, ‘text/html’); GET与POST请求对于get请求可以用req.query来获得请求语句。并且express会自动帮你转换为一个对象。对于post请求博旭引入bodyParser,但是如果有文件上传还是得用formidable123456//bodyParser APIapp.use(bodyParser.urlencoded(&#123; extended: false &#125;))app.post(\"/\",function(req,res)&#123; console.log(req.body);&#125;);","categories":[{"name":"区块链","slug":"区块链","permalink":"http://gunslingeratlarge.github.io/categories/区块链/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://gunslingeratlarge.github.io/tags/nodejs/"}]},{"title":"leetcode 88. Merge Sorted Array","slug":"leetcode-88-Merge-Sorted-Array","date":"2018-04-20T01:31:00.000Z","updated":"2018-06-25T10:21:01.910Z","comments":true,"path":"2018/04/20/leetcode-88-Merge-Sorted-Array/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/04/20/leetcode-88-Merge-Sorted-Array/","excerpt":"88. Merge Sorted ArrayDifficulty: Easy Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note: The number of elements initialized in nums1 and nums2 are m and n respectively. You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.","text":"88. Merge Sorted ArrayDifficulty: Easy Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note: The number of elements initialized in nums1 and nums2 are m and n respectively. You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. Example: 12345**Input:**nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3**Output:** [1,2,2,3,5,6] Solution1234567891011121314151617181920212223//从后往前class Solution &#123; public void merge(int[] nums1, int m, int[] nums2, int n) &#123; //nums1的最后一位 int i = m - 1; //nums2的最后一位 int j = n - 1; //总数组的最后一位 int k = m + n - 1; while(i &gt;= 0 &amp;&amp; j &gt;= 0) &#123; if (nums1[i] &gt; nums2[j]) &#123; nums1[k--] = nums1[i--]; &#125; else &#123; nums1[k--] = nums2[j--]; &#125; &#125; while(j &gt;= 0) &#123; nums1[k--] = nums2[j--]; &#125; &#125;&#125;","categories":[{"name":"刷题","slug":"刷题","permalink":"http://gunslingeratlarge.github.io/categories/刷题/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://gunslingeratlarge.github.io/tags/leetcode/"},{"name":"刷题","slug":"刷题","permalink":"http://gunslingeratlarge.github.io/tags/刷题/"},{"name":"easy","slug":"easy","permalink":"http://gunslingeratlarge.github.io/tags/easy/"}]},{"title":"Nodejs写相册","slug":"Nodejs写相册","date":"2018-04-19T12:52:00.000Z","updated":"2018-06-25T10:21:01.896Z","comments":true,"path":"2018/04/19/Nodejs写相册/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/04/19/Nodejs写相册/","excerpt":"相册首页 需求需求：用户输入127.0.0.1时候，首页，就显示所有的文件夹列表：这些相册，都是真实文件夹的名字。uploads里面有aaa、bbb、ccc文件夹点击每个相册之后，进入的地址：127.0.0.1/aaa就能看见这个文件夹中的所有图片管理员界面127.0.0.1/admin，不需要密码即可登录有一个表单， 上传图片， 传到哪个文件夹里面。 当然，也有“新建相册”功能(fs.mkdir()函数)。","text":"相册首页 需求需求：用户输入127.0.0.1时候，首页，就显示所有的文件夹列表：这些相册，都是真实文件夹的名字。uploads里面有aaa、bbb、ccc文件夹点击每个相册之后，进入的地址：127.0.0.1/aaa就能看见这个文件夹中的所有图片管理员界面127.0.0.1/admin，不需要密码即可登录有一个表单， 上传图片， 传到哪个文件夹里面。 当然，也有“新建相册”功能(fs.mkdir()函数)。 设计主要是路由设计，先判断是不是文件，因为所有的请求，不管是对页面的请求（html）还是对文件的请求（如图片），都是以同样的方式处理的，因此先判断pathname中有没有’.’，如果有，代表是文件，读取文件并返回，如果没有，代表是文件夹或者是页面，因此就用多个if…else…语句对pathname进行判断，然后或者返回html，或者进行相关的操作比如创建文件夹等等。每一个页面都有相对应的ejs，在这个项目中前端和后端很难分开，前端也要先写成html，然后改成ejs，再在nodejs中render，有点像写jsp，感觉不是很舒服。而且node的异步是需要一定的时间来适应的，有时候你就是需要读完这些再去进行下一个操作，幸好有了readFileSync函数，但是总感觉写起来不得劲。总感觉牵牵扯扯，模块之间分得不清楚，前后端分得不清楚，命名也是乱命，css写得也乱，id满天飞。总而言之还是对web开发、node不熟悉。 实现具体的代码已经传到了我的github上，这里记录几个小点： js可以通过window.location.href = url来发送get请求，我就是用这个来处理创建dir的需求的。 对返回的数据最好还是设置好它的mime类型，操作思路是这样的： 有一个mime.json，它里面是所有的后缀名对应的mime类型，我们可以写一个函数，叫getMime(extname,callback)，在这个函数里面使用JSON.parse把mime.json读取成key-value形式并根据extname查到对应的mime值，然后callback(mime)，即把这个mime值传给回调函数。 在调用这个getMime的时候我们就可以getMime(“.jpg”,function(mime){操作…})异步地使用到这个mime值了。","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://gunslingeratlarge.github.io/tags/nodejs/"}]},{"title":"CSS小结","slug":"CSS小结","date":"2018-04-19T12:29:00.000Z","updated":"2018-06-25T10:21:01.890Z","comments":true,"path":"2018/04/19/CSS小结/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/04/19/CSS小结/","excerpt":"京东首页 CSS 元素的分类 块元素（独占一行：包括div、p、ul、li、h1-h6） 可以设置宽高 嵌套下，子元素宽度和父块元素宽度默认一致 独占一行 行内元素 span、a、strong、em、del、ins 在一行上显示 不能直接设置宽高 元素的宽高就是内容撑开的宽高 因此text-align:center（对元素的内容居中）无效了 仍在父级元素内自适应","text":"京东首页 CSS 元素的分类 块元素（独占一行：包括div、p、ul、li、h1-h6） 可以设置宽高 嵌套下，子元素宽度和父块元素宽度默认一致 独占一行 行内元素 span、a、strong、em、del、ins 在一行上显示 不能直接设置宽高 元素的宽高就是内容撑开的宽高 因此text-align:center（对元素的内容居中）无效了 仍在父级元素内自适应 行内块元素 外在inline，内在为块，image，input 在一行上显示 可以设置宽高 元素之间的转换 块元素转行内元素：display:inline; 行内块元素转块元素：display:block; 块和行内元素转行内块元素：display:inline-block; 使用场景：想将块元素和行内元素都放在一行，还想定义宽高，将他们都转成行内块元素（最常用） 样式表的优先级 继承和默认为0 标签选择器优先级为1 类选择器为10 id选择器为100 行内样式为1000 !important 为1000以上 注意权重会叠加，如div p .span就为1+1+10 = 12 链接伪类 a:visited访问之后的状态 a:hover滑过的状态 a:active激活的状态 :focus获取到焦点的状态如input:focus 去除下划线：text-decoration:none; (underline, line-through) 背景属性 background-color background-image:url(“1.png”) background-repeat:no-repeat,repeat-x, repeat-y,repeat background-position:left right center top bottom 当你只写一个值的时候，另一个值就居中（不居中，难道默认值为left或top？所以只能默认居中为最好的情况），如写right，则是到最右边的中间位置，即right center。 写两个具体值是水平方向，垂直方向，只写一个代表水平方向 background-attachment： scroll fixed 背景是否滚动 如果此值为fixed的话，那么它的position是基于浏览器窗口的，不再以元素来定位了 行高 浏览器默认文字大小16px 行高 = 基线与基线之间的距离 行高 = 文字高度 + 上下边距(注意这个上下边距跟外边距没关系)，这里讲的行高就是文字content的高度 一行文字行高和父元素高度一致的时候，垂直居中显示（a标签中文字是a这个标签的子元素，所以可以用text-align作用在子元素上） 行高的单位 有父元素时行高 推荐行高使用像素为单位 line-height与height的区别 一行文字总是在line-height的中间的，而height只是设置某个元素的高度，文字还是左上放的 设置line-height为50 设置height为50 盒子模型 边框合并 border-collapse:collapse; 将table的边框合并，结合 使用 继承的盒子一般不会被撑大 包含（嵌套）的盒子，如果子盒子没有定义宽度，给子盒子设置左右内边距，一般不会撑大盒子。 css世界中流的概念，只会填充满父级容器而不会溢出 在高度方向上就可以撑大（就算外面的盒子已经设置了高度也会被撑大） 盒子与盒子之间的居中对齐用margin:0 auto; 标签中内容的居中对齐用text-align:center; 规范中的text-align:center是用来居中行内元素或者是自身的内容的，但是ie7/8也可以用来对齐块级元素 text-align:center; 这个属性也具有继承性 外边距margin 两个盒子垂直一个设置上外边距，一个设置下外边距，取的设置较大的值 嵌套的盒子外边距塌陷 嵌套的盒子，直接给子盒子设置垂直外边距的时候，会发生外边距塌陷 解决方法 1、给父盒子设置边框 2、给父元素设置overflow:hidden; 行内元素不要给上下的margin 和padding 上下margin和padding会被忽略 左右margin和padding会起作用 浮动 浮动原理 清除body的margin可以消除空白边缘： body {margin:0;} 浮动的盒子脱离标准流，并且在一行上显示 行内元素浮动后变为行内块元素（不推荐使用） 浮动的盒子一般要给宽，要不然容易掉下来 浮动作用 文本绕图 对图片左浮动，然后p会环绕图片 图片的浮动是不会盖住文字的（本来就是为了用浮动解决文本绕图的问题） 制作导航 使用ul、li完成导航而非将a转成行内块 margin：没有背景色 padding：有背景色 网页布局 一个左浮动一个右浮动 清除浮动 当父盒子没有定义高度，子盒子浮动之后，下面的元素发生位置错误 方法 额外标签法：在最后一个浮动元素后添加标签&lt;div style=”clear:both;&gt;&lt;/div&gt; 给浮动的父级元素使用 overflow: hidden; 将溢出隐藏，所以就给了高度以容纳子元素？ 如果有内容在盒子之外，不能使用了。因为会把盒子之外的内容裁掉 伪元素清除浮动 给父级元素以.clearfix类 .clearfix:after { display:block; height:0; line-height:0; visibility:hidden；clear:both;} .clearfix {zoom:1} 兼容ie浏览器 css初始化 直接复制粘贴别人的即可 Overflow visible：默认值，内容不会修剪，会呈现在元素之外 hidden：内容会被修剪 scroll：内容出了盒子会隐藏，但是会显示滚动条 auto: 能滚才有滚动条，scorll一定有两个滚动条 定位 left,right,top,bottom:100px; 表示位置信息 静态定位 position: static; 默认值 绝对定位: position:absolute; 不占据原来的位置（脱标） left等等属性有用了，是关于浏览器（这个浏览器页面而非浏览器窗口，滚动是会消失的）的位置 嵌套的盒子，父盒子没有使用定位，子盒子绝对定位，子盒子位置从浏览器出发 嵌套的盒子，父盒子使用定位，子盒子绝对定位，子盒子从父元素出发 使用绝对定位之后，行内元素转成了行内块元素（z-index 调整元素的层叠顺序，默认值0-999，越大越在上面 ） 行内元素脱标之后都会转成行内块（个人认为） div不会再流动地填满整个父级元素了 相对定位：position:relative; 位置从自己原来的位置出发，相对指的是相对于自己 还占据原来的位置 子绝父相（父元素相对定位，子元素绝对定位）——工作中用得最多 父相对定位不脱标，子元素按照父元素位置出发 固定定位：fixed 一直在浏览器窗口，无视滚动 不占据原有位置，脱标 行内元素转换为行内块元素 其他一些问题 定位的盒子居中显示 margin: 0 auto;只能让不脱标的盒子居中 left:50%; margin-left:-480px; 即向右走父元素宽度的50%,向左走自身宽度的一半（这里自身宽度为960px） 不同的分辨率也可适配 标签包含规范 div可以包含所有的标签。 p标签不能包含div h1等标签 h1可以包含p，div等标签 行内元素尽量包含行内元素，行内元素不要包含块元素 规避脱标流 能用流的尽量用流，不行再用浮动，再不行使用定位 margin-left:auto; 小技巧可以把盒子左边距设到最大，往右边冲 图片和文字的垂直居中对齐 vertical-align：主要是使用在行内块上。默认属性是：baseline 只需要把图片的vertical-align改为middle，bottom，top就可以解决了 css可见性 overflow:hidden；溢出隐藏 可以用纯css做标签页的切换，就是使用这个结合锚点。 通过点击a标签业内跳转到不同的id，然后由于父级盒子只能显示一个且设置了overflow:hidden;因此只显示一个div visibility:hidden；隐藏元素，隐藏之后还占据原来位置 display:none；隐藏元素，隐藏后不占据原来的位置 display:block；显示元素 后两者常配合js使用，如下拉菜单 内容移出 可以将a的内容移出不显示，但是仍然在html中，对seo就比较友好了 方法 对a display: inline-block; text-indent:-5000em; div {height:0px; width:300px; background:red; padding-top:100px; overflow:hidden;}则div中的内容不会显示出来，因为高度为0且溢出隐藏，但是盒子又能显示，因为有一个上padding 精灵图 将小图标放到一张图上，避免多次加载 通过使用bg的不同位置来确定图片","categories":[{"name":"前端","slug":"前端","permalink":"http://gunslingeratlarge.github.io/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://gunslingeratlarge.github.io/tags/前端/"},{"name":"css","slug":"css","permalink":"http://gunslingeratlarge.github.io/tags/css/"}]},{"title":"Node.js part2","slug":"Node-js-part2","date":"2018-04-18T08:28:00.000Z","updated":"2018-06-25T10:21:01.894Z","comments":true,"path":"2018/04/18/Node-js-part2/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/04/18/Node-js-part2/","excerpt":"引用模块 某一个js文件中，提供了函数，供别人使用。 只需要暴露函数就行了； exports.msg=msg; 某一个js文件，描述了一个类。 module.exports = 构造函数名;一个JavaScript文件，可以向外exports无数个变量、函数。但是require的时候，仅仅需要require这个JS文件一次。使用的它的变量、函数的时候，用点语法即可。所以，无形之中，增加了一个顶层命名空间。12345678910111213141516 var msg = \"你好\"; var info = \"呵呵\"; function showInfo()&#123; console.log(info); &#125; exports.msg = msg; exports.info = info; exports.showInfo = showInfo;//在使用者中，只需要require一次。 var foo = require(\"./test/foo.js\");//相当于增加了顶层变量。所有的函数、变量都要从这个顶层变量走： console.log(foo.msg); console.log(foo.info); foo.showInfo();","text":"引用模块 某一个js文件中，提供了函数，供别人使用。 只需要暴露函数就行了； exports.msg=msg; 某一个js文件，描述了一个类。 module.exports = 构造函数名;一个JavaScript文件，可以向外exports无数个变量、函数。但是require的时候，仅仅需要require这个JS文件一次。使用的它的变量、函数的时候，用点语法即可。所以，无形之中，增加了一个顶层命名空间。12345678910111213141516 var msg = \"你好\"; var info = \"呵呵\"; function showInfo()&#123; console.log(info); &#125; exports.msg = msg; exports.info = info; exports.showInfo = showInfo;//在使用者中，只需要require一次。 var foo = require(\"./test/foo.js\");//相当于增加了顶层变量。所有的函数、变量都要从这个顶层变量走： console.log(foo.msg); console.log(foo.info); foo.showInfo(); 如果require的时候没有路径也没有.js，就去找node_modules里面的文件夹，默认找index.js，如果名字不是这个要在package.json中配置。如果没有路径有js就去node_modules里面找对应的js。使用npm init命令可以自动生成package.json。 post请求原生post123456789101112var alldata = \"\";//下面是post请求接收的一个公式//node为了追求极致，它是一个小段一个小段接收的。//接受了一小段，可能就给别人去服务了。防止一个过大的表单阻塞了整个进程 req.addListener(\"data\",function(chunk)&#123; alldata += chunk;&#125;);//全部传输完毕 req.addListener(\"end\",function()&#123; console.log(alldata.toString()); res.end(\"success\");&#125;); 如果要文件上传，那还是用第三方formidable比较好，能够更好地处理post请求封装到fields和files中。form标签要加个属性：1&lt;form action=&quot;http://127.0.0.1/dopost&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 并且form中type=file的那个input还要加上name属性。这里给出源码：12345678910111213141516171819202122232425262728293031323334353637383940if(req.url == &quot;/dopost&quot; &amp;&amp; req.method.toLowerCase() == &quot;post&quot;)&#123; //Creates a new incoming form. var form = new formidable.IncomingForm(); //设置文件上传存放地址 form.uploadDir = &quot;./uploads&quot;; //执行里面的回调函数的时候，表单已经全部接收完毕了。 form.parse(req, function(err, fields, files) &#123; //if(err)&#123; // throw err; //&#125; //console.log(util.inspect(&#123;fields: fields, files: files&#125;)); //时间，使用了第三方模块，silly-datetime var ttt = sd.format(new Date(), &apos;YYYYMMDDHHmmss&apos;); var ran = parseInt(Math.random() * 89999 + 10000); var extname = path.extname(files.tupian.name); //执行改名 var oldpath = __dirname + &quot;/&quot; + files.tupian.path; //新的路径由三个部分组成：时间戳、随机数、拓展名 var newpath = __dirname + &quot;/uploads/&quot; + ttt + ran + extname; //改名 fs.rename(oldpath,newpath,function(err)&#123; if(err)&#123; throw Error(&quot;改名失败&quot;); &#125; res.writeHead(200, &#123;&apos;content-type&apos;: &apos;text/plain&apos;&#125;); res.end(&quot;成功&quot;); &#125;); &#125;); &#125;else if(req.url == &quot;/&quot;)&#123; //呈递form.html页面 fs.readFile(&quot;./form.html&quot;,function(err,data)&#123; res.writeHead(200, &#123;&apos;content-type&apos;: &apos;text/html&apos;&#125;); res.end(data); &#125;) &#125;else&#123; res.writeHead(404, &#123;&apos;content-type&apos;: &apos;text/html&apos;&#125;); res.end(&quot;404&quot;); &#125; 模板引擎数据绑定类似&lt;a href=&quot;&lt;%= url %&gt;&quot;&gt;&lt;img src=&quot;&lt;%= imageURL %&gt;&quot; alt=&quot;&quot;&gt;&lt;/a&gt;。后台模板引擎主要两个，ejs，jade。这里给一个简单的示例123456789101112var ejs = require(\"ejs\");//模板var string = \"好高兴啊，今天我买了iphone&lt;%= a %&gt;s\";//数据var data = &#123; a : 6&#125;;//数据绑定var html = ejs.render(string, data);//输出console.log(html); 输出：好高兴啊，今天我买了iphone6s。 当然也可以把string另外写到一个.ejs文件中去，data是一个对象，里面是键值对，然后用render传入data，string就从ejs里面读，最后输出html到response中即可。在服务器上组成页面，这样显示、数据没分清楚，不是发展的趋势。","categories":[{"name":"区块链","slug":"区块链","permalink":"http://gunslingeratlarge.github.io/categories/区块链/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://gunslingeratlarge.github.io/tags/nodejs/"}]},{"title":"Node.js part1","slug":"Node-js-part1","date":"2018-04-17T11:01:00.000Z","updated":"2018-06-25T10:21:01.894Z","comments":true,"path":"2018/04/17/Node-js-part1/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/04/17/Node-js-part1/","excerpt":"特点单线程、非阻塞I/O、事件驱动。这三点其实就是一点：因为其为单线程，如果是阻塞的话就没有办法处理多个请求，所以需要非阻塞I/O，而在处理某一个请求时如果之前的一个I/O操作做完了，怎么通知它？就要用到事件，所以需要事件驱动。 适合I/O密集型的应用，无非代替php,java等传统后端语言，只是一个小工具。可以处理数万个并发请求。通常在大型网站中用来处理部分模块。","text":"特点单线程、非阻塞I/O、事件驱动。这三点其实就是一点：因为其为单线程，如果是阻塞的话就没有办法处理多个请求，所以需要非阻塞I/O，而在处理某一个请求时如果之前的一个I/O操作做完了，怎么通知它？就要用到事件，所以需要事件驱动。 适合I/O密集型的应用，无非代替php,java等传统后端语言，只是一个小工具。可以处理数万个并发请求。通常在大型网站中用来处理部分模块。 Hello World1234567var http = require(\"http\");http.createServer( function(req,res) &#123; res.writeHead(200,&#123;\"Content-type\":\"text/html;charset=UTF-8\"&#125;); res.end(\"Hello World\"); &#125;).listen(3000,\"127.0.0.1\"); http是node的一个模块，用require来引入，res.writeHead用来写响应头，res.write用来写响应，res.end用来写入并且结束响应。(不写res.end客户端会一直等待，就网页显示一直在加载中）。 路由nodejs是没有web容器的，也就是它自己内置了一个轻服务器（粗暴理解），而且它的path也不是真正的文件夹，而是用if…else…语句写的路由。比如下面这段代码：1234567891011121314151617181920212223242526var http = require(\"http\");http.createServer(function(req,res) &#123; var questurl = req.url; res.writeHead(200,&#123;\"Content-type\":\"text/html;charset=UTF-8\"&#125;); if (questurl.substr(0,9) == \"/student/\") &#123; var studentid = questurl.substr(9); if (/^\\d&#123;10&#125;$/.test(studentid)) &#123; res.write(\"查询学生：\" + studentid); &#125; else &#123; res.write(\"学生id格式不正确\"); &#125; &#125; else if (questurl.substr(0,9)==\"/teacher/\")&#123; var teacherid = questurl.substr(9); if (/^\\d&#123;6&#125;$/.test(teacherid)) &#123; res.write(\"check teacher:\" + teacherid); &#125; else &#123; res.write(\"teacher id wrong\"); &#125; &#125; else &#123; res.write(\"身份类型错误\"); &#125;; res.end;&#125;).listen(3000,\"127.0.0.1\"); urlurl模块用来处理url，有url.parse(req.url,true)，写true代表要将其转换为一个对象。一个url对象里面有很多东西，包括path，pathname（path去掉query），query，host，port，因此就可以用这个方法来处理GET请求了。12345678910111213141516var http = require(\"http\");var url = require(\"url\");var server = http.createServer(function(req,res)&#123; //url.parse()可以将一个完整的URL地址，分为很多部分： //host、port、pathname、path、query var pathname = url.parse(req.url).pathname; //url.parse()如果第二个参数是true，那么就可以将所有的查询变为对象 //就可以直接打点得到这个参数 var query = url.parse(req.url,true).query; //直接打点得到这个参数 var age = query.age; res.end();&#125;);server.listen(3000,\"127.0.0.1\"); 文件处理用fs模块。 文件读取fs.readFile(&quot;./test/1.txt&quot;,{&quot;charset&quot;:&quot;utf-8&quot;},callback)，读取文件。注意要用./表示路径，option可以不写，callback为function(err,data){}123456789101112131415161718192021222324252627var http = require(\"http\");var fs = require(\"fs\");var server = http.createServer(function(req,res)&#123; //不处理小图标 if(req.url == \"/favicon.ico\")&#123; return; &#125; //给用户加一个五位数的id var userid = parseInt(Math.random() * 89999) + 10000; console.log(\"欢迎\" + userid); res.writeHead(200,&#123;\"Content-Type\":\"text/html;charset=UTF8\"&#125;); //两个参数，第一个是完整路径，当前目录写./ //第二个参数，就是回调函数，表示文件读取成功之后，做的事情 fs.readFile(\"./test/1.txt\",function(err,data)&#123; if(err)&#123; throw err; &#125; console.log(userid + \"文件读取完毕\"); res.end(data); &#125;); &#125;);server.listen(3000,\"192.168.41.30\"); 创建文件夹fs.mkdir(路径)1234fs.mkdir(\"./test\",function(err)&#123; if(err) throw err; &#125;); 也有回调函数，只不过只接受一个错误信息，要注意目录不可以多级创建，只能一级一级创建。 判断是否是文件夹1234fs.stat(path,function(err,stats) &#123; stats.isDirectory(); stats.isFile();&#125;); fs.stat方法给回调函数传入一个stats参数，这个参数可以用来判断是不是文件夹、文件等等，还可以查看各种信息。 读取文件夹中有哪些文件读取得到一个包含文件名的数组，使用fs.readdir(path,callback) 即可。12345678910111213141516171819202122232425fs.readdir(\"./test\",function (err,files) &#123; console.log(files); &#125;);//[ '111.txt', '222.txt', 'aaa', 'bbb', 'ccc' ]``` 现在我只想读取其中的文件夹的信息（下面为错误示范）``` js fs.readdir(\"./test\",function (err,files) &#123; console.log(\"所有文件：\" + files); //现在我想输出所有的文件夹的名称 var dirs = []; for (var i = 0; i &lt; files.length; i++) &#123; var filename = files[i]; console.log(i); fs.stat(\"./test/\" + filename, function(err,stats) &#123; console.log(filename); console.log(stats.birthtimeMs); if (stats.isDirectory()) &#123; dirs.push(filename); &#125; console.log(dirs); &#125;) &#125; &#125;) 输出结果为:123456789101112131415161718192001234ccc1523971858776.6848[]ccc1523971862328.894[]ccc1523971849602.3806[ &apos;ccc&apos; ]ccc1523971852809.615[ &apos;ccc&apos;, &apos;ccc&apos; ]ccc1523971855378.7153[ &apos;ccc&apos;, &apos;ccc&apos;, &apos;ccc&apos; ] 原因是这样的，由于是异步的，所以fs.stat是在所有的循环完成之后才完成的（可以看到0 1 2 3 4在输出的最上面），而这个时候filename已经变成了ccc了，所以在stat的回调函数中去拿filename（比如输出和加入到dirs中）时，只能拿到ccc，但是本身在传入fs.stat()的第一个路径参数的时候还是正确的文件名，因此回调函数的参数stats还是正确的，所以最后dirs里有三个ccc，对应三个文件夹。正确的做法：将异步变为同步。很经常遇到。使用一个iterator函数，在异步的回调函数（这里的stat的回调）中调用iterator。1234567891011121314151617181920fs.readdir(\"./test\",function (err,files) &#123; console.log(\"所有文件：\" + files); //现在我想输出所有的文件夹的名称 var dirs = []; (function iterator(i) &#123; if (i == files.length) &#123; res.end(); console.log(dirs); return; &#125; var filename = files[i]; fs.stat(\"./test/\" + filename, function(err,stats) &#123; console.log(filename); if (stats.isDirectory()) &#123; dirs.push(filename); &#125; iterator(i + 1); &#125;) &#125;)(0); &#125;) 静态资源文件管理将static文件夹作为根目录，有路径对应关系的路由。要把mime类型写到res的头里面去。通过path.extname(pathname)获得扩展名。因此要引入path模块。显示的文件都是通过readFile真实读取来实现的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748var http = require(\"http\");var url = require(\"url\");var fs = require(\"fs\");var path = require(\"path\");http.createServer(function(req,res)&#123; //得到用户的路径 var pathname = url.parse(req.url).pathname; //默认首页 if(pathname == \"/\")&#123; pathname = \"index.html\"; &#125; //拓展名 var extname = path.extname(pathname); //真的读取这个文件 fs.readFile(\"./static/\" + pathname,function(err,data)&#123; if(err)&#123; //如果此文件不存在，就应该用404返回 fs.readFile(\"./static/404.html\",function(err,data)&#123; res.writeHead(404,&#123;\"Content-type\":\"text/html;charset=UTF8\"&#125;); res.end(data); &#125;); return; &#125;; //MIME类型，就是 //网页文件： text/html //jpg文件 : image/jpg var mime = getMime(extname); res.writeHead(200,&#123;\"Content-type\":mime&#125;); res.end(data); &#125;);&#125;).listen(3000,\"127.0.0.1\");function getMime(extname)&#123; switch(extname)&#123; case \".html\" : return \"text/html\"; break; case \".jpg\" : return \"image/jpg\"; break; case \".css\": return \"text/css\"; break; &#125;&#125;","categories":[{"name":"区块链","slug":"区块链","permalink":"http://gunslingeratlarge.github.io/categories/区块链/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://gunslingeratlarge.github.io/tags/nodejs/"}]},{"title":"leetcode 189. Rotate Array","slug":"leetcode-189-Rotate-Array","date":"2018-04-17T05:44:00.000Z","updated":"2018-06-25T10:21:01.903Z","comments":true,"path":"2018/04/17/leetcode-189-Rotate-Array/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/04/17/leetcode-189-Rotate-Array/","excerpt":"","text":"189. Rotate ArrayDifficulty: Easy Rotate an array of n elements to the right by k steps. For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4]. Note:Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem. Hint:Could you do it in-place with O(1) extra space? Related problem: Solution1234567891011121314class Solution &#123; public void rotate(int[] nums, int k) &#123; int[] pos = new int[nums.length]; k = k % nums.length; for (int i = 0; i &lt; nums.length; i++) &#123; pos[i] = (i + nums.length - k)%nums.length; &#125; int[] temp = Arrays.copyOf(nums,nums.length); for (int i = 0; i &lt; nums.length; i++) &#123; nums[i] = temp[pos[i]]; &#125; &#125;&#125;","categories":[{"name":"刷题","slug":"刷题","permalink":"http://gunslingeratlarge.github.io/categories/刷题/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://gunslingeratlarge.github.io/tags/leetcode/"},{"name":"刷题","slug":"刷题","permalink":"http://gunslingeratlarge.github.io/tags/刷题/"},{"name":"easy","slug":"easy","permalink":"http://gunslingeratlarge.github.io/tags/easy/"}]},{"title":"leetcode 3. Longest Substring Without Repeating Characters","slug":"leetcode-3-Longest-Substring-Without-Repeating-Characters","date":"2018-04-17T04:53:00.000Z","updated":"2018-06-25T10:21:01.904Z","comments":true,"path":"2018/04/17/leetcode-3-Longest-Substring-Without-Repeating-Characters/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/04/17/leetcode-3-Longest-Substring-Without-Repeating-Characters/","excerpt":"3. Longest Substring Without Repeating CharactersDifficulty: Medium Given a string, find the length of the longest substring without repeating characters. Examples: Given &quot;abcabcbb&quot;, the answer is &quot;abc&quot;, which the length is 3. Given &quot;bbbbb&quot;, the answer is &quot;b&quot;, with the length of 1. Given &quot;pwwkew&quot;, the answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.","text":"3. Longest Substring Without Repeating CharactersDifficulty: Medium Given a string, find the length of the longest substring without repeating characters. Examples: Given &quot;abcabcbb&quot;, the answer is &quot;abc&quot;, which the length is 3. Given &quot;bbbbb&quot;, the answer is &quot;b&quot;, with the length of 1. Given &quot;pwwkew&quot;, the answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring. Solution1123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; //做法：从重复元素的下一个元素开始考察 char[] chs = s.toCharArray(); //只能处理26个小写字母，不能处理特殊符号，因此还是要使用map //int[] pos = new int[26]; Map&lt;Character,Integer&gt; map = new HashMap&lt;&gt;(); //Arrays.fill(pos,-1); int head = 0, tail = 0, res = 0, count = 0; while(tail &lt; chs.length) &#123; if (!map.containsKey(chs[tail])) &#123; //pos[chs[tail] - &apos;a&apos;] = tail; map.put(chs[tail],tail); count++; &#125; else &#123; //head不应该等于tail，而应该等于两个重复元素中的第一个的下一个 //head = pos[chs[tail] - &apos;a&apos;] + 1; head = map.get(chs[tail]) + 1; //arr全部置为false //Arrays.fill(pos,-1); map.clear(); //从head到tail，初始化其中的元素对应在arr中的值 for (int i = head; i &lt;= tail; i++) &#123; map.put(chs[i],i); &#125; res = Math.max(count, res); count = tail - head + 1; &#125; tail++; &#125; //如果最后一个元素仍然满足条件的话，res不会被更新 return Math.max(count,res); &#125;&#125; Solution21234567891011121314class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int head,tail,max = 0; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for (head = 0, tail = 0; tail &lt; s.length(); tail++ ) &#123; if (map.containsKey(s.charAt(tail))) &#123; head = Math.max(head, map.get(s.charAt(tail)) + 1); &#125; map.put(s.charAt(tail),tail); max = Math.max(max, tail - head + 1); &#125; return max; &#125;&#125; 思路都是从重复元素的下一个元素开始考察，都使用了hashmap来记录字符的位置，第二种写法有两个特点： max我不再等到产生最大值的情况再求，我每次都求，那么只要你有最大值产生，那么一定跑不掉，这样就减少了什么时候产生max情况的判断 当head去到了字符串的中间，怎么去判断某个字符有没有在这个子串中，我第一种做法是每次更新了head的值就重新初始化map，把子串的字符位置重新放进去，效率很低，第二种做法是不重新初始化，而是判断重复的字符的位置是不是在我head之后，也就是是不是我子串的一部分，如果是我就更新head，不是我就不管了。非常巧妙。","categories":[{"name":"刷题","slug":"刷题","permalink":"http://gunslingeratlarge.github.io/categories/刷题/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://gunslingeratlarge.github.io/tags/leetcode/"},{"name":"刷题","slug":"刷题","permalink":"http://gunslingeratlarge.github.io/tags/刷题/"},{"name":"medium","slug":"medium","permalink":"http://gunslingeratlarge.github.io/tags/medium/"}]},{"title":"leetcode 540. Single Element in a Sorted Array","slug":"leetcode-540-Single-Element-in-a-Sorted-Array","date":"2018-04-16T12:16:00.000Z","updated":"2018-06-25T10:21:01.905Z","comments":true,"path":"2018/04/16/leetcode-540-Single-Element-in-a-Sorted-Array/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/04/16/leetcode-540-Single-Element-in-a-Sorted-Array/","excerpt":"540. Single Element in a Sorted ArrayDifficulty: Medium Given a sorted array consisting of only integers where every element appears twice except for one element which appears once. Find this single element that appears only once.","text":"540. Single Element in a Sorted ArrayDifficulty: Medium Given a sorted array consisting of only integers where every element appears twice except for one element which appears once. Find this single element that appears only once.Example 1: 12**Input:** [1,1,2,3,3,4,4,8,8]**Output:** 2 Example 2: 12**Input:** [3,3,7,7,10,11,11]**Output:** 10 Note: Your solution should run in O(log n) time and O(1) space. Solution123456789class Solution &#123; public int singleNonDuplicate(int[] nums) &#123; int res = 0; for (int num : nums) &#123; res ^= num; &#125; return res; &#125;&#125; 思路：按位异或，一样的就变为0了，留下来的就是那个single number","categories":[{"name":"刷题","slug":"刷题","permalink":"http://gunslingeratlarge.github.io/categories/刷题/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"http://gunslingeratlarge.github.io/tags/刷题/"},{"name":"leetcdde","slug":"leetcdde","permalink":"http://gunslingeratlarge.github.io/tags/leetcdde/"},{"name":"meduim","slug":"meduim","permalink":"http://gunslingeratlarge.github.io/tags/meduim/"}]},{"title":"essence of linear algebra","slug":"essence-of-linear-algebra-chapter1","date":"2018-04-16T05:42:00.000Z","updated":"2018-06-25T10:21:01.900Z","comments":true,"path":"2018/04/16/essence-of-linear-algebra-chapter1/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/04/16/essence-of-linear-algebra-chapter1/","excerpt":"","text":"https://www.youtube.com/watch?v=fNk_zzaMoSs 三种视角物理学：在空间中的箭头，由它的长度和它的方向定义，这两个决定了就可以任意移动一个向量计算机：有序的数字列表数学：结合了两种视角这里我们希望在大家先把一个向量视为坐落在原点处的箭头 向量相加为什么如此定义?每一个向量定义了一个移动方向。两个向量相加就代表把它们的移动方向相组合 标量乘向量对向量长度的scalar 基向量我们可以把一个二维平面上的向量[3,-2]&#39;视为3i + (-2)j，这里i是x方向的基向量，j是y方向的基向量。之前我不理解，为什么C是R的一个扩域，也就是C是R上的一个向量空间。因为C = {a + bi|a，b∈R}，我觉得一个向量不是应该是(0,1)这样二维空间上的点表示的吗？为什么C变成了一个向量空间了。这里可以类比，我们把C中的1视为一个基向量，可以指向任意方向，只要它与i线性无关即可，i是另一个基向量，那就像这里的3i + (-2)j了，或者我们可以不这样取基向量，也是可以的，但是只要这两个基向量线性无关，我们就总是可以说这两个基可以表示这整个空间。当我们对向量使用数值表示时，实际上就隐含了我们对基向量的选择，因为基向量不同，同一个向量会有不用的数值表示。我们用span来描述选定的两个向量（或多个）能够张成的空间。","categories":[{"name":"数学","slug":"数学","permalink":"http://gunslingeratlarge.github.io/categories/数学/"},{"name":"线性代数","slug":"数学/线性代数","permalink":"http://gunslingeratlarge.github.io/categories/数学/线性代数/"}],"tags":[{"name":"线性代数","slug":"线性代数","permalink":"http://gunslingeratlarge.github.io/tags/线性代数/"},{"name":"数学","slug":"数学","permalink":"http://gunslingeratlarge.github.io/tags/数学/"}]},{"title":"leetcode 2. Add Two Numbers","slug":"leetcode-2-Add-Two-Numbers","date":"2018-04-15T05:17:00.000Z","updated":"2018-06-25T10:21:01.904Z","comments":true,"path":"2018/04/15/leetcode-2-Add-Two-Numbers/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/04/15/leetcode-2-Add-Two-Numbers/","excerpt":"2. Add Two NumbersDifficulty: Medium You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself.","text":"2. Add Two NumbersDifficulty: Medium You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example 123**Input:** (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)**Output:** 7 -&gt; 0 -&gt; 8**Explanation:** 342 + 465 = 807. Solution12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode l1cur = l1; ListNode l2cur = l2; ListNode res = null; ListNode rescur = null; //l1 != null &amp;&amp; l2 != null int carry = 0; while(l1cur != null || l2cur != null || carry != 0) &#123; int value = 0; if (l1cur != null &amp;&amp; l2cur!=null) &#123; value = l1cur.val + l2cur.val + carry; l1cur = l1cur.next; l2cur = l2cur.next; &#125; else if (l1cur == null &amp;&amp; l2cur != null)&#123; value = l2cur.val + carry; l2cur = l2cur.next; &#125; else if (l2cur == null &amp;&amp; l1cur != null) &#123; value = l1cur.val + carry; l1cur = l1cur.next; &#125; else &#123; value = carry; &#125; carry = 0; if (value &gt;= 10) &#123; //加法中carry最多为1 carry = 1; value -= 10; &#125; //第一个结点的值 if (res == null) &#123; res = new ListNode(value); rescur = res; &#125; else &#123; //其他节点的值：value ListNode curNode = new ListNode(value); rescur.next = curNode; rescur = curNode; &#125; &#125; return res; &#125;&#125; 思路与收获：一定要想得比较清楚了再做题，思路清晰做起来很快，debug也容易。不要没有什么思路或者有一点点想法了就开始写，结果写到一半了发现自己想错了又涂涂改改。这道题本身没有什么难度，只要注意进位就可以了，各个情况分类讨论清楚就行了。","categories":[{"name":"刷题","slug":"刷题","permalink":"http://gunslingeratlarge.github.io/categories/刷题/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://gunslingeratlarge.github.io/tags/leetcode/"},{"name":"刷题","slug":"刷题","permalink":"http://gunslingeratlarge.github.io/tags/刷题/"},{"name":"medium","slug":"medium","permalink":"http://gunslingeratlarge.github.io/tags/medium/"}]},{"title":"为什么要模质数p和模质数p的幂","slug":"有限群与多项式有限群","date":"2018-04-15T03:12:00.000Z","updated":"2018-06-25T10:21:01.928Z","comments":true,"path":"2018/04/15/有限群与多项式有限群/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/04/15/有限群与多项式有限群/","excerpt":"","text":"https://www.zhihu.com/question/61534896/answer/188767505这个答案写得太好了，非常的清楚。几个思路：由于我们有无限群，我们就思考能不能有有限群？我们发现$Z_p$关于加法是有限群，那关于乘法呢？当p是质数的时候是有限群，如果n是某个质数p，则对于集合{1, 2, …, p-2, p-1}中的任意一个元素a，一定能找到另一个元素b，使得 $a \\times b \\equiv 1 \\bmod p$。（好像这里涉及到欧几里得算法）。这很好地解释了我们为什么要去模质数，并且要讨论模质数之后关于乘法构成群。怎么理解多项式群？尤其是多项式商群？这里补充一点Z3[x]/(x^2 + 1)的元素个数为3^2 = 9个。其他的可以直接看这个答案，讲得非常清楚了。","categories":[{"name":"数学","slug":"数学","permalink":"http://gunslingeratlarge.github.io/categories/数学/"},{"name":"抽象代数","slug":"数学/抽象代数","permalink":"http://gunslingeratlarge.github.io/categories/数学/抽象代数/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://gunslingeratlarge.github.io/tags/数学/"},{"name":"抽象代数","slug":"抽象代数","permalink":"http://gunslingeratlarge.github.io/tags/抽象代数/"}]},{"title":"素域与代数元","slug":"素域与代数元","date":"2018-04-14T03:13:00.000Z","updated":"2018-06-25T10:21:01.931Z","comments":true,"path":"2018/04/14/素域与代数元/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/04/14/素域与代数元/","excerpt":"https://mubu.com/doc/2833zp6EOn 素域 没有真子域的域 域是整环，因此域的charF要么为0要么为素数 F为域，则[F;+]中的非零元同阶，皆为charF 补充：域的特征cahrF：假设p是最小的正整数， 使得p个1相加等于0， 那么p就称为域的特征。 为什么域的特征不是0就是素数？","text":"https://mubu.com/doc/2833zp6EOn 素域 没有真子域的域 域是整环，因此域的charF要么为0要么为素数 F为域，则[F;+]中的非零元同阶，皆为charF 补充：域的特征cahrF：假设p是最小的正整数， 使得p个1相加等于0， 那么p就称为域的特征。 为什么域的特征不是0就是素数？ — K为F的扩域时，charK = charF— F为域，则F必有一个素子域delta 如果charF = 0，则delta与Q同构 如果charF = p，则delta与Z_p同构 — 代数元 K为F的扩域，α属于K，如果f(x)属于F[x],且f(x)不等于0，f(α) = 0，那么alpha为F的代数元，否则为超越元 — 极小多项式 如果p(α) = 0且系数为1，且次数最小（α为根的多项式中次数最小），p(x)为α在F上的极小多项式 特点 唯一 不可约 f(x)属于F(x),f（α）= 0，则p(x)|f(x)","categories":[{"name":"数学","slug":"数学","permalink":"http://gunslingeratlarge.github.io/categories/数学/"},{"name":"抽象代数","slug":"数学/抽象代数","permalink":"http://gunslingeratlarge.github.io/categories/数学/抽象代数/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://gunslingeratlarge.github.io/tags/数学/"},{"name":"抽象代数","slug":"抽象代数","permalink":"http://gunslingeratlarge.github.io/tags/抽象代数/"}]},{"title":"leetcode 79. Word Search","slug":"leetcode-79-Word-Search","date":"2018-04-13T13:39:00.000Z","updated":"2018-06-25T10:21:01.909Z","comments":true,"path":"2018/04/13/leetcode-79-Word-Search/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/04/13/leetcode-79-Word-Search/","excerpt":"79. Word SearchDifficulty: Medium Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.","text":"79. Word SearchDifficulty: Medium Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.For example,Given board = 12345[ [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;], [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;], [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]] word = &quot;ABCCED&quot;, -&gt; returns true,word = &quot;SEE&quot;, -&gt; returns true,word = &quot;ABCB&quot;, -&gt; returns false. Solution12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class Solution &#123; private boolean isMatch = false; private boolean[][] visited; public boolean exist(char[][] board, String word) &#123; if (board.length == 0 || board[0].length == 0) &#123; return false; &#125; visited = new boolean[board.length][board[0].length]; for (int i = 0; i &lt; board.length; i++) &#123; for (int j = 0; j &lt; board[0].length; j++) &#123; dfs(word,0,board,i,j);​ &#125; &#125; return isMatch; &#125; private boolean isValid(int i, int j, char[][] board) &#123; //3 int height = board.length; //4 int width = board[0].length; if (i &gt; height - 1 || j &gt; width - 1 || i &lt; 0 || j &lt; 0)&#123; return false; &#125; if(visited[i][j] == true) &#123; return false; &#125; return true; &#125; private void dfs (String word, int idx, char[][]board, int i, int j) &#123; if (!isValid(i,j,board)) &#123; return; &#125; if (isMatch) &#123; return; &#125;​ if (idx &gt;= word.length()) &#123; return; &#125; if(idx == word.length() - 1 &amp;&amp; word.charAt(idx) == board[i][j]) &#123; isMatch = true; //ystem.out.println(&quot;MMMAtch:now word: &quot; + word.substring(0,idx + 1)); //stem.out.println(&quot;MMMAtch:&quot;+ idx + &quot;i :&quot; + i + &quot;j:&quot; + j); for (int k = 0; k &lt; visited.length; k++) &#123; for (int h = 0; h &lt; visited[0].length; h++) &#123; // System.out.print(visited[k][h]); &#125; //stem.out.println(&quot; &quot;); &#125; return; &#125; //stem.out.println(&quot;now word: &quot; + word.substring(0,idx + 1)); //stem.out.println(idx + &quot;i :&quot; + i + &quot;j:&quot; + j); if(word.charAt(idx) == board[i][j]) &#123; visited[i][j] = true; dfs(word,idx + 1,board,i + 1,j); dfs(word,idx + 1,board,i,j + 1); dfs(word,idx + 1,board,i - 1,j); dfs(word,idx + 1,board,i,j - 1); visited[i][j] = false; &#125; return; &#125;&#125; 思路：dfs即可。DFS使用栈，思路是对于图到的所有顶点u，如果u未被访问，则访问u所在的联通块。访问顶点u：设置u被访问，枚举从u出发可以到达的所有顶点v，如果v未被访问，则递归访问v123456789DFS(u) &#123; vis[u] = true; for (从u出发能到达的v) &#123; if vis[v] == false &#123; DFS(v) &#125; &#125;&#125; 有时也可以不显式地定义一个visitted数组，可以直接更改图，访问过的改为0（如leetcode695），也可以有比较灵活的改动，比如递归调用的DFS可以有返回值之类的。还有一个小技巧要注意的是可以在递归调用的函数里判断是否这次调用时是否是valid的，而不是在调用这个函数时判断，这样就可以不管三七二十一调用这个函数就可以了，因为调用不valid也没有问题直接返回就可以了。回到这道题的话，最好在main方法里只调用一次dfs，其他的东西都扔到dfs本身去做。尽量能够简化写就简化写，可以帮助减少思维负担。除此之外，如果说需要像这道题一样保证每次只出现一次，就可以把visited在其所有的后续节点都遍历完了之后重新设为false。","categories":[{"name":"刷题","slug":"刷题","permalink":"http://gunslingeratlarge.github.io/categories/刷题/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://gunslingeratlarge.github.io/tags/leetcode/"},{"name":"刷题","slug":"刷题","permalink":"http://gunslingeratlarge.github.io/tags/刷题/"},{"name":"medium","slug":"medium","permalink":"http://gunslingeratlarge.github.io/tags/medium/"}]},{"title":"leetcode 791. Custom Sort String","slug":"leetcode-791-Custom-Sort-String","date":"2018-04-12T06:36:00.000Z","updated":"2018-06-25T10:21:01.909Z","comments":true,"path":"2018/04/12/leetcode-791-Custom-Sort-String/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/04/12/leetcode-791-Custom-Sort-String/","excerpt":"791. Custom Sort StringDifficulty: Medium S and T are strings composed of lowercase letters. In S, no letter occurs more than once. S was sorted in some custom order previously. We want to permute the characters of T so that they match the order that S was sorted. More specifically, if x occurs before y in S, then x should occur before y in the returned string. Return any permutation of T (as a string) that satisfies this property.","text":"791. Custom Sort StringDifficulty: Medium S and T are strings composed of lowercase letters. In S, no letter occurs more than once. S was sorted in some custom order previously. We want to permute the characters of T so that they match the order that S was sorted. More specifically, if x occurs before y in S, then x should occur before y in the returned string. Return any permutation of T (as a string) that satisfies this property.12345678**Example :****Input:** S = &quot;cba&quot;T = &quot;abcd&quot;**Output:** &quot;cbad&quot;**Explanation:** &quot;a&quot;, &quot;b&quot;, &quot;c&quot; appear in S, so the order of &quot;a&quot;, &quot;b&quot;, &quot;c&quot; should be &quot;c&quot;, &quot;b&quot;, and &quot;a&quot;. Since &quot;d&quot; does not appear in S, it can be at any position in T. &quot;dcba&quot;, &quot;cdba&quot;, &quot;cbda&quot; are also valid outputs. Note: S has length at most 26, and no character is repeated in S. T has length at most 200. S and T consist of lowercase letters only. Solution1234567891011121314151617181920212223class Solution &#123; public String customSortString(String S, String T) &#123; //在s中，则先排了，如果不在s中，最后再排，所以要遍历s int[] chs = new int[26]; for (char c: T.toCharArray()) &#123; chs[c - &apos;a&apos;]++; &#125; StringBuilder sb = new StringBuilder(); for (char c:S.toCharArray()) &#123; while(chs[c - &apos;a&apos;]-- &gt; 0) &#123; sb.append(c); &#125; &#125; for (char c: T.toCharArray()) &#123; while(chs[c-&apos;a&apos;]-- &gt; 0) &#123; sb.append(c); &#125; &#125; return sb.toString(); &#125;&#125; 思路：将T中字符放到桶中，每个字母有几个放放好。然后遍历s，在s中的就拿出去先排了，最后遍历t，把t剩下的(不在s中的）再放进去。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://gunslingeratlarge.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://gunslingeratlarge.github.io/tags/leetcode/"},{"name":"刷题","slug":"刷题","permalink":"http://gunslingeratlarge.github.io/tags/刷题/"},{"name":"medium","slug":"medium","permalink":"http://gunslingeratlarge.github.io/tags/medium/"}]},{"title":"leetcode 506. Relative Ranks","slug":"leetcode-506-Relative-Ranks","date":"2018-04-12T05:43:00.000Z","updated":"2018-06-25T10:21:01.905Z","comments":true,"path":"2018/04/12/leetcode-506-Relative-Ranks/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/04/12/leetcode-506-Relative-Ranks/","excerpt":"506. Relative RanksDifficulty: Easy Given scores of N athletes, find their relative ranks and the people with the top three highest scores, who will be awarded medals: “Gold Medal”, “Silver Medal” and “Bronze Medal”. Example 1:","text":"506. Relative RanksDifficulty: Easy Given scores of N athletes, find their relative ranks and the people with the top three highest scores, who will be awarded medals: “Gold Medal”, “Silver Medal” and “Bronze Medal”. Example 1:1234**Input:** [5, 4, 3, 2, 1]**Output:** [&quot;Gold Medal&quot;, &quot;Silver Medal&quot;, &quot;Bronze Medal&quot;, &quot;4&quot;, &quot;5&quot;]**Explanation:** The first three athletes got the top three highest scores, so they got &quot;Gold Medal&quot;, &quot;Silver Medal&quot; and &quot;Bronze Medal&quot;. For the left two athletes, you just need to output their relative ranks according to their scores. Note: N is a positive integer and won’t exceed 10,000. All the scores of athletes are guaranteed to be unique. Solution12345678910111213141516171819202122232425262728class Solution &#123; public String[] findRelativeRanks(int[] nums) &#123; int[] descent = Arrays.copyOf(nums,nums.length); Arrays.sort(descent); for(int start = 0, end = descent.length - 1; start &lt; end; start++,end--)&#123; int temp = descent[start]; descent[start] = descent[end]; descent[end] = temp; &#125; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for (int i =0; i &lt; descent.length; i++) &#123; map.put(descent[i],i+1); &#125; String[] res = new String[nums.length]; for (int i = 0; i &lt; nums.length;i++) &#123; if(map.get(nums[i]) == 1) &#123; res[i] = &quot;Gold Medal&quot;; &#125; else if (map.get(nums[i]) == 2) &#123; res[i] = &quot;Silver Medal&quot;; &#125; else if (map.get(nums[i]) == 3) &#123; res[i] = &quot;Bronze Medal&quot;; &#125; else &#123; res[i] = &quot;&quot; + map.get(nums[i]); &#125; &#125; return res; &#125;&#125; 思路：将得分-名次放到map中，如何找到某个得分的名词呢？ 排序后的index就是名词。另外，java中对数组逆序可以很快地写出来，左、右两个指针，相互交换，左加加，右减减，直到左大于等于右。int转String：Integer.parseInt(num);String转int: num + “” String.valueOf(num);","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://gunslingeratlarge.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://gunslingeratlarge.github.io/tags/leetcode/"},{"name":"刷题","slug":"刷题","permalink":"http://gunslingeratlarge.github.io/tags/刷题/"},{"name":"easy","slug":"easy","permalink":"http://gunslingeratlarge.github.io/tags/easy/"}]},{"title":"以太坊源码分析02-rlp part2","slug":"以太坊源码分析02-rlp-part2","date":"2018-04-11T11:43:00.000Z","updated":"2018-06-25T10:21:01.919Z","comments":true,"path":"2018/04/11/以太坊源码分析02-rlp-part2/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/04/11/以太坊源码分析02-rlp-part2/","excerpt":"分析有空再补上。","text":"分析有空再补上。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935package org.ethereum.util;import java.math.BigInteger;import java.nio.ByteBuffer;import java.util.ArrayList;import java.util.Arrays;import java.util.Queue;import static java.util.Arrays.copyOfRange;import static org.ethereum.util.ByteUtil.byteArrayToInt;import static org.spongycastle.util.Arrays.concatenate;import java.util.List;import org.ethereum.util.RLP;import org.ethereum.util.RLPItem;import org.ethereum.util.RLPList;/** * Recursive Length Prefix (RLP) encoding. * * The purpose of RLP is to encode arbitrarily nested arrays of binary data, and * RLP is the main encoding method used to serialize objects in Ethereum. The * only purpose of RLP is to encode structure; encoding specific atomic data * types (eg. strings, ints, floats) is left up to higher-order protocols; in * Ethereum the standard is that integers are represented in big endian binary * form. If one wishes to use RLP to encode a dictionary, the two suggested * canonical forms are to either use [[k1,v1],[k2,v2]...] with keys in * lexicographic order or to use the higher-level Patricia Tree encoding as * Ethereum does. * * The RLP encoding function takes in an item. An item is defined as follows: * * - A string (ie. byte array) is an item - A list of items is an item * * For example, an empty string is an item, as is the string containing the word * \"cat\", a list containing any number of strings, as well as more complex data * structures like [\"cat\",[\"puppy\",\"cow\"],\"horse\",[[]],\"pig\",[\"\"],\"sheep\"]. Note * that in the context of the rest of this article, \"string\" will be used as a * synonym for \"a certain number of bytes of binary data\"; no special encodings * are used and no knowledge about the content of the strings is implied. * * See: https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-RLP */public class RLP &#123; /** Allow for content up to size of 2^64 bytes **/ private static double MAX_ITEM_LENGTH = Math.pow(256, 8); /** * Reason for threshold according to Vitalik Buterin: * - 56 bytes maximizes the benefit of both options * - if we went with 60 then we would have only had 4 slots for long strings * so RLP would not have been able to store objects above 4gb * - if we went with 48 then RLP would be fine for 2^128 space, but that's way too much * - so 56 and 2^64 space seems like the right place to put the cutoff * - also, that's where Bitcoin's varint does the cutoff **/ private static int SIZE_THRESHOLD = 56; /** RLP encoding rules are defined as follows: */ /* * For a single byte whose value is in the [0x00, 0x7f] range, that byte is * its own RLP encoding. */ /* * If a string is 0-55 bytes long, the RLP encoding consists of a single * byte with value 0x80 plus the length of the string followed by the * string. The range of the first byte is thus [0x80, 0xb7]. */ private static int OFFSET_SHORT_ITEM = 0x80; /* * If a string is more than 55 bytes long, the RLP encoding consists of a * single byte with value 0xb7 plus the length of the length of the string * in binary form, followed by the length of the string, followed by the * string. For example, a length-1024 string would be encoded as * \\xb9\\x04\\x00 followed by the string. The range of the first byte is thus * [0xb8, 0xbf]. */ private static int OFFSET_LONG_ITEM = 0xb8; /* * If the total payload of a list (i.e. the combined length of all its * items) is 0-55 bytes long, the RLP encoding consists of a single byte * with value 0xc0 plus the length of the list followed by the concatenation * of the RLP encodings of the items. The range of the first byte is thus * [0xc0, 0xf7]. */ private static int OFFSET_SHORT_LIST = 0xc0; /* * If the total payload of a list is more than 55 bytes long, the RLP * encoding consists of a single byte with value 0xf7 plus the length of the * length of the list in binary form, followed by the length of the list, * followed by the concatenation of the RLP encodings of the items. The * range of the first byte is thus [0xf8, 0xff]. */ private static int OFFSET_LONG_LIST = 0xf8; /* ****************************************************** * DECODING * * ******************************************************/ //解析byte型 private static byte decodeOneByteItem(byte[] data, int index) &#123; // null item if ((data[index] &amp; 0xFF) == OFFSET_SHORT_ITEM) &#123; return (byte) (data[index] - OFFSET_SHORT_ITEM); &#125; // single byte item if ((data[index] &amp; 0xFF) &lt; OFFSET_SHORT_ITEM) &#123; return (byte) (data[index]); &#125; // single byte item // 大于等于127的情况 if ((data[index] &amp; 0xFF) == OFFSET_SHORT_ITEM+1) &#123; return (byte) (data[index + 1]); &#125; return 0; &#125; //解析int型 public static int decodeInt(byte[] data, int index) &#123; int value = 0; //为什么要有一个index，因为有可能从其他位置解析，不一定是开头，比如dog,cat,对dog有可能要单独解析 //大于128，小于183，即1-55字节数据（非列表 if ((data[index] &amp; 0xFF) &gt; OFFSET_SHORT_ITEM &amp;&amp; (data[index] &amp; 0xFF) &lt; 0xB7) &#123; System.out.println(data[index] - OFFSET_SHORT_ITEM); //byte length = (byte) (data[index] - OFFSET_SHORT_ITEM); //&amp;0xff就把它转成了无符号数，就从-126转为了130，（256 - 126），再减去130即可 byte length =(byte)( data[index] &amp; 0xff - OFFSET_SHORT_ITEM); //我们考察一个例子1024，这个整数，存为 1000 0010 0000 0100 0000 0000，length为2， //第一次value加上了0000 0100左移八位的数，即1024，第二次就是最后八位了 byte pow = (byte) (length - 1); for (int i = 1; i &lt;= length; ++i) &#123; value += data[index + i] &lt;&lt; (8 * pow); pow--; &#125; //解析一个int，长度不可能达到56字节及以上的，如果达到了就说明有问题 &#125; else &#123; throw new RuntimeException(\"wrong decode attempt\"); &#125; return value; &#125; //解析short型 private static short decodeShort(byte[] data, int index) &#123; short value = 0; if ((data[index] &amp; 0xFF) &gt; OFFSET_SHORT_ITEM &amp;&amp; (data[index] &amp; 0xFF) &lt; 0xB7) &#123; byte length = (byte) (data[index] - OFFSET_SHORT_ITEM); value = ByteBuffer.wrap(data, index, length).getShort(); &#125; else &#123; value = data[index]; &#125; return value; &#125; //跟int型可以说是一模一样 private static long decodeLong(byte[] data, int index) &#123; long value = 0; if ((data[index] &amp; 0xFF) &gt; OFFSET_SHORT_ITEM &amp;&amp; (data[index] &amp; 0xFF) &lt; 0xB7) &#123; byte length = (byte) (data[index] - OFFSET_SHORT_ITEM); byte pow = (byte) (length - 1); for (int i = 1; i &lt;= length; ++i) &#123; value += data[index + i] &lt;&lt; (8 * pow); pow--; &#125; &#125; else &#123; throw new RuntimeException(\"wrong decode attempt\"); &#125; return value; &#125; private static String decodeStringItem(byte[] data, int index) &#123; String value = null; //183-192 if ((data[index] &amp; 0xFF) &gt;= 0xB7 &amp;&amp; (data[index] &amp; 0xFF) &lt; OFFSET_SHORT_LIST) &#123; //其实就是长度的长度，比如我们之前的例子中，183,30，。。。这里30是后面省略号的长度，而长度的长度即 //30的长度就是1. byte lengthOfLength = (byte) (data[index] - 0xB7); //现在知道了lengthoflength是1，接下来就是去拿出这个长度为1的length然后返回为int int length = calcLengthRaw(lengthOfLength, data, index); //然后再把后面的数据拿出来作为字符串 value = new String(data, index + lengthOfLength + 1, length); //128-183 如果是数据是1-55字节以内的 &#125; else if ((data[index] &amp; 0xFF) &gt; OFFSET_SHORT_ITEM &amp;&amp; (data[index] &amp; 0xFF) &lt; 0xB7) &#123; //这个长度也可以改为我的写法，也没问题 byte length = (byte) ((data[index] &amp; 0xFF) - OFFSET_SHORT_ITEM); //取除了长度位以外的部分 value = new String(data, index + 1, length); &#125; else &#123; throw new RuntimeException(\"wrong decode attempt\"); &#125; return value; &#125; //类似，先不细看了 private static byte[] decodeItemBytes(byte[] data, int index) &#123; byte[] value = null; int length = 0; if ((data[index] &amp; 0xFF) &gt;= 0xB7 &amp;&amp; (data[index] &amp; 0xFF) &lt; OFFSET_SHORT_LIST) &#123; byte lengthOfLength = (byte) (data[index] - 0xB7); length = calcLengthRaw(lengthOfLength, data, index); &#125; else if ((data[index] &amp; 0xFF) &gt; OFFSET_SHORT_ITEM &amp;&amp; (data[index] &amp; 0xFF) &lt; 0xB7) &#123; length = (byte) (data[index] - OFFSET_SHORT_ITEM); &#125; else &#123; throw new RuntimeException(\"wrong decode attempt\"); &#125; byte[] valueBytes = new byte[length]; System.arraycopy(data, index, valueBytes, 0, length); value = valueBytes; return value; &#125; //大整数也类似 public static BigInteger decodeBigInteger(byte[] data, int index) &#123; BigInteger value = null; int length = 0; if ((data[index] &amp; 0xFF) &gt;= 0xB7 &amp;&amp; (data[index] &amp; 0xFF) &lt; OFFSET_SHORT_LIST) &#123; byte lengthOfLength = (byte) (data[index] - 0xB7); length = calcLengthRaw(lengthOfLength, data, index); &#125; else if ((data[index] &amp; 0xFF) &gt; OFFSET_SHORT_ITEM &amp;&amp; (data[index] &amp; 0xFF) &lt; 0xB7) &#123; length = (byte) (data[index] - OFFSET_SHORT_ITEM); &#125; else &#123; throw new RuntimeException(\"wrong decode attempt\"); &#125; byte[] valueBytes = new byte[length]; System.arraycopy(data, index, valueBytes, 0, length); value = new BigInteger(valueBytes); return value; &#125; //与decodeByteArray类似 private static byte[] decodeByteArray(byte[] data, int index) &#123; byte[] value = null; int length = 0; if ((data[index] &amp; 0xFF) &gt;= 0xB7 &amp;&amp; (data[index] &amp; 0xFF) &lt; OFFSET_SHORT_LIST) &#123; byte lengthOfLength = (byte) (data[index] - 0xB7); length = calcLengthRaw(lengthOfLength, data, index); &#125; else if ((data[index] &amp; 0xFF) &gt; OFFSET_SHORT_ITEM &amp;&amp; (data[index] &amp; 0xFF) &lt; 0xB7) &#123; length = (byte) (data[index] - OFFSET_SHORT_ITEM); &#125; else &#123; throw new RuntimeException(\"wrong decode attempt\"); &#125; byte[] valueBytes = new byte[length]; System.arraycopy(data, index, valueBytes, 0, length); value = valueBytes; return value; &#125; private static int nextItemLength(byte[] data, int index) &#123; if (index &gt;= data.length) return -1; if ((data[index] &amp; 0xFF) &gt;= 0xF7) &#123; byte lengthOfLength = (byte) (data[index] - 0xF7); int length = calcLength(lengthOfLength, data, index); return length; &#125; if ((data[index] &amp; 0xFF) &gt;= OFFSET_SHORT_LIST &amp;&amp; (data[index] &amp; 0xFF) &lt; 0xF7) &#123; byte length = (byte) ((data[index] &amp; 0xFF) - OFFSET_SHORT_LIST); return length; &#125; if ((data[index] &amp; 0xFF) &gt;= 0xB7 &amp;&amp; (data[index] &amp; 0xFF) &lt; OFFSET_SHORT_LIST) &#123; byte lengthOfLength = (byte) (data[index] - 0xB7); int length = calcLength(lengthOfLength, data, index); return length; &#125; if ((data[index] &amp; 0xFF) &gt; OFFSET_SHORT_ITEM &amp;&amp; (data[index] &amp; 0xFF) &lt; 0xB7) &#123; byte length = (byte) ((data[index] &amp; 0xFF) - OFFSET_SHORT_ITEM); return length; &#125; if ((data[index] &amp; 0xFF) == OFFSET_SHORT_ITEM) &#123; return 1; &#125; if ((data[index] &amp; 0xFF) &lt; OFFSET_SHORT_ITEM) &#123; return 1; &#125; return -1; &#125; public static byte[] decodeIP4Bytes(byte[] data, int index) &#123; int length = (data[index] &amp; 0xFF) - OFFSET_SHORT_LIST; int offset = 1; byte aByte = decodeOneByteItem(data, index + offset); if ((data[index + offset] &amp; 0xFF) &gt; OFFSET_SHORT_ITEM) offset = offset + 2; else offset = offset + 1; byte bByte = decodeOneByteItem(data, index + offset); if ((data[index + offset] &amp; 0xFF) &gt; OFFSET_SHORT_ITEM) offset = offset + 2; else offset = offset + 1; byte cByte = decodeOneByteItem(data, index + offset); if ((data[index + offset] &amp; 0xFF) &gt; OFFSET_SHORT_ITEM) offset = offset + 2; else offset = offset + 1; byte dByte = decodeOneByteItem(data, index + offset); // return IP address return new byte[] &#123; aByte, bByte, cByte, dByte &#125; ; &#125; //获得有效载荷中的第一个元素 public static int getFirstListElement(byte[] payload, int pos) &#123; if (pos &gt;= payload.length) return -1; if ((payload[pos] &amp; 0xFF) &gt;= 0xF7) &#123; byte lengthOfLength = (byte) (payload[pos] - 0xF7); return pos + lengthOfLength + 1; &#125; if ((payload[pos] &amp; 0xFF) &gt;= OFFSET_SHORT_LIST &amp;&amp; (payload[pos] &amp; 0xFF) &lt; 0xF7) &#123; return pos + 1; &#125; if ((payload[pos] &amp; 0xFF) &gt;= 0xB7 &amp;&amp; (payload[pos] &amp; 0xFF) &lt; OFFSET_SHORT_LIST) &#123; byte lengthOfLength = (byte) (payload[pos] - 0xB7); return pos + lengthOfLength + 1; &#125; return -1; &#125; public static int getNextElementIndex(byte[] payload, int pos) &#123; if (pos &gt;= payload.length) return -1; if ((payload[pos] &amp; 0xFF) &gt;= 0xF7) &#123; byte lengthOfLength = (byte) (payload[pos] - 0xF7); int length = calcLength(lengthOfLength, payload, pos); return pos + lengthOfLength + length + 1; &#125; if ((payload[pos] &amp; 0xFF) &gt;= OFFSET_SHORT_LIST &amp;&amp; (payload[pos] &amp; 0xFF) &lt; 0xF7) &#123; byte length = (byte) ((payload[pos] &amp; 0xFF) - OFFSET_SHORT_LIST); return pos + 1 + length; &#125; if ((payload[pos] &amp; 0xFF) &gt;= 0xB7 &amp;&amp; (payload[pos] &amp; 0xFF) &lt; OFFSET_SHORT_LIST) &#123; byte lengthOfLength = (byte) (payload[pos] - 0xB7); int length = calcLength(lengthOfLength, payload, pos); return pos + lengthOfLength + length + 1; &#125; if ((payload[pos] &amp; 0xFF) &gt; OFFSET_SHORT_ITEM &amp;&amp; (payload[pos] &amp; 0xFF) &lt; 0xB7) &#123; byte length = (byte) ((payload[pos] &amp; 0xFF) - OFFSET_SHORT_ITEM); return pos + 1 + length; &#125; if ((payload[pos] &amp; 0xFF) == OFFSET_SHORT_ITEM) &#123; return pos + 1; &#125; if ((payload[pos] &amp; 0xFF) &lt; OFFSET_SHORT_ITEM) &#123; return pos + 1; &#125; return -1; &#125; /** * Get exactly one message payload */ public static void fullTraverse(byte[] msgData, int level, int startPos, int endPos, int levelToIndex, Queue&lt;Integer&gt; index) &#123; try &#123; if (msgData == null || msgData.length == 0) return; int pos = startPos; while (pos &lt; endPos) &#123; if (level == levelToIndex) index.add(new Integer(pos)); // It's a list with a payload more than 55 bytes // data[0] - 0xF7 = how many next bytes allocated // for the length of the list if ((msgData[pos] &amp; 0xFF) &gt;= 0xF7) &#123; byte lengthOfLength = (byte) (msgData[pos] - 0xF7); int length = calcLength(lengthOfLength, msgData, pos); // now we can parse an item for data[1]..data[length] System.out.println(\"-- level: [\" + level + \"] Found big list length: \" + length); fullTraverse(msgData, level + 1, pos + lengthOfLength + 1, pos + lengthOfLength + length, levelToIndex, index); pos += lengthOfLength + length + 1; continue; &#125; // It's a list with a payload less than 55 bytes if ((msgData[pos] &amp; 0xFF) &gt;= OFFSET_SHORT_LIST &amp;&amp; (msgData[pos] &amp; 0xFF) &lt; 0xF7) &#123; byte length = (byte) ((msgData[pos] &amp; 0xFF) - OFFSET_SHORT_LIST); System.out.println(\"-- level: [\" + level + \"] Found small list length: \" + length); fullTraverse(msgData, level + 1, pos + 1, pos + length + 1, levelToIndex, index); pos += 1 + length; continue; &#125; // It's an item with a payload more than 55 bytes // data[0] - 0xB7 = how much next bytes allocated for // the length of the string if ((msgData[pos] &amp; 0xFF) &gt;= 0xB7 &amp;&amp; (msgData[pos] &amp; 0xFF) &lt; OFFSET_SHORT_LIST) &#123; byte lengthOfLength = (byte) (msgData[pos] - 0xB7); int length = calcLength(lengthOfLength, msgData, pos); // now we can parse an item for data[1]..data[length] System.out.println(\"-- level: [\" + level + \"] Found big item length: \" + length); pos += lengthOfLength + length + 1; continue; &#125; // It's an item less than 55 bytes long, // data[0] - 0x80 == length of the item if ((msgData[pos] &amp; 0xFF) &gt; OFFSET_SHORT_ITEM &amp;&amp; (msgData[pos] &amp; 0xFF) &lt; 0xB7) &#123; byte length = (byte) ((msgData[pos] &amp; 0xFF) - OFFSET_SHORT_ITEM); System.out.println(\"-- level: [\" + level + \"] Found small item length: \" + length); pos += 1 + length; continue; &#125; // null item if ((msgData[pos] &amp; 0xFF) == OFFSET_SHORT_ITEM) &#123; System.out.println(\"-- level: [\" + level + \"] Found null item: \"); pos += 1; continue; &#125; // single byte item if ((msgData[pos] &amp; 0xFF) &lt; OFFSET_SHORT_ITEM) &#123; System.out.println(\"-- level: [\" + level + \"] Found single item: \"); pos += 1; continue; &#125; &#125; &#125; catch (Throwable th) &#123; throw new RuntimeException(\"wire packet not parsed correctly\", th.fillInStackTrace()); &#125; &#125; //这两个方法是一模一样的 private static int calcLength(int lengthOfLength, byte[] msgData, int pos) &#123; byte pow = (byte) (lengthOfLength - 1); int length = 0; for (int i = 1; i &lt;= lengthOfLength; ++i) &#123; length += (msgData[pos + i] &amp; 0xFF) &lt;&lt; (8 * pow); pow--; &#125; return length; &#125; private static int calcLengthRaw(int lengthOfLength, byte[] msgData, int index) &#123; byte pow = (byte) (lengthOfLength - 1); int length = 0; //像之前求值一样，先求最前面八位，再求接下来八位，...一直继续下去 for (int i = 1; i &lt;= lengthOfLength; ++i) &#123; length += msgData[index + i] &lt;&lt; (8 * pow); pow--; &#125; return length; &#125; //命令码可能是在一个列表中一起传过来的，而命令码应该是一个小于127的数，getFirstListElement是获得list中的第一个元素也就是命令码 public static byte getCommandCode(byte[] data) &#123; byte command = 0; int index = getFirstListElement(data, 0); command = data[index]; command = ((int) (command &amp; 0xFF) == OFFSET_SHORT_ITEM) ? 0 : command; return command; &#125; /** * Parse wire byte[] message into RLP elements * * @param msgData * - raw RLP data * @param rlpList * - outcome of recursive RLP structure */ public static RLPList decode2(byte[] msgData) &#123; RLPList rlpList = new RLPList(); fullTraverse(msgData, 0, 0, msgData.length, 1, rlpList); return rlpList; &#125; /** * Get exactly one message payload */ private static void fullTraverse(byte[] msgData, int level, int startPos, int endPos, int levelToIndex, RLPList rlpList) &#123; try &#123; if (msgData == null || msgData.length == 0) return; int pos = startPos; while (pos &lt; endPos) &#123; // It's a list with a payload more than 55 bytes // data[0] - 0xF7 = how many next bytes allocated // for the length of the list if ((msgData[pos] &amp; 0xFF) &gt;= 0xF7) &#123; byte lengthOfLength = (byte) (msgData[pos] - 0xF7); int length = calcLength(lengthOfLength, msgData, pos); byte[] rlpData = new byte[lengthOfLength + length + 1]; System.arraycopy(msgData, pos, rlpData, 0, lengthOfLength + length + 1); RLPList newLevelList = new RLPList(); newLevelList.setRLPData(rlpData); // todo: this done to get some data for testing should be // delete // byte[] subList = Arrays.copyOfRange(msgData, pos, pos + // lengthOfLength + length + 1); // System.out.println(Utils.toHexString(subList)); fullTraverse(msgData, level + 1, pos + lengthOfLength + 1, pos + lengthOfLength + length + 1, levelToIndex, newLevelList); rlpList.add(newLevelList); pos += lengthOfLength + length + 1; continue; &#125; // It's a list with a payload less than 55 bytes if ((msgData[pos] &amp; 0xFF) &gt;= OFFSET_SHORT_LIST &amp;&amp; (msgData[pos] &amp; 0xFF) &lt; 0xF7) &#123; byte length = (byte) ((msgData[pos] &amp; 0xFF) - OFFSET_SHORT_LIST); byte[] rlpData = new byte[length + 1]; System.arraycopy(msgData, pos, rlpData, 0, length + 1); RLPList newLevelList = new RLPList(); newLevelList.setRLPData(rlpData); if (length &gt; 0) fullTraverse(msgData, level + 1, pos + 1, pos + length + 1, levelToIndex, newLevelList); rlpList.add(newLevelList); pos += 1 + length; continue; &#125; // It's an item with a payload more than 55 bytes // data[0] - 0xB7 = how much next bytes allocated for // the length of the string if ((msgData[pos] &amp; 0xFF) &gt;= 0xB7 &amp;&amp; (msgData[pos] &amp; 0xFF) &lt; OFFSET_SHORT_LIST) &#123; byte lengthOfLength = (byte) (msgData[pos] - 0xB7); int length = calcLength(lengthOfLength, msgData, pos); // now we can parse an item for data[1]..data[length] byte[] item = new byte[length]; System.arraycopy(msgData, pos + lengthOfLength + 1, item, 0, length); byte[] rlpPrefix = new byte[lengthOfLength + 1]; System.arraycopy(msgData, pos, rlpPrefix, 0, lengthOfLength + 1); RLPItem rlpItem = new RLPItem(item); rlpList.add(rlpItem); pos += lengthOfLength + length + 1; continue; &#125; // It's an item less than 55 bytes long, // data[0] - 0x80 == length of the item if ((msgData[pos] &amp; 0xFF) &gt; OFFSET_SHORT_ITEM &amp;&amp; (msgData[pos] &amp; 0xFF) &lt; 0xB7) &#123; byte length = (byte) ((msgData[pos] &amp; 0xFF) - OFFSET_SHORT_ITEM); byte[] item = new byte[length]; System.arraycopy(msgData, pos + 1, item, 0, length); byte[] rlpPrefix = new byte[2]; System.arraycopy(msgData, pos, rlpPrefix, 0, 2); RLPItem rlpItem = new RLPItem(item); rlpList.add(rlpItem); pos += 1 + length; continue; &#125; // null item if ((msgData[pos] &amp; 0xFF) == OFFSET_SHORT_ITEM) &#123; byte[] item = new byte[0]; RLPItem rlpItem = new RLPItem(item); rlpList.add(rlpItem); pos += 1; continue; &#125; // single byte item if ((msgData[pos] &amp; 0xFF) &lt; OFFSET_SHORT_ITEM) &#123; byte[] item = &#123; (byte) (msgData[pos] &amp; 0xFF) &#125;; RLPItem rlpItem = new RLPItem(item); rlpList.add(rlpItem); pos += 1; continue; &#125; &#125; &#125; catch (Throwable th) &#123; throw new RuntimeException(\"wire packet not parsed correctly\", th.fillInStackTrace()); &#125; &#125; /** * Reads any RLP encoded byte-array and returns all objects as byte-array or list of byte-arrays * * @param data RLP encoded byte-array * @param pos position in the array to start reading * @return DecodeResult encapsulates the decoded items as a single Object and the final read position */ public static DecodeResult decode(byte[] data, int pos) &#123; if (data == null || data.length &lt; 1) &#123; return null; &#125; int prefix = data[pos] &amp; 0xFF; if (prefix == OFFSET_SHORT_ITEM) &#123; return new DecodeResult(pos+1, new byte[0]); // means no length or 0 &#125; else if (prefix &lt; OFFSET_SHORT_ITEM) &#123; return new DecodeResult(pos+1, new byte[] &#123; data[pos] &#125;); // byte is its own RLP encoding &#125; else if (prefix &lt; OFFSET_LONG_ITEM)&#123; int len = prefix - OFFSET_SHORT_ITEM; // length of the encoded bytes return new DecodeResult(pos+1+len, copyOfRange(data, pos+1, pos+1+len)); &#125; else if (prefix &lt; OFFSET_SHORT_LIST) &#123; int lenlen = prefix - OFFSET_LONG_ITEM + 1; // length of length the encoded bytes int lenbytes = byteArrayToInt(copyOfRange(data, pos+1, pos+1+lenlen)); // length of encoded bytes return new DecodeResult(pos+1+lenlen+lenbytes, copyOfRange(data, pos+1+lenlen, pos+1+lenlen+lenbytes)); &#125; else if (prefix &lt; OFFSET_LONG_LIST) &#123; int len = prefix - OFFSET_SHORT_LIST; // length of the encoded list int prevPos = pos; pos++; return decodeList(data, pos, prevPos, len); &#125; else if (prefix &lt; 0xFF) &#123; int lenlen = prefix - OFFSET_LONG_LIST + 1; // length of length the encoded list int lenlist = byteArrayToInt(copyOfRange(data, pos+1, pos+1+lenlen)); // length of encoded bytes pos = pos + lenlen + 1; int prevPos = lenlist; return decodeList(data, pos, prevPos, lenlist); &#125; else &#123; throw new RuntimeException(\"Only byte values between 0x00 and 0xFF are supported, but got: \" + prefix); &#125; &#125; private static DecodeResult decodeList(byte[] data, int pos, int prevPos, int len) &#123; List&lt;Object&gt; slice = new ArrayList&lt;Object&gt;(); for (int i = 0; i &lt; len;) &#123; // Get the next item in the data list and append it DecodeResult result = decode(data, pos); slice.add(result.getDecoded()); // Increment pos by the amount bytes in the previous read prevPos = result.getPos(); i += (prevPos - pos); pos = prevPos; &#125; return new DecodeResult(pos, slice.toArray()); &#125; /* ****************************************************** * ENCODING * * ******************************************************/ /** * Turn Object into its RLP encoded equivalent of a byte-array * Support for String, Integer, BigInteger and Lists of any of these types. * * @param item as object or List of objects * @return byte[] RLP encoded */ public static byte[] encode(Object input) &#123; Value val = new Value(input); if (val.isList()) &#123; List&lt;Object&gt; inputArray = val.asList(); if (inputArray.size() == 0) &#123; return encodeLength(inputArray.size(), OFFSET_SHORT_LIST); &#125; byte[] output = new byte[0]; for (Object object : inputArray) &#123; output = concatenate(output, encode(object)); &#125; byte[] prefix = encodeLength(output.length, OFFSET_SHORT_LIST); return concatenate(prefix, output); &#125; else &#123; byte[] inputAsBytes = toBytes(input); if(inputAsBytes.length == 1) &#123; return inputAsBytes; &#125; else &#123; byte[] firstByte = encodeLength(inputAsBytes.length, OFFSET_SHORT_ITEM); return concatenate(firstByte, inputAsBytes); &#125; &#125; &#125; /** Integer limitation goes up to 2^31-1 so length can never be bigger than MAX_ITEM_LENGTH */ public static byte[] encodeLength(int length, int offset) &#123; if (length &lt; SIZE_THRESHOLD) &#123; byte firstByte = (byte) (length + offset); return new byte[] &#123; firstByte &#125;; &#125; else if (length &lt; MAX_ITEM_LENGTH) &#123; byte[] binaryLength; if(length &gt; 0xFF) binaryLength = BigInteger.valueOf(length).toByteArray(); else binaryLength = new byte[] &#123; (byte) length &#125;; byte firstByte = (byte) (binaryLength.length + offset + SIZE_THRESHOLD - 1 ); return concatenate(new byte[] &#123; firstByte &#125;, binaryLength); &#125; else &#123; throw new RuntimeException(\"Input too long\"); &#125; &#125; public static byte[] encodeByte(byte singleByte) &#123; //如果是0，那么就编码为0x80 if ((singleByte &amp; 0xFF) == 0) &#123; return new byte[] &#123; (byte) OFFSET_SHORT_ITEM &#125;; //如果小于127，那么就不动 &#125; else if ((singleByte &amp; 0xFF) &lt; 0x7F) &#123; return new byte[] &#123; singleByte &#125;; //如果大于等于127 &#125; else &#123; return new byte[] &#123; (byte) (OFFSET_SHORT_ITEM+1), singleByte &#125;; &#125; &#125; public static byte[] encodeShort(short singleShort) &#123; if (singleShort &lt;= 0xFF) return encodeByte((byte) singleShort); else &#123; return new byte[] &#123; (byte) (OFFSET_SHORT_ITEM + 2), (byte) (singleShort &gt;&gt; 8 &amp; 0xFF), (byte) (singleShort &gt;&gt; 0 &amp; 0xFF) &#125;; &#125; &#125; //把字符串转为字节数组即可 public static byte[] encodeString(String srcString) &#123; return encodeElement(srcString.getBytes()); &#125; //对大整数进行encode，如果是0，直接encode0,如果不是0就转成字节数组 public static byte[] encodeBigInteger(BigInteger srcBigInteger) &#123; if(srcBigInteger == BigInteger.ZERO) return encodeByte((byte)0); else return encodeElement(srcBigInteger.toByteArray()); &#125; //对字节数组进行encode public static byte[] encodeElement(byte[] srcData) &#123; if (srcData == null)&#123; return new byte[] &#123; 0x00 &#125;; //如果小于等于55，那么就只用一个字节来表示长度 &#125; else if (srcData.length &lt;= 0x37) &#123; // length = 8X //长度就是128 + 数据的字节长度，把length放到第一位 byte length = (byte) (OFFSET_SHORT_ITEM + srcData.length); byte[] data = Arrays.copyOf(srcData, srcData.length + 1); System.arraycopy(data, 0, data, 1, srcData.length); data[0] = length; return data; //如果大于55，那么就有两个长度，一个数据的长度，一个长度的长度 &#125; else &#123; // length of length = BX // prefix = [BX, [length]] int tmpLength = srcData.length; byte byteNum = 0; while (tmpLength != 0) &#123; ++byteNum; tmpLength = tmpLength &gt;&gt; 8; &#125; byte[] lenBytes = new byte[byteNum]; for (int i = 0; i &lt; byteNum; ++i) &#123; lenBytes[0] = (byte) ((srcData.length &gt;&gt; (8 * i)) &amp; 0xFF); &#125; // first byte = F7 + bytes.length byte[] data = Arrays.copyOf(srcData, srcData.length + 1 + byteNum); System.arraycopy(data, 0, data, 1 + byteNum, srcData.length); data[0] = (byte) (0xB7 + byteNum); System.arraycopy(lenBytes, 0, data, 1, lenBytes.length); return data; &#125; &#125; //对list进行encode，三个点表示可以接受多个实际参数，实际上相当于接受byte[][] elements public static byte[] encodeList(byte[]... elements) &#123; int totalLength = 0; //把list中的所有元素的长度都加起来 for (int i = 0; i &lt; elements.length; ++i) &#123; totalLength += elements[i].length; &#125; byte[] data; int copyPos = 0; //小于55 if (totalLength &lt;= 0x37) &#123; data = new byte[1 + totalLength]; data[0] = (byte) (OFFSET_SHORT_LIST + totalLength); copyPos = 1; //长度大于55 &#125; else &#123; // length of length = BX // prefix = [BX, [length]] int tmpLength = totalLength; byte byteNum = 0; while (tmpLength != 0) &#123; ++byteNum; tmpLength = tmpLength &gt;&gt; 8; &#125; tmpLength = totalLength; byte[] lenBytes = new byte[byteNum]; for (int i = 0; i &lt; byteNum; ++i) &#123; lenBytes[i] = (byte) ((tmpLength &gt;&gt; (8 * i)) &amp; 0xFF); &#125; // first byte = F7 + bytes.length data = new byte[1 + lenBytes.length + totalLength]; data[0] = (byte) (0xF7 + byteNum); System.arraycopy(lenBytes, 0, data, 1, lenBytes.length); copyPos = lenBytes.length + 1; &#125; //这里写得有问题 for (int i = 0; i &lt; elements.length; ++i) &#123; System.arraycopy(elements[i], 0, data, copyPos, elements[i].length); copyPos += elements[i].length; &#125; return data; &#125; /* * Utility function to convert Objects into byte arrays */ private static byte[] toBytes(Object input) &#123; if (input instanceof byte[]) &#123; return (byte[]) input; &#125; else if (input instanceof String) &#123; String inputString = (String) input; return inputString.getBytes(); &#125; else if(input instanceof Long) &#123; Long inputLong = (Long) input; return (inputLong == 0) ? new byte[0] : BigInteger.valueOf(inputLong).toByteArray(); &#125; else if(input instanceof Integer) &#123; Integer inputInt = (Integer) input; return (inputInt == 0) ? new byte[0] : BigInteger.valueOf(inputInt.longValue()).toByteArray(); &#125; else if(input instanceof BigInteger) &#123; BigInteger inputBigInt = (BigInteger) input; return (inputBigInt == BigInteger.ZERO) ? new byte[0] : inputBigInt.toByteArray(); &#125; else if (input instanceof Value) &#123; Value val = (Value) input; return toBytes(val.asObj()); &#125; throw new RuntimeException(\"Unsupported type: Only accepting String, Integer and BigInteger for now\"); &#125;&#125;","categories":[{"name":"区块链","slug":"区块链","permalink":"http://gunslingeratlarge.github.io/categories/区块链/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://gunslingeratlarge.github.io/tags/区块链/"},{"name":"以太坊","slug":"以太坊","permalink":"http://gunslingeratlarge.github.io/tags/以太坊/"}]},{"title":"leetcode 55.Jump game","slug":"leetcode-55-Jump-game","date":"2018-04-11T01:16:00.000Z","updated":"2018-06-25T10:21:01.906Z","comments":true,"path":"2018/04/11/leetcode-55-Jump-game/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/04/11/leetcode-55-Jump-game/","excerpt":"55. Jump GameDifficulty: Medium Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. For example:A = [2,3,1,1,4], return true. A = [3,2,1,0,4], return false.","text":"55. Jump GameDifficulty: Medium Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. For example:A = [2,3,1,1,4], return true. A = [3,2,1,0,4], return false. Solution123456789101112131415/** * @param &#123;number[]&#125; nums * @return &#123;boolean&#125; */var canJump = function(nums) &#123; var reach = 0; for (var i = 0; i &lt;= reach &amp;&amp; i &lt; nums.length; i++) &#123; reach = Math.max(reach, nums[i] + i); &#125; if (reach &gt;= (nums.length - 1)) &#123; return true; &#125; else &#123; return false; &#125;&#125;; 用reach来表示能够最大走到的边界，如果说最大能够走到的边界比最右的index大，说明可以达到，否则不行。我一开始使用递归做，即递归判断某个位置出发能够走到的结点能不能到达终点，其实也可以，不过最后超时了，如果结合dp来进行递归的话我觉得是可以的，回头有时间再重新做一做。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://gunslingeratlarge.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://gunslingeratlarge.github.io/tags/leetcode/"},{"name":"刷题","slug":"刷题","permalink":"http://gunslingeratlarge.github.io/tags/刷题/"},{"name":"medium","slug":"medium","permalink":"http://gunslingeratlarge.github.io/tags/medium/"}]},{"title":"unicode与utf-8","slug":"unicode与utf-8","date":"2018-04-11T01:06:00.000Z","updated":"2018-06-25T10:21:01.916Z","comments":true,"path":"2018/04/11/unicode与utf-8/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/04/11/unicode与utf-8/","excerpt":"参考 https://blog.csdn.net/bluetjs/article/details/52936943 unicodeunicode只是一个符号集，只是规定了每个符号的二进制表示，而没有规定说应该怎样在计算机内存储。 utf-8是unicode的编码方式，是变长的编码，对于一个字节就可以表示的英文字母，我们就用一个字节，而汉字就用3或者4个字节表示。","text":"参考 https://blog.csdn.net/bluetjs/article/details/52936943 unicodeunicode只是一个符号集，只是规定了每个符号的二进制表示，而没有规定说应该怎样在计算机内存储。 utf-8是unicode的编码方式，是变长的编码，对于一个字节就可以表示的英文字母，我们就用一个字节，而汉字就用3或者4个字节表示。12345String a = \"abc中国ren\"; for(byte b: a.getBytes(\"utf-8\")) &#123; System.out.println(b); &#125; System.out.println(a.getBytes(\"utf-8\").length); 输出为：97 98 99 -28 -72 -83 -27 -101 -67 114 101 110 12即abc中国ren这个字符串在内存中存为12个字节，每个英文字母一个字节，中文三个字节。那它是怎样编码的呢？ UTF-8的编码规则很简单，只有二条：1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。2）对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。 这样就可以将ascii码和汉字的二进制表示分开来了。","categories":[{"name":"其他","slug":"其他","permalink":"http://gunslingeratlarge.github.io/categories/其他/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://gunslingeratlarge.github.io/tags/其他/"}]},{"title":"以太坊源码分析02-rlp part1","slug":"以太坊源码分析02-rlp","date":"2018-04-10T13:16:00.000Z","updated":"2018-06-25T10:21:01.920Z","comments":true,"path":"2018/04/10/以太坊源码分析02-rlp/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/04/10/以太坊源码分析02-rlp/","excerpt":"byte在java中，整数有四种，byte，short，int，long，分别8、16、32、64位，而他们都是以补码形式保存的。补码的规则是：第一位为符号位，为0则正，为1则负，而0表示为0000 0000,1000 0000则表示最小数。原码求补码、补码求原码的规则是按位取反加1（只针对负数，正数不需转换）。补码有一个特点，符号位相同时，就算不看符号位也能比较出大小。如1000 0000与 1111 1111谁大？ 1111 1111大，不看符号位，很显然，看了符号位，知道这两个数都是负数，1000 0000实际上是-128,1111 1111实际上是-1，这也是我们为什么要引入补码的一个原因。所以当我们从int转到byte的时候，由于byte表示的范围只有-128到127，int中大于127的数到了byte中就变为了负数，下面这张图可谓一目了然。","text":"byte在java中，整数有四种，byte，short，int，long，分别8、16、32、64位，而他们都是以补码形式保存的。补码的规则是：第一位为符号位，为0则正，为1则负，而0表示为0000 0000,1000 0000则表示最小数。原码求补码、补码求原码的规则是按位取反加1（只针对负数，正数不需转换）。补码有一个特点，符号位相同时，就算不看符号位也能比较出大小。如1000 0000与 1111 1111谁大？ 1111 1111大，不看符号位，很显然，看了符号位，知道这两个数都是负数，1000 0000实际上是-128,1111 1111实际上是-1，这也是我们为什么要引入补码的一个原因。所以当我们从int转到byte的时候，由于byte表示的范围只有-128到127，int中大于127的数到了byte中就变为了负数，下面这张图可谓一目了然。 encodingrlp有五种情况 数据是单个字节并且是0-127范围内，那么原封不动如15-&gt;[15],127-&gt;[127] 数据是0-55字节，那么128 + 数据的字节长度（最多128 + 55 = 183）作为encoding之后的第一个字节，后面就放数据的字节表示。如”abc”-&gt;[131,97,98,99]，因为abc三字节，字节表示为”97,98,99”，所以128 + 3 = 131，放在第一位 数据大于55字节，那么就从183开始加，但是如果直接加数据的字节长度，就会太大了超过一个字节最大的255，因此就把数据拿过来先计算一个长度，比如说30，表示数据有30个字节，然后再算这个“30”有多长，那肯定一个字节就可以放下，所以就用183 + 1，最后就是[183,30,….]。 对于数组，如果数组总的长度（每个元素都encoding后）在0-55字节，先对数组中每个元素进行encoding，然后把数组所有元素放在一起，把他们的长度加到192上面去。比如[“dog”, “cat”]-&gt; [200, 131, 100, 111, 103, 131, 99,97,116] 如果数组总的长度（每个元素都encoding后）大于55字节，先对数组中每个元素进行encoding，然后把数组所有元素放在一起，总的encoding，算长度，然后把这个长度的长度加到247上面去。[“this is a very long list”, “you never guess how long it is”, “indeed，how did you know it was this long”, “good job, that I can tell you in honestlyyyyy”]-&gt;[248, 144, 152, 116, 104, 105, 115, 32, 105, 115, 32, 97, 32, 118,101, 114, 121, 32, 108, 111, 110, 103, 32, 108, 105, 115, 116, 158,121, 111, 117, 32, 110, 101, 118, 101, 114, 32, 103, 117, 101, 115,115, 32, 104, 111, 119, 32, 108, 111, 110, 103, 32, 105, 116, 32, 105 115, 169, 105, 110, 100, 101, 101, 100, 44, 32, 104, 111, 119, 32, 100,105, 100, 32, 121, 111, 117, 32, 107, 110, 111, 119, 32, 105, 116, 32,119, 97, 115, 32, 116, 104, 105, 115, 32, 108, 111, 110, 103, 173, 103,111, 111, 100, 32, 106, 111, 98, 44, 32, 116, 104, 97, 116, 32, 73, 32 99, 97, 110, 32, 116, 101, 108, 108, 32, 121, 111, 117, 32, 105, 110,32, 104, 111, 110, 101, 115, 116, 108, 121, 121, 121, 121, 121] decoding先看第一个字节，根据第一个字节所处的范围即可判断是哪种情况： 0-127 128-183 184-192 193-247 247-255 单字节 1-55字节 56字节以上 数组1-55字节 数组56字节以上 根据第一个字节的情况就可以判断第二个字节是数据还是长度的长度即可。不再赘述。 参考 http://hidskes.com/blog/2014/04/02/ethereum-building-blocks-part-1-rlp/https://segmentfault.com/a/1190000011763339 &amp;0xffhttp://www.cnblogs.com/think-in-java/p/5527389.html简单来说，&amp;0xff为了从byte-&gt;int保持二进制表示的不变，即1000 0001 -&gt; 0000 0000 1000 0001，而不是保持值的不变，也就是说将byte当成一个无符号数来看待。（java中byte是有符号的，从-127到128）","categories":[{"name":"区块链","slug":"区块链","permalink":"http://gunslingeratlarge.github.io/categories/区块链/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://gunslingeratlarge.github.io/tags/区块链/"},{"name":"以太坊","slug":"以太坊","permalink":"http://gunslingeratlarge.github.io/tags/以太坊/"},{"name":"java","slug":"java","permalink":"http://gunslingeratlarge.github.io/tags/java/"}]},{"title":"以太坊源码分析01-区块","slug":"以太坊源码分析01-区块","date":"2018-04-10T10:00:00.000Z","updated":"2018-06-25T10:21:01.919Z","comments":true,"path":"2018/04/10/以太坊源码分析01-区块/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/04/10/以太坊源码分析01-区块/","excerpt":"config.Initializer这个类是初始化一些东西的，初始化什么不太清楚。里面有三个方法，一个类的constructor，DatabaseVersionHandler，这个是跟升级后数据库的版本有关的可以先不用管。Initializer实现了BeanPostProcessor接口，这个接口来自于Spring，意思是说在实例化某个Bean之后可以通过它对bean进行一系列的操作:","text":"config.Initializer这个类是初始化一些东西的，初始化什么不太清楚。里面有三个方法，一个类的constructor，DatabaseVersionHandler，这个是跟升级后数据库的版本有关的可以先不用管。Initializer实现了BeanPostProcessor接口，这个接口来自于Spring，意思是说在实例化某个Bean之后可以通过它对bean进行一系列的操作: —&gt; Spring IOC容器实例化Bean—&gt; 调用BeanPostProcessor的postProcessBeforeInitialization方法—&gt; 调用bean实例的初始化方法—&gt; 调用BeanPostProcessor的postProcessAfterInitialization方法 我们逐一地来看这里面的三个类，第一个private void initConfig(SystemProperties config),这个是初始化配置的，可以初步理解为初始化区块链配置，然后使用了logger打印了一些信息，注意到这三句：12345678// forcing loading blockchain configconfig.getBlockchainConfig();// forcing loading genesis to fail fast in case of errorconfig.getGenesis();// forcing reading private key or generating it in database directoryconfig.nodeId(); 我们先看这个SystemProperties是什么东西。 Utility class to retrieve property values from the ethereumj.conf files 懂了，从ethereumj.conf中读取配置信息的工具类，ethereumj.conf中包含了许多以太坊的配置信息，我们假装搞懂了然后继续。上面的三句一个是加载区块链的配置，一个是加载创世区块的信息，然后一个是获取节点的私钥？总之这里就是加载。 后面两个就是BeanPostProcessor接口需要overwrite的方法，也就是调用initConfig这个私有方法。没啥。 然后继续看config.getBlockchainConfig()这个方法，这个方法里面首先获得了一个genesis的json表示，实际上就是一个叫做genesisJson的类，里面就是我们genesis.json文件的那些东西，nonce啊，难度啊之类的。它里面有一个属性叫做config，是通过setConfig传入参数来设置的，这个参数就是一个叫做GenesisConfig的类，这个配置文件配置一些什么乱七八糟的东西呢？ 12345678public Integer homesteadBlock;public Integer daoForkBlock;public Integer eip150Block;public Integer eip155Block;public boolean daoForkSupport;public Integer eip158Block;public Integer byzantiumBlock;public Integer chainId; 这里网上找到一段比较好的解释：其中有很多都是针对以太坊历史发生的问题进行的专门配置。ChainId可以预防replay攻击。Homestead是以太坊发展蓝图中的一个阶段。第一阶段是以太坊区块链面世，代号为frontier，第二个阶段即为当前阶段，代号为Homestead（家园），第三阶段为Metropolis（大都会），大都会又细分为两个小阶段，第一个是Byzantium（拜占庭）硬分叉(引入新型零知识证明算法以及pos权益证明共识算法)，第二个是Constantinople（君士坦丁堡）硬分叉（以太坊正式应用pow和pos混合链，解决拜占庭引发的问题）。最后一个阶段代号Serenity（宁静），最终版本的以太坊稳定运行。2017年6月18日，以太坊上DAO（去中心自治组织）的一次大危机做出的相应调整。感兴趣的可以自行谷百。2017年10月16日，以太坊的一次Byzantium拜占庭硬分叉。EIPs(Ethereum Improvement Proposals)，是以太坊更新改善的一些方案，对应后面的数字就是以太坊github源码issue的编号。而一开始没有特别配置的话这些值都应该是null的。所以在getBlockchainConfig中就写到，如果你的genesisJson有特别的配置的话，那么就用你的配置，如果没有的话，就用我的main/ropsten/testnet的配置。 我们来到这个方法的尾部：1234567if (genesisJson.getConfig() != null &amp;&amp; genesisJson.getConfig().headerValidators != null) &#123; for (GenesisConfig.HashValidator validator : genesisJson.getConfig().headerValidators) &#123; BlockHeaderValidator headerValidator = new BlockHeaderValidator(new BlockCustomHashRule(ByteUtil.hexStringToBytes(validator.hash))); blockchainConfig.getConfigForBlock(validator.number).headerValidators().add( Pair.of(validator.number, headerValidator)); &#125; &#125; 如果说genesisJson的config里面有头部验证器那么就验证，如果没有的话就算了。我大概现在是这么理解的。至于怎么验证的先不管它。另外一个方法叫做getGenesis(),返回的类型是Genesis，继承Block，所以就是指的我们的创世块。它是怎么制造创世块的呢？就是通过读取BlockchainConfig和genesisJson这两个类的信息创造出块。123456public Genesis getGenesis() &#123; if (genesis == null) &#123; genesis = GenesisLoader.parseGenesis(getBlockchainConfig(), getGenesisJson()); &#125; return genesis;&#125; WorldManager“ * WorldManager is a singleton containing references to different parts of the system.”我们先把WorldManager理解为一个大总管吧，在这个大总管的构造方法中调用了loadBlockchain()这个方法，搞了一系列复杂的操作，又是写到repository里面又是commit了，反正就是最后把这个我们创建的创世区块从内存中写到了数据库中去了。 Eth62然后我们转到网络，看看以太坊在网络上是怎么和节点间交互的。我们通过查看项目的jar包可以发现它使用了netty作为它的网络通信工具，netty是什么呢我也不知道但是我们简单百度之后发现它就可以简单理解为对java的socket和io的封装，反正就是处理socket的东西。然后我们发现Eth62里面有一个方法叫channelRead0卧槽这个是什么东西？我们随手百度一下发现这个是netty里的东西！原来Eth62继承了netty的SimpleChannelInboundHandler，这个类可以通过加入泛型使得我们拦截特定类型的对象来进行处理,这里就是拦截的EthMasseage，就是以太坊自己定义的消息类型了。所以我们就可以大概地理解为channelRead0是一个拦截/读取消息的方法，可以使得我们的节点处理特定的消息，有些什么消息呢？12345678910111213141516171819202122232425262728switch (msg.getCommand()) &#123; case STATUS: processStatus((StatusMessage) msg, ctx); break; case NEW_BLOCK_HASHES: processNewBlockHashes((NewBlockHashesMessage) msg); break; case TRANSACTIONS: processTransactions((TransactionsMessage) msg); break; case GET_BLOCK_HEADERS: processGetBlockHeaders((GetBlockHeadersMessage) msg); break; case BLOCK_HEADERS: processBlockHeaders((BlockHeadersMessage) msg); break; case GET_BLOCK_BODIES: processGetBlockBodies((GetBlockBodiesMessage) msg); break; case BLOCK_BODIES: processBlockBodies((BlockBodiesMessage) msg); break; case NEW_BLOCK: processNewBlock((NewBlockMessage) msg); break; default: break; &#125; 这些消息都是定义为的十六进制的数字其实，当收到这些消息之后我们这个节点就进行相应的操作了。具体有什么操作现在先不管。 现在我们看到SyncManager，这个类里面有这样一个类叫做ExecutorPipeline，这个是一个工具类，应该算是一个比较容易理解的了吧？看它的注释是说将待执行的任务排列到一个队列当中使得这些任务可以parallel地执行但是又保留他们的先后顺序。大概是这个意思我也没太看明白。Queues execution tasks into a single pipeline where some tasks can be executed in parallel but preserve ‘messages’ order so the next task process messages on a single thread in the same order they were added to the previous executor.在这个SyncManager里面似乎是有一个Sync队列的，新的块要加进来是会先到这个队列里面去排队，等待被加入到链上。就通过它的validateAndAddNewBlock方法。 这个SyncManager是继承了BlockDownloader，这个类就是一个块的下载器，它的init方法就会去起两个线程，然后这两个线程分别去下载区块头和区块体。这里面涉及到java异步编程的内容，我们可以学习了java异步编程的内容后再来深入地看这部分。","categories":[{"name":"区块链","slug":"区块链","permalink":"http://gunslingeratlarge.github.io/categories/区块链/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://gunslingeratlarge.github.io/tags/区块链/"},{"name":"以太坊","slug":"以太坊","permalink":"http://gunslingeratlarge.github.io/tags/以太坊/"},{"name":"java","slug":"java","permalink":"http://gunslingeratlarge.github.io/tags/java/"}]},{"title":"leetcode 781. Rabbits in Forest","slug":"leetcode-781-Rabbits-in-Forest","date":"2018-04-10T04:31:00.000Z","updated":"2018-06-25T10:21:01.908Z","comments":true,"path":"2018/04/10/leetcode-781-Rabbits-in-Forest/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/04/10/leetcode-781-Rabbits-in-Forest/","excerpt":"781. Rabbits in ForestDifficulty: Medium In a forest, each rabbit has some color. Some subset of rabbits (possibly all of them) tell you how many other rabbits have the same color as them. Those answers are placed in an array. Return the minimum number of rabbits that could be in the forest.","text":"781. Rabbits in ForestDifficulty: Medium In a forest, each rabbit has some color. Some subset of rabbits (possibly all of them) tell you how many other rabbits have the same color as them. Those answers are placed in an array. Return the minimum number of rabbits that could be in the forest.123456789101112131415**Examples:****Input:** answers = [1, 1, 2]**Output:** 5**Explanation:**The two rabbits that answered &quot;1&quot; could both be the same color, say red.The rabbit than answered &quot;2&quot; can&apos;t be red or the answers would be inconsistent.Say the rabbit that answered &quot;2&quot; was blue.Then there should be 2 other blue rabbits in the forest that didn&apos;t answer into the array.The smallest possible number of rabbits in the forest is therefore 5: 3 that answered plus 2 that didn&apos;t.**Input:** answers = [10, 10, 10]**Output:** 11**Input:** answers = []**Output:** 0 Note: answers will have length at most 1000. Each answers[i] will be an integer in the range [0, 999]. Solution123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123; public int numRabbits(int[] answers) &#123; Arrays.sort(answers); int capacity = 0; int res = 0; int count = 0; for (int i = 0; i &lt; answers.length;i++) &#123; //对开头单独处理 if (i == 0) &#123; capacity = answers[i] + 1; count = 1; if (capacity == 1) &#123; count = 0; res += capacity; &#125; &#125; else &#123; //如果后一个跟前一个相同 if (answers[i - 1] == answers[i]) &#123; count++; if (count == capacity) &#123; res += capacity; count = 0; &#125; if (count != 0 &amp;&amp; i == (answers.length - 1)) &#123; res += capacity; &#125; //如果后一个跟前一个不同 &#125; else &#123; //如果前一个回答还有兔子 if (count != 0) &#123; res += capacity; count = 0; &#125; capacity = answers[i] + 1; //如果是最后一个回答 if (i == answers.length - 1) &#123; res += capacity; &#125; count++; &#125; &#125; &#125; return res; &#125;&#125; 思路：将兔子们的回答排序，然后遍历数组，设置一个capacity来表示这个回答能够装下多少只同样颜色的兔子，比如回答为2，那么就至少有3只同样颜色的兔子，如果说回答是2的兔子超过了3（count &gt; 3），那么就要另外加上一个capacity了。此外，对于末尾的兔子和分界处的兔子也要额外考虑。要想清楚再写代码，不要没想清楚就开始写，实际上写出来的代码一团糟。","categories":[{"name":"刷题","slug":"刷题","permalink":"http://gunslingeratlarge.github.io/categories/刷题/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://gunslingeratlarge.github.io/tags/leetcode/"},{"name":"刷题","slug":"刷题","permalink":"http://gunslingeratlarge.github.io/tags/刷题/"},{"name":"medium","slug":"medium","permalink":"http://gunslingeratlarge.github.io/tags/medium/"}]},{"title":"建立私链并部署合约","slug":"建立私链并部署合约","date":"2018-04-08T12:07:00.000Z","updated":"2018-06-25T10:21:01.924Z","comments":true,"path":"2018/04/08/建立私链并部署合约/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/04/08/建立私链并部署合约/","excerpt":"安装trufflenpm install -g truffle 安装测试链npm install -g ganache-cli 初始化truffletruffle init 将智能合约加到contracts中，并将deploy的js脚本加到migrations中 配置truffle注意windows下要删去truffle.js。将后面的配置信息拷贝到truffle-config.js 编译合约truffle compile 部署合约truffle migrate —network development—network 后面就跟上网络名（配置在truffle-config.js中） 下载geth注意版本差异 初始化创世区块geth —datadir .\\chaindata init .\\genesis.json 开启私链geth —datadir .\\chaindata\\ —rpc 新建账户eth.accountspersonal.newAccount 开始挖矿miner.start() truffle migrate —network ourTestNet这次部署到geth的私链上","text":"安装trufflenpm install -g truffle 安装测试链npm install -g ganache-cli 初始化truffletruffle init 将智能合约加到contracts中，并将deploy的js脚本加到migrations中 配置truffle注意windows下要删去truffle.js。将后面的配置信息拷贝到truffle-config.js 编译合约truffle compile 部署合约truffle migrate —network development—network 后面就跟上网络名（配置在truffle-config.js中） 下载geth注意版本差异 初始化创世区块geth —datadir .\\chaindata init .\\genesis.json 开启私链geth —datadir .\\chaindata\\ —rpc 新建账户eth.accountspersonal.newAccount 开始挖矿miner.start() truffle migrate —network ourTestNet这次部署到geth的私链上 geth —datadir ./chaindata —rpcgeth attach \\.\\pipe\\geth.ipc“Ethereum Wallet” -rpc http://127.0.0.1:8545 智能合约123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103pragma solidity ^0.4.18; /** * Example script for the Ethereum development walkthrough */contract Wrestling &#123; /** * Our wrestlers */ address public wrestler1; address public wrestler2; bool public wrestler1Played; bool public wrestler2Played; uint private wrestler1Deposit; uint private wrestler2Deposit; bool public gameFinished; address public theWinner; uint gains; /** * The logs that will be emitted in every step of the contract&apos;s life cycle */ event WrestlingStartsEvent(address wrestler1, address wrestler2); event EndOfRoundEvent(uint wrestler1Deposit, uint wrestler2Deposit); event EndOfWrestlingEvent(address winner, uint gains); /** * The contract constructor */ function Wrestling() public &#123; wrestler1 = msg.sender; &#125; /** * A second wrestler can register as an opponent */ function registerAsAnOpponent() public &#123; require(wrestler2 == address(0)); wrestler2 = msg.sender; WrestlingStartsEvent(wrestler1, wrestler2); &#125; /** * Every round a player can put a sum of ether, if one of the player put in twice or * more the money (in total) than the other did, the first wins */ function wrestle() public payable &#123; require(!gameFinished &amp;&amp; (msg.sender == wrestler1 || msg.sender == wrestler2)); if(msg.sender == wrestler1) &#123; require(wrestler1Played == false); wrestler1Played = true; wrestler1Deposit = wrestler1Deposit + msg.value; &#125; else &#123; require(wrestler2Played == false); wrestler2Played = true; wrestler2Deposit = wrestler2Deposit + msg.value; &#125; if(wrestler1Played &amp;&amp; wrestler2Played) &#123; if(wrestler1Deposit &gt;= wrestler2Deposit * 2) &#123; endOfGame(wrestler1); &#125; else if (wrestler2Deposit &gt;= wrestler1Deposit * 2) &#123; endOfGame(wrestler2); &#125; else &#123; endOfRound(); &#125; &#125; &#125; function endOfRound() internal &#123; wrestler1Played = false; wrestler2Played = false; EndOfRoundEvent(wrestler1Deposit, wrestler2Deposit); &#125; function endOfGame(address winner) internal &#123; gameFinished = true; theWinner = winner; gains = wrestler1Deposit + wrestler2Deposit; EndOfWrestlingEvent(winner, gains); &#125; /** * The withdraw function, following the withdraw pattern shown and explained here: * http://solidity.readthedocs.io/en/develop/common-patterns.html#withdrawal-from-contracts */ function withdraw() public &#123; require(gameFinished &amp;&amp; theWinner == msg.sender); uint amount = gains; gains = 0; msg.sender.transfer(amount); &#125;&#125; 部署的js脚本123456const Wrestling = artifacts.require(\"./Wrestling.sol\")module.exports = function(deployer) &#123; deployer.deploy(Wrestling);&#125;; 配置truffle，注意windows下要删去truffle.js12345678910111213141516module.exports = &#123; // See &lt;http://truffleframework.com/docs/advanced/configuration&gt; // for more about customizing your Truffle configuration! networks: &#123; development: &#123; host: \"127.0.0.1\", port: 7545, network_id: \"*\" &#125;, ourTestNet: &#123; host: \"127.0.0.1\", port: 8545, network_id: \"*\" &#125; &#125;&#125;; 创世区块12345678910111213&#123; \"difficulty\" : \"0x20000\", \"extraData\" : \"\", \"gasLimit\" : \"0x8000000\", \"alloc\": &#123;&#125;, \"config\": &#123; \"chainId\": 15, \"homesteadBlock\": 0, \"eip155Block\": 0, \"eip158Block\": 0 &#125;&#125;","categories":[{"name":"区块链","slug":"区块链","permalink":"http://gunslingeratlarge.github.io/categories/区块链/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://gunslingeratlarge.github.io/tags/区块链/"},{"name":"以太坊","slug":"以太坊","permalink":"http://gunslingeratlarge.github.io/tags/以太坊/"}]},{"title":"Problem:Not enough memory to mine ether","slug":"Not-enough-memory-to-mine-ether","date":"2018-04-08T12:03:00.000Z","updated":"2018-06-25T10:21:01.896Z","comments":true,"path":"2018/04/08/Not-enough-memory-to-mine-ether/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/04/08/Not-enough-memory-to-mine-ether/","excerpt":"","text":"https://github.com/ethereum/go-ethereum/issues/14786 ERROR[07-10|15:56:35] Failed to generate mapped ethash dataset epoch=1 err=”cannot allocate memory”runtime: out of memory: cannot allocate 2164260864-byte block (128057344 in use)fatal error: out of memory 实际上是使用了错误的geth版本导致的（64位使用了32位） geth version,如果architecture是386的话说明是32位的。跟内存没什么关系。","categories":[{"name":"区块链","slug":"区块链","permalink":"http://gunslingeratlarge.github.io/categories/区块链/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://gunslingeratlarge.github.io/tags/区块链/"},{"name":"以太坊","slug":"以太坊","permalink":"http://gunslingeratlarge.github.io/tags/以太坊/"}]},{"title":"区块链资料","slug":"区块链资料","date":"2018-04-08T06:16:00.000Z","updated":"2018-06-25T10:21:01.921Z","comments":true,"path":"2018/04/08/区块链资料/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/04/08/区块链资料/","excerpt":"","text":"以太坊以太坊架构https://blog.zeppelin.solutions/designing-the-architecture-for-your-ethereum-application-9cec086f8317以太坊开发walkthroughhttps://hackernoon.com/ethereum-development-walkthrough-part-1-smart-contracts-b3979e6e573e以太坊源码解析（java）https://www.jianshu.com/nb/23229920如何更新以太坊上的合约https://ethereum.stackexchange.com/questions/11938/how-to-update-a-deployed-smart-contract 区块链区块链实例https://github.com/openblockchains/awesome-blockchains学习路线https://medium.freecodecamp.org/the-authoritative-guide-to-blockchain-development-855ab65b58bc区块链平台介绍https://medium.com/blockchain-blog/17-blockchain-platforms-a-brief-introduction-e07273185a0b区块链架构https://blog.bigchaindb.com/blockchain-infrastructure-landscape-a-first-principles-framing-92cc5549bafe 动手实践用java写一个区块链https://medium.com/programmers-blockchain/create-simple-blockchain-java-tutorial-from-scratch-6eeed3cb03fa 版权保护数据存储https://ethereum.stackexchange.com/questions/11987/how-does-data-storage-on-the-blockchain-work/12002","categories":[{"name":"区块链","slug":"区块链","permalink":"http://gunslingeratlarge.github.io/categories/区块链/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://gunslingeratlarge.github.io/tags/区块链/"},{"name":"以太坊","slug":"以太坊","permalink":"http://gunslingeratlarge.github.io/tags/以太坊/"}]},{"title":"leetcode 672. Bulb Switcher II","slug":"672-Bulb-Switcher-II","date":"2018-04-08T01:01:00.000Z","updated":"2018-06-25T10:21:01.888Z","comments":true,"path":"2018/04/08/672-Bulb-Switcher-II/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/04/08/672-Bulb-Switcher-II/","excerpt":"672. Bulb Switcher IIDifficulty: Medium There is a room with n lights which are turned on initially and 4 buttons on the wall. After performing exactly m unknown operations towards buttons, you need to return how many different kinds of status of the n lights could be.","text":"672. Bulb Switcher IIDifficulty: Medium There is a room with n lights which are turned on initially and 4 buttons on the wall. After performing exactly m unknown operations towards buttons, you need to return how many different kinds of status of the n lights could be.Suppose n lights are labeled as number [1, 2, 3 …, n], function of these 4 buttons are given below: Flip all the lights. Flip lights with even numbers. Flip lights with odd numbers. Flip lights with (3k + 1) numbers, k = 0, 1, 2, … Example 1: 123Input: n = 1, m = 1.Output: 2Explanation: Status can be: [on], [off] Example 2: 123Input: n = 2, m = 1.Output: 3Explanation: Status can be: [on, off], [off, on], [off, off] Example 3: 123Input: n = 3, m = 1.Output: 4Explanation: Status can be: [off, on, off], [on, off, on], [off, off, off], [off, on, on]. Note: n and m both fit in range [0, 1000]. Solution1234567891011121314151617181920212223/** * @param &#123;number&#125; n * @param &#123;number&#125; m * @return &#123;number&#125; */var flipLights = function(n, m) &#123; if (m == 0 || n == 0) &#123; return 1; &#125; if(n == 1) &#123; return 2; &#125; if ( n ==2 )&#123; return m == 1?3:4; &#125; if (m == 1)&#123; return 4; &#125; if (m == 2) &#123; return 7; &#125; return 8;&#125;; 分析：这道题有点像寻找规律的问题，只要知道前三个灯泡的状态就可以推出所有灯泡的状态了。总共有八种状态：全开，1,2,3,4，1+4,2+4,3+4（因为1+2 = 3，,2+ 3 = 1， 1+3 = 2） 操作数\\灯泡数 0 1 2 3 4 5 .. 0 1 1 1 1 1 1 1 1 1 2 3 4 4 4 4 2 1 2 4 7 7 7 7 3 1 2 4 8 8 8 8 3 1 2 4 8 8 8 8","categories":[{"name":"刷题","slug":"刷题","permalink":"http://gunslingeratlarge.github.io/categories/刷题/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://gunslingeratlarge.github.io/tags/leetcode/"},{"name":"刷题","slug":"刷题","permalink":"http://gunslingeratlarge.github.io/tags/刷题/"},{"name":"medium","slug":"medium","permalink":"http://gunslingeratlarge.github.io/tags/medium/"}]},{"title":"leetcode 565. Array Nesting","slug":"leetcode-565-Array-Nesting","date":"2018-04-07T12:40:00.000Z","updated":"2018-06-25T10:21:01.906Z","comments":true,"path":"2018/04/07/leetcode-565-Array-Nesting/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/04/07/leetcode-565-Array-Nesting/","excerpt":"565. Array NestingDifficulty: Medium A zero-indexed array A of length N contains all integers from 0 to N-1. Find and return the longest length of set S, where S[i] = {A[i], A[A[i]], A[A[A[i]]], … } subjected to the rule below. Suppose the first element in S starts with the selection of element A[i] of index = i, the next element in S should be A[A[i]], and then A[A[A[i]]]… By that analogy, we stop adding right before a duplicate element occurs in S.","text":"565. Array NestingDifficulty: Medium A zero-indexed array A of length N contains all integers from 0 to N-1. Find and return the longest length of set S, where S[i] = {A[i], A[A[i]], A[A[A[i]]], … } subjected to the rule below. Suppose the first element in S starts with the selection of element A[i] of index = i, the next element in S should be A[A[i]], and then A[A[A[i]]]… By that analogy, we stop adding right before a duplicate element occurs in S.Example 1: 1234567Input: A = [5,4,0,3,1,6,2]Output: 4Explanation: A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.One of the longest S[K]:S[0] = &#123;A[0], A[5], A[6], A[2]&#125; = &#123;5, 6, 2, 0&#125; Note: N is an integer within the range [1, 20,000]. The elements of A are all distinct. Each element of A is an integer within the range [0, N-1]. Solution12345678910111213141516171819202122232425/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var arrayNesting = function(nums) &#123; var res = 0; for (var i = 0; i &lt; nums.length; i++) &#123; var count = 0; var start = i; while (nums[start] &gt;= 0) &#123; count++; var temp = nums[start]; if (nums[start]!= 0) &#123; nums[start] = -nums[start]; &#125;else &#123; nums[start] = -999999; &#125; start = temp; &#125; res = Math.max(res,count); &#125; return res;&#125;; 思路：如果一个数组里的元素跟下标关系密切，比如n个元素，数组元素为0到n-1这种，就可以用这种方法来确定哪个元素被访问过了，不用使用多余的空间。这道题还有一个地方就是要注意，置为负数的时候要注意对0的处理。此外，对于这种循环形式的一组数，其实从循环的任何一个位置开始都可以访问得到所有的元素的，有一点像循环群，不是吗？","categories":[{"name":"刷题","slug":"刷题","permalink":"http://gunslingeratlarge.github.io/categories/刷题/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://gunslingeratlarge.github.io/tags/leetcode/"},{"name":"刷题","slug":"刷题","permalink":"http://gunslingeratlarge.github.io/tags/刷题/"},{"name":"medium","slug":"medium","permalink":"http://gunslingeratlarge.github.io/tags/medium/"}]},{"title":"扩展欧几里得算法求逆元","slug":"扩展欧几里得算法求逆元","date":"2018-04-07T10:49:00.000Z","updated":"2018-06-25T10:21:01.926Z","comments":true,"path":"2018/04/07/扩展欧几里得算法求逆元/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/04/07/扩展欧几里得算法求逆元/","excerpt":"","text":"直接上例子。求：1 = 17*x(mod43)即求17mod43的逆元43 = 17 × 2 + 9 ①17 = 9 × 1 + 8 ②9 = 8 × 1 + 1 ③直到余数为1令1到左边，则有1 = 9 - 8代入上面的8 = 17 - 9 ②1 = 9 - 17 + 91 = 2 × 9 - 17代入①1 = 2 ×(43 - 17 × 2) - 171 = 2 × 43 - 5 × 1743是模，所以直接约去， 1 = -5 × 17(mod43)所以17的逆是-5，也就是38对于多项式的扩展欧几里得同样，只是在求余的时候比较麻烦一点了。","categories":[{"name":"数学","slug":"数学","permalink":"http://gunslingeratlarge.github.io/categories/数学/"},{"name":"抽象代数","slug":"数学/抽象代数","permalink":"http://gunslingeratlarge.github.io/categories/数学/抽象代数/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://gunslingeratlarge.github.io/tags/数学/"},{"name":"抽象代数","slug":"抽象代数","permalink":"http://gunslingeratlarge.github.io/tags/抽象代数/"}]},{"title":"leetcode 648 replace words","slug":"leetcode-648-replace-words","date":"2018-04-05T02:02:00.000Z","updated":"2018-06-25T10:21:01.907Z","comments":true,"path":"2018/04/05/leetcode-648-replace-words/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/04/05/leetcode-648-replace-words/","excerpt":"648. Replace WordsDifficulty: Medium In English, we have a concept called root, which can be followed by some other words to form another longer word - let’s call this word successor. For example, the root an, followed by other, which can form another word another. Now, given a dictionary consisting of many roots and a sentence. You need to replace all the successor in the sentence with the root forming it. If a successor has many roots can form it, replace it with the root with the shortest length. You need to output the sentence after the replacement.","text":"648. Replace WordsDifficulty: Medium In English, we have a concept called root, which can be followed by some other words to form another longer word - let’s call this word successor. For example, the root an, followed by other, which can form another word another. Now, given a dictionary consisting of many roots and a sentence. You need to replace all the successor in the sentence with the root forming it. If a successor has many roots can form it, replace it with the root with the shortest length. You need to output the sentence after the replacement.Example 1: 123**Input:** dict = [&quot;cat&quot;, &quot;bat&quot;, &quot;rat&quot;]sentence = &quot;the cattle was rattled by the battery&quot;**Output:** &quot;the cat was rat by the bat&quot; Note: The input will only have lower-case letters. 1 &lt;= dict words number &lt;= 1000 1 &lt;= sentence words number &lt;= 1000 1 &lt;= root length &lt;= 100 1 &lt;= sentence words length &lt;= 1000 Solution123456class Solution &#123; public String replaceWords(List&lt;String&gt; dict, String sentence) &#123; System.out.println(&quot;\\\\b(&quot; + String.join(&quot;|&quot;,dict)+&quot;)*?\\\\b&quot;); return sentence.replaceAll(&quot;\\\\b(&quot; + String.join(&quot;|&quot;,dict)+&quot;)&#123;1&#125;.*?\\\\b&quot;,&quot;$1&quot;); &#125;&#125; 思路：使用正则或者使用tier tree，tier tree还不会，这里复习一下正则：* ? + 是量词，是用来修饰一个东西的，注意*不是通配符里的表示任意多个字符，不要搞混了，表示任意一个字符用.,字母用\\w。常用.*?来表示任意字符的非贪婪匹配。","categories":[{"name":"刷题","slug":"刷题","permalink":"http://gunslingeratlarge.github.io/categories/刷题/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://gunslingeratlarge.github.io/tags/leetcode/"},{"name":"刷题","slug":"刷题","permalink":"http://gunslingeratlarge.github.io/tags/刷题/"},{"name":"medium","slug":"medium","permalink":"http://gunslingeratlarge.github.io/tags/medium/"}]},{"title":"leetcode 448. Find All Numbers Disappeared in an Array","slug":"Find All Numbers Disappeared in an Array","date":"2018-04-05T01:18:00.000Z","updated":"2018-06-25T10:21:01.891Z","comments":true,"path":"2018/04/05/Find All Numbers Disappeared in an Array/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/04/05/Find All Numbers Disappeared in an Array/","excerpt":"448. Find All Numbers Disappeared in an ArrayDifficulty: Easy Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements of [1, n] inclusive that do not appear in this array. Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.","text":"448. Find All Numbers Disappeared in an ArrayDifficulty: Easy Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements of [1, n] inclusive that do not appear in this array. Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.Example: 12345**Input:**[4,3,2,7,8,2,3,1]**Output:**[5,6] Solution1234567891011121314151617181920/** * @param &#123;number[]&#125; nums * @return &#123;number[]&#125; */var findDisappearedNumbers = function(nums) &#123; for (var i = 0; i &lt; nums.length; i++) &#123; var value = nums[i]; var pos = Math.abs(value) - 1; nums[pos] = -Math.abs(nums[pos]); &#125; var ans = []; for (var i = 0; i &lt; nums.length; i++) &#123; if (nums[i] &gt; 0) &#123; ans.push(i + 1); &#125; else &#123; nums[i] = -nums[i]; &#125; &#125; return ans;&#125; 思路：利用下标与内容的对应关系，将数组内的某个元素-1之后对应的元素置为负数，最后看哪几个位置的元素不为负数即可。另外，js的数组添加元素是push(),绝对值是Math.abs()","categories":[{"name":"刷题","slug":"刷题","permalink":"http://gunslingeratlarge.github.io/categories/刷题/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://gunslingeratlarge.github.io/tags/leetcode/"},{"name":"刷题","slug":"刷题","permalink":"http://gunslingeratlarge.github.io/tags/刷题/"},{"name":"easy","slug":"easy","permalink":"http://gunslingeratlarge.github.io/tags/easy/"}]},{"title":"java网络编程","slug":"java网络编程","date":"2018-04-04T11:42:00.000Z","updated":"2018-06-25T10:21:01.902Z","comments":true,"path":"2018/04/04/java网络编程/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/04/04/java网络编程/","excerpt":"网络编程三要素ip地址InetAddress功能子类 Inet4Address Inet6Address类中有静态方法返回该类的对象成员方法：getByName(String host) 根据主机名或者ip地址字符得到ip地址对象address.getHostName()address.getHostAddress()","text":"网络编程三要素ip地址InetAddress功能子类 Inet4Address Inet6Address类中有静态方法返回该类的对象成员方法：getByName(String host) 根据主机名或者ip地址字符得到ip地址对象address.getHostName()address.getHostAddress() 端口标识进程。有效端口0-65535 0-1024系统使用或保留 协议过程socket创建发送端socket对象创建数据，并把数据打包调用socket对象的发送方法发送数据包释放资源 UDPDatagramSocket(发送和接受都是同一个)，内容包是DatagramPacket 发送创建发送端Socket对象123DatagramSocket ds = new DatagramSocket();``` 调用socket对象的发送方法发送数据包 DatagramPacket(byte[] buf, int length, InetAddress address, int port)1创建数据并把数据打包 ds.send(ds);123释放资源 ``` ds.close(); 接受创建发送端socket对象创建接收端datagrampacket作为接受容器调用socket对象的接收方法接收数据解析数据包 并显示在控制台释放资源 实现简易聊天基于udp，java的net包和io包实现。采用两个线程处理聊天过程，一个线程负责接收信息，另一个线程负责发送信息。 Chatroom类 主要的类，管理ip、port和两个线程的启动 1234567891011121314151617181920212223242526272829303132package cn.kvmial.chatroom;import java.util.Scanner;public class Chatroom &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(\"请输入目标ip(10.131.4.20):\"); String ip = \"10.131.4.20\"; String inputip = sc.nextLine(); if (inputip.equals(\"\")) &#123; System.out.println(\"使用默认值10.131.4.20\"); &#125; else &#123; ip = inputip; &#125; System.out.println(\"请输入目标ip(25535):\"); int port = 25535; String nextint = sc.nextLine(); if (!nextint.equals(\"\")) &#123; port = Integer.parseInt(nextint); &#125; Thread r = new Thread(new ReceiveThread(port)); Thread s = new Thread(new SendThread(ip,port)); r.start(); s.start(); &#125;&#125; SendThread类 发送消息的线程，读取键盘输入并发送 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package cn.kvmial.chatroom;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;import java.net.SocketException;public class SendThread implements Runnable&#123; private String ip; private int port; public SendThread(String ip, int port) &#123; this.ip = ip; this.port = port; &#125; @Override public void run() &#123; System.out.println(\"Initializing...\"); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e1) &#123; // TODO Auto-generated catch block e1.printStackTrace(); &#125; System.out.println(\"Initialized.\"); DatagramSocket ds = null; try &#123; ds = new DatagramSocket(); &#125; catch (SocketException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line = null; try &#123; while((line = br.readLine())!= null) &#123; byte[] bys = new String(line).getBytes(); DatagramPacket dp = new DatagramPacket(bys,bys.length, InetAddress.getByName(ip), port); ds.send(dp); if(\"!exit\".equals(line)) &#123; break; &#125; &#125; &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; ds.close(); &#125;&#125; ReceiveThread接收消息的线程 12345678910111213141516171819202122232425262728293031323334353637package cn.kvmial.chatroom;import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.SocketException;public class ReceiveThread implements Runnable &#123; private int port; public ReceiveThread(int port) &#123; this.port = port; &#125; @Override public void run() &#123; DatagramSocket ds = null; try &#123; ds = new DatagramSocket(port); &#125; catch (SocketException e) &#123; e.printStackTrace(); &#125; while(true) &#123; byte[] bys = new byte[1024]; DatagramPacket dp = new DatagramPacket(bys,1024); try &#123; ds.receive(dp); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; String message =new String(dp.getData(),0,dp.getLength()); if(message.equals(\"!exit\")) &#123; break; &#125; System.out.println(message); &#125; ds.close(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://gunslingeratlarge.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://gunslingeratlarge.github.io/tags/Java/"},{"name":"区块链","slug":"区块链","permalink":"http://gunslingeratlarge.github.io/tags/区块链/"}]},{"title":"KMP","slug":"Untitled","date":"2018-04-04T05:42:00.000Z","updated":"2018-06-25T10:21:01.898Z","comments":true,"path":"2018/04/04/Untitled/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/04/04/Untitled/","excerpt":"https://www.youtube.com/watch?v=GTJr8OvyEVQ 介绍目标串：abcxabcdabxabcdabcdabcy模式串：abcdabcy想要找到模式串是否是目标串的子串，如果是，在目标串的index是多少","text":"https://www.youtube.com/watch?v=GTJr8OvyEVQ 介绍目标串：abcxabcdabxabcdabcdabcy模式串：abcdabcy想要找到模式串是否是目标串的子串，如果是，在目标串的index是多少 思路 既是前缀又是后缀：如abcab，这里的ab就既是前缀又是后缀 按照暴力求解的办法从头开始比较。比较到不匹配的位置时，观察模式串不匹配位置之前是否有即是前缀又是后缀的一个子串比如：从头开始，abc都匹配，目标的x和模式的d不匹配 ，则观察模式串的d之前的子串abc是否有即是前缀又是后缀的一部分。没有既是前缀又是后缀，所以从不匹配位置再从头开始，即模式串的开头a与目标串的x开始比较。即abcxabcdabxabcdabcdabcy与abcdabcy比较。可以一直匹配到abcxabcdabxabcdabcdabcy，abcdabcy，此时x与c比较不匹配。我们就看abcdab这个已经匹配了的子串，它是否有既是前缀又是后缀的一部分。有的，对吗？ab既是它的前缀，又是它的后缀。现在我们看这两个字符串：abcxabcdabxabcdabcdabcyabcdabcy注意到由于加粗的部分是互相匹配的，因此斜体的两部分肯定是匹配的，对吧。又由于加粗的部分中ab既是后缀又是前缀，也就是说模式串的前两个ab和目标串的斜体ab肯定是匹配的，因此我们就可以不再从目标串的x与模式串的第一个a开始比较了，而是比较x与模式串的第三个字母c，但是x与c不匹配，所以又匹配目标串x之后的a和模式串的开头a。最后比较到这里，目标串：abcxabcdabxabcdabcdabcy模式串：abcdabcyd与y不匹配，但是abcdabc满足abc既是前缀又是后缀，因此从模式串的index = 3的d开始与目标串的下一个d进行比较，一直到结束。这就是kmp的一个思路。 求模式串的next数组next数组就是表示pattern串中既是前缀又是后缀的字符位数的：如abcdabcy这个模式串它的next数组为0 0 0 0 1 2 3 0 应该怎么求呢？说再多不如看视频https://www.youtube.com/watch?v=KG44VoDtsAA 为什么要这样求呢？关键点在于，如果i和j所指的字符不同，为什么要将j移到其前一位的next数组值的位置。一图胜千言： 应用next数组 代码实现待续","categories":[{"name":"算法","slug":"算法","permalink":"http://gunslingeratlarge.github.io/categories/算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://gunslingeratlarge.github.io/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"http://gunslingeratlarge.github.io/tags/算法/"}]},{"title":"Intro to NN","slug":"IntroTONN","date":"2018-04-03T23:18:00.000Z","updated":"2018-06-25T10:21:01.891Z","comments":true,"path":"2018/04/04/IntroTONN/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/04/04/IntroTONN/","excerpt":"https://www.youtube.com/watch?v=LSr96IZQkncnotebook下载 配置环境 官网下载conda 安装时选择添加path conda create -n nnseries activate nnseries conda install numpy conda install jupyter jupyter notebook","text":"https://www.youtube.com/watch?v=LSr96IZQkncnotebook下载 配置环境 官网下载conda 安装时选择添加path conda create -n nnseries activate nnseries conda install numpy conda install jupyter jupyter notebook — 引入 第一个神经网络由三个节点组成，两个引入节点，一个输出节点 对应的python代码是：(此处略) 我们一开始参数（w1，w2，b）是随机的，因此预测效果不理想，由此引入cost function — cost function 平方误差函数 对预测值与实际目标值的差取平方，估算代价的一种方法 假设NN() = b，目标值为4，则cost = (b - 4)^2 为了最小化cost，我们每次减去cost在该点的斜率值 — 最简单神经网络 加载数据 将数据存在list中 使用data.append添加单条数据 使用data + [[1,2,3],[4,5,6]]添加多条数据 绘制数据 画散点图： plt.scatter([data[i][0]], [data[i][1]], c=c,alpha = .2) plt.grid()可以绘制对应每个坐标值的网格 alpha可以指定透明度 如果没有特殊指定，都是在一张图上绘制的（在一个cell中的命令） 画sigmoid函数： X = np.linspace(-5, 5, 100) 这里是取100个点，即均分为99段 plt.plot(X, sigmoid(X), c=”b”) # sigmoid in blue 注意这里sigmoid传入的是一个ndarray，这是numpy所独有的一种数据类型 只有ndarray可以对它进行加减乘除相当于是对它的每一位都操作 list是不可以的，会报错 进行训练 生成随机数 使用np.random.randn()生成在1附近的，标准正态分布随机数 生成w1，w2，b 计算预测值 进行梯度下降 计算cost = （pred - target ）** 2 计算梯度 根据梯度更新w1，w2，b的值 跟踪cost的值 这里要注意，每次都是用随机取点来训练的，因此如果只跟踪每个点的cost的话不能很好的反映整体的情况，因此每隔一段时间都要随机对所有的点计算cost并取平均，跟踪这个值","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://gunslingeratlarge.github.io/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://gunslingeratlarge.github.io/tags/机器学习/"},{"name":"神经网络","slug":"神经网络","permalink":"http://gunslingeratlarge.github.io/tags/神经网络/"}]},{"title":"leetcode 717. 1-bit and 2-bit Characters","slug":"leetcode","date":"2018-04-03T11:04:00.000Z","updated":"2018-06-25T10:21:01.910Z","comments":true,"path":"2018/04/03/leetcode/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/04/03/leetcode/","excerpt":"717. 1-bit and 2-bit CharactersDifficulty: Easy We have two special characters. The first character can be represented by one bit 0. The second character can be represented by two bits (10 or 11). Now given a string represented by several bits. Return whether the last character must be a one-bit character or not. The given string will always end with a zero.","text":"717. 1-bit and 2-bit CharactersDifficulty: Easy We have two special characters. The first character can be represented by one bit 0. The second character can be represented by two bits (10 or 11). Now given a string represented by several bits. Return whether the last character must be a one-bit character or not. The given string will always end with a zero.Example 1: 12345Input:bits = [1, 0, 0]Output: TrueExplanation: The only way to decode it is two-bit character and one-bit character. So the last character is one-bit character. Example 2: 12345Input: bits = [1, 1, 1, 0]Output: FalseExplanation:The only way to decode it is two-bit character and two-bit character. So the last character is NOT one-bit character. Note: 1 &lt;= len(bits) &lt;= 1000. bits[i] is always 0 or 1. Solution12345678910111213141516171819202122232425262728293031323334/** * @param &#123;number[]&#125; bits * @return &#123;boolean&#125; */var isOneBitCharacter = function(bits) &#123; if (bits.length === 0) &#123; return false; &#125; var len = bits.length; if (len === 1) &#123; return true; &#125; var secondzero;//倒数第二个零 for (var i = len - 2; i &gt;= 0; i--) &#123; if (bits[i] === 0) &#123; secondzero = i; break; &#125; &#125; if (secondzero == undefined) &#123; if (len % 2 == 0) &#123; return false; &#125; else &#123; return true; &#125; &#125; else &#123; if ((len - secondzero) % 2 == 0) &#123; return true; &#125; else &#123; return false; &#125; &#125;&#125;; 注意几点： 求数组长度用数组名.length 涉及到成对出现、单个出现，应联想到奇偶性","categories":[{"name":"刷题","slug":"刷题","permalink":"http://gunslingeratlarge.github.io/categories/刷题/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://gunslingeratlarge.github.io/tags/leetcode/"},{"name":"刷题","slug":"刷题","permalink":"http://gunslingeratlarge.github.io/tags/刷题/"},{"name":"easy","slug":"easy","permalink":"http://gunslingeratlarge.github.io/tags/easy/"}]},{"title":"理解paxos：大纲","slug":"理解paxos：大纲","date":"2018-04-03T08:48:00.000Z","updated":"2018-06-25T10:21:01.931Z","comments":true,"path":"2018/04/03/理解paxos：大纲/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/04/03/理解paxos：大纲/","excerpt":"https://understandingpaxos.wordpress.com/ 一、介绍 Paxos是分布式共识领域中最古老，最简单，最通用的算法之一 不建议通过阅读lamport的paxos made simple学习paxos，并不simple 对paxos核心算法以及它如何适应现有分布式计算的生态进行介绍 从以下三个层次展开 从总体上：paxos是什么，在分布式系统中的位置 解释paxos的工作原理并结合具体的冲突解决示例 从局部上：阐释paxos的组成部分，解释他们的作用和责任 除此之外，补充了paxos最常用的用例Multi-Paxos以及一些变种的介绍","text":"https://understandingpaxos.wordpress.com/ 一、介绍 Paxos是分布式共识领域中最古老，最简单，最通用的算法之一 不建议通过阅读lamport的paxos made simple学习paxos，并不simple 对paxos核心算法以及它如何适应现有分布式计算的生态进行介绍 从以下三个层次展开 从总体上：paxos是什么，在分布式系统中的位置 解释paxos的工作原理并结合具体的冲突解决示例 从局部上：阐释paxos的组成部分，解释他们的作用和责任 除此之外，补充了paxos最常用的用例Multi-Paxos以及一些变种的介绍 — 二、概览（Overview） paxos是什么 paxos是一种通过不可靠的沟通渠道达成单一价值共识的机制 在分布式系统中的角色 一个原始的、可以构建更高层次抽象的构件 独立于用例 具有许多潜在应用的通用工具 如何运行 定义了基于简单多数法则的对等一致协议 协议能够确保达成一个单一的共识结果值 所有的节点地位相当，没有谁的提议更有效或者更无效 失败容忍 能够容忍正常故障，如机器崩溃和网络中断 不能容忍恶意节点 要求每个对等饭都必须遵守协议要求才可以保证正确性 不完整的规范 基本算法只阐述了如何保证最终结果的正确性 但还有许多方面的问题没有描述，如： 如何保证最终结果一定能达到 如何缓解节点间的干扰 怎样保证所有节点都知晓最终结果 不完整规范的好处 提供了巨大的灵活性 开辟了广泛的潜在应用和优化的可能性 正确理解paxos的心态 重点是各个组件以及它们之间的交互 先从宏观上理解各个部分的作用，再了解细节 可以将算法的各个部分分开来理解，它们的复杂性局限在各个部分内部 正确性 确保进展 知晓最终结果 延迟优化 应用程序级逻辑 — 三、paxos的元素 提议ID 通过提议ID可以判断消息的先后 如(5，B)&gt;(4,B)&gt;(4，A)，5表示消息号，字母表示节点号 新接受的消息的ID超过最后处理的消息，才对新消息进行处理 消息 权限请求 请求其他节点获得提出提议的许可 被发送到所有的其他节点上 包含：即将提出的提议的提议id 许可授予 如果收到权限请求的结点发现这条权限请求是最新的（id最大），那么发送许可授予 包含 对应的权限请求包含的提议id值 最后接受的提议id 最后接受的值 提议 获得多数节点的许可授予后，节点可以发送提议以企图在某个值上达成一致 包含 建议id 值（blob二进制大文件） 已接受 如果接受对等方节点的提议，发送已接收消息来表示自己的接受态度 包含：对应提议的提议id 否定确认（Nack） 如果不处理某个节点发来的消息，则发送Nack Nack消息明确告知同伴他们的消息被忽略 这样同伴可以尽早知道自己的消息无法达成多数条件，可以尽早提高消息id值 — 四、达成共识 基本步骤 节点尝试发送请求许可消息 获得许可之后，节点提出提议 消息处理规则 收到权限请求消息 必须为提议ID更大的消息授予权限 更大：比自己之前批准过的权限请求消息更大 收到提议消息 必须接受提议Id更大的提议消息 更大：比自己之前批准过的权限请求消息更大 问题：假如最大批准了的是(3,A)，收到（6，B）的提议，接受提议，此时收到了(5,C)的权限请求消息，应如何处理？接受提议的时候会更新自己的已批准消息吗？（我觉得是会的，要不然还接受其他5,c的权限请求不成？） 其他注意事项 即使达成共识，整个过程也可能继续进行 只保证就最终值达成共识，不保证提议id 节点数必须是固定的和提前知道的 paxos不保证所有节点都能知晓最终值 — 五、保证进展 减轻节点间干扰 使用指数退避法 每一个节点从一个小的重传窗口开始，比如2ms 每接收到一次Nack消息就将窗口翻倍 要重新提出请求消息的时候，就从0-窗口值中随机选择一个数 然后延迟这么长再开始操作 从节点宕机中恢复 从一个给定范围内随机选择超时值，超时没有接受到消息则开始自己推进 这个方法降低了碰撞的可能性，并且相对数量较少的结点 而指数退避法比较使用于这种场景 — 六、组成部分 提议者 提出提议 处理丢失和延迟的消息 避免与其他的提议者的冲突 接受者 对提议者发送来的权限请求和提议消息进行处理 将已接受消息发送给仲裁者 如果否定了一条消息，可以将Nack发送给该提议者 仲裁者 接受者如果接受了一个提议，他将会把这个已接受消息发送给仲裁者 如果仲裁者发现超过半数的接受者都接受了，那么（这个仲裁者就认为）就达成共识 — 七、常见问题 分布式系统的天生复杂性 paxos不保证全部节点学习到共识值 只能对单个值形成共识 大多数分布式系统并不满足于单个值的共识，因此可能使用多个paxos实例，然后在应用层对这一系列共识值进行合并 paxos算法本身不能保证这种思路得出的最终合并值的正确性 对算法的修改 应尽量避免对算法的修改 修改后的算法正确性未经过验证 可以通过一定的模拟来实现改进 软件设计 算法很难进行封装 很难隔离网络因素 应该由一小组实现核心算法的类组成 可以将消息的发送和接受定义为类中的方法，则可以隔离开网络 — 八、Multi-Paxos 复制日志 可以利用多个paxos实例在一组机器上实现一致的复制日志 日志文件只能追加内容，如果能够保证每次追加的内容都达成了共识，那么这组机器也就有了复制日志 问题: 将如何防止来自不同Paxos实例的消息互相干扰？ 如果节点错过了一个或多个日志追加操作，它是如何检测到这一点的？ 节点在落后时如何迎头赶上？ 如何知道节点是否拥有最新的版本？ 答： 使用文件的长度确定消息属于哪个实例 如果我的文件长度比我收到的消息的文件长度短，则说明我落后了 需要进行一次共识来确定哪个版本是最新的 复制状态机 可以利用复制日志来建立复制状态机 每个状态机都按照复制日志的记录顺序来执行，则状态容易保持一致 性能考量 影响 影响写入：每次写入都需要经过（至少）两次来回，一次获得批准，一次进行提议 影响读取：每次想读取时不确定当前的版本，因此要进行一次共识以确定目前的版本 主节点 通过设置一个主节点可以避免上面的两个局限性 主节点的日志一定是最新的 写入时不需要进行批准，主节点直接提议即可 单次往返 写入优化 可以将一段时间要写入的数据打包，然后进行一次共识写入 减少形成共识的次数可以提高吞吐量 处理单点故障 为了避免主节点单点故障后整个系统完全不能工作 设置主节点重选机制 重选后继续进行写入和读取操作 主租约 主租约有时间限制 到期前应不断更新租约（宣告自己存活，并继续持有租约） 主租约实施方法 尽量将租约实现在paxos内部，与paxos中的消息对应，而非在外部实现 基于链的主租约管理 链上的消息为一对值 一个值为共识值（应用程序级别的值），另一个值为配置值 配置值中包含了主节点的号码以及作为主节点持续的时间 主节点可以在主租约到期前任意时间更改配置值 其他节点只能在主租约到期后更改 主租约对消息处理的限制 其他节点对主节点以外的权限请求和提议消息都将丢弃 保证只有主节点可以推进整个过程 租约到期后将解除对消息处理的限制直到新的主节点出现 主租约的时间考量 绝对时间不可靠 各个节点使用本地的相对时间 只要主节点在发送其配置值的时候就开始计时，即可保证其计时器在其他节点计时器到期之前到期 处理主节点故障 选择一个新的主节点 开销很大，尽量避免 可以通过主节点感知到故障后自己转交主节点身份给其他节点的方式 添加和删除成员 更新的成员列表可以输入到paxos实例链中，所有节点使用下一个链来更新列表即可 — 九、Paxos变种 Fast Paxos 单次往返 两种不同的轮次 与传统相比，容忍的故障更少 在广域网中相比Paxos并没有明显的优势 Generalized Paxos 允许条目顺序不同，只要结果状态相同即可 Byzantine Paxos 可以处理恶意节点 额外的消息延迟和加密开销 Egalitarian Paxos HP Paxos 混合协议 结合了Classic Paxos,Fast Paxos和Generalized Paxos的优点","categories":[{"name":"区块链","slug":"区块链","permalink":"http://gunslingeratlarge.github.io/categories/区块链/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://gunslingeratlarge.github.io/tags/区块链/"}]},{"title":"多项式环","slug":"多项式环","date":"2018-04-03T02:07:00.000Z","updated":"2018-06-25T10:21:01.923Z","comments":true,"path":"2018/04/03/多项式环/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/04/03/多项式环/","excerpt":"定义 多项式环中的元素为一个个多项式 这些多项式的系数不再是实数，而是来自于域F 把这样的多项式环叫做F[x] —","text":"定义 多项式环中的元素为一个个多项式 这些多项式的系数不再是实数，而是来自于域F 把这样的多项式环叫做F[x] — 定理组一：可除得余组 定理：多项式环中的元素f(x)同样也可以被非0的g(x)除，得到商为q(x)，余数为r(x) q(x)唯一，r(x)唯一，0&lt;degr(x) &lt; degg(x)或degr(x) = 0 推论一： f(x)、x-a ∈F,f(x)被x-a除的余式为f(a) 证明：由于x-a的次数为1次，因此r(x)只能为0次，设为c 则f(x) = (x - a) * q(x) + c 取x = a，则f(a) = c 因此得证余式为c 推论二：若x-a可以整除f(x)，则f(a) = 0 — 定理组二：公因子组 定义：最大公因子，其他所有的公因子都必须要整除最大公因子 定理：f(x),g(x)同样也具有最大公因子GCD(f(x),g(x))，同样可以使用辗转相除法求得 定理：若h(x)为f(x)、g(x)的最大公因子，必存在s(x),t(x)∈F[x]使得h(x) = s(x)f(x)+ t(x)g(x) — 定义：F* = F - {0}实际上就是F[x]的所有可逆元（关于第二个运算），因为f(x)g(x)= 1在f(x)的次数大于1时没法实现 — 定义：如果f(x) 能够分解为两个F[x]中的多项式的乘积（这两个多项式的次数≥1），那么就说f(x)可约 — 定理组三：可逆元倍 定理：如果f(x)与g(x)互相整除，当且仅当它们之间的关系是可逆元倍。（f(x) = ag(x), a∈F*） 定理：如果g1(x)是GCD(f(x),g(x))，那么g2(x)是GCD（f(x),g(x)）当且仅当g1、g2之间的关系是可逆元倍","categories":[{"name":"数学","slug":"数学","permalink":"http://gunslingeratlarge.github.io/categories/数学/"},{"name":"抽象代数","slug":"数学/抽象代数","permalink":"http://gunslingeratlarge.github.io/categories/数学/抽象代数/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://gunslingeratlarge.github.io/tags/数学/"},{"name":"抽象代数","slug":"抽象代数","permalink":"http://gunslingeratlarge.github.io/tags/抽象代数/"}]},{"title":"一道群练习题","slug":"一道群练习题","date":"2018-04-02T00:19:00.000Z","updated":"2018-06-25T10:21:01.917Z","comments":true,"path":"2018/04/02/一道群练习题/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/04/02/一道群练习题/","excerpt":"","text":"测验：设~是群G上的等价关系,并且对于G的任意三个元素a,x,x’，若ax∈ax’则必有x ∈x’。 证明：与G中单位元等价的元素全体构成G的一个子群。H={x|x∈G,并且x∈e}对任意的x∈H， x∈e, xe∈e=xx-1对任意的x,y∈H， x∈e, y∈e, ey∈e,x-1xy∈x-1x 总结： 1、e可以转为x * x^-12、不要觉得x不在H中就没有逆了，G中有逆，只不过我们要把G中的逆证明为H中的逆3、证子群时，不一定要先证明封闭性，也可以先证有逆元，再证封闭性","categories":[{"name":"数学","slug":"数学","permalink":"http://gunslingeratlarge.github.io/categories/数学/"},{"name":"抽象代数","slug":"数学/抽象代数","permalink":"http://gunslingeratlarge.github.io/categories/数学/抽象代数/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://gunslingeratlarge.github.io/tags/数学/"},{"name":"抽象代数","slug":"抽象代数","permalink":"http://gunslingeratlarge.github.io/tags/抽象代数/"}]},{"title":"子环与环同态","slug":"子环与环同态","date":"2018-04-01T05:52:00.000Z","updated":"2018-06-25T10:21:01.923Z","comments":true,"path":"2018/04/01/子环与环同态/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/04/01/子环与环同态/","excerpt":"子环 定义 子环 R为环，对于集合S属于R且为非空集合，S是环时称它为R的子环 环的中心 R中的所有的与R中任意元在乘法运算下可交换的元素全体构成环的中心 单位子环 R为有单位元环，单位元为e，则E = {ne | n ∈ Z}为R的一个子环，称为单位子环 特征数 使pe = 0的最小正整数为环R的特征数 如果不存在这样的正整数，则称环R的特征数为0 当R的单位子环E有限时，一定有非0特征数","text":"子环 定义 子环 R为环，对于集合S属于R且为非空集合，S是环时称它为R的子环 环的中心 R中的所有的与R中任意元在乘法运算下可交换的元素全体构成环的中心 单位子环 R为有单位元环，单位元为e，则E = {ne | n ∈ Z}为R的一个子环，称为单位子环 特征数 使pe = 0的最小正整数为环R的特征数 如果不存在这样的正整数，则称环R的特征数为0 当R的单位子环E有限时，一定有非0特征数 定理 子环等价定理 S为R的子环等价为 1.S关于R的第一个运算为子群（封闭且每个元素有逆元） 2.第二个运算满足封闭性 环的中心为子环 p为有单位元环R的特征数，对任何a≠0，pa = 0 若R是整环 p是使得pa =0对任何a≠0都成立的最小非零正整数 R为整环时，其特征数或为素数或为0（反证法证明） — 环同态与同构 环的同态映射 对于环[R;+,*]与环[R’;+’,*‘],若存在映射φ:R→R’ 使得对任r1,r2∈R有 φ(r1+r2)=φ (r1)+φ(r2) φ(r1*r2)=φ(r1)*‘φ(r2) 环同态的性质 加法单位元映射到加法单位元，即φ(0) =0’ 乘法单位元映射到乘法单位元，即φ(e) = e’，当满足如下条件时 φ是满射或者 R’为无零因子环且φ不是零同态（所有元素在φ下的象都是0’） 如果两个环同构，其实就是一个环，只是人为指定的符号表示不同 同构的性质 若R与R’同构，则R为整环，除环，域时，R’同样","categories":[{"name":"数学","slug":"数学","permalink":"http://gunslingeratlarge.github.io/categories/数学/"},{"name":"抽象代数","slug":"数学/抽象代数","permalink":"http://gunslingeratlarge.github.io/categories/数学/抽象代数/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://gunslingeratlarge.github.io/tags/数学/"},{"name":"抽象代数","slug":"抽象代数","permalink":"http://gunslingeratlarge.github.io/tags/抽象代数/"}]},{"title":"opml转换为markdown","slug":"opml转换为markdown","date":"2018-04-01T00:10:00.000Z","updated":"2018-06-25T10:21:01.912Z","comments":true,"path":"2018/04/01/opml转换为markdown/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/04/01/opml转换为markdown/","excerpt":"","text":"尝试过pandoc，但是pandoc将所有的opml内容都转换为markdown中的标题，非常难受。最后找到了这个https://github.com/azu/opml-to-markdown简单又好用。这样就能够满足我想要在幕布上写大纲，但是又想发布在博客上的需求了。命令：opml-to-markdown -e subring.opml -o subring.md","categories":[{"name":"其他","slug":"其他","permalink":"http://gunslingeratlarge.github.io/categories/其他/"}],"tags":[]},{"title":"js再入门","slug":"js再入门","date":"2018-03-31T09:06:00.000Z","updated":"2018-06-25T10:21:01.903Z","comments":true,"path":"2018/03/31/js再入门/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/03/31/js再入门/","excerpt":"一、输出语句console.log(“hello”);document.write(“hello”);alert(“hello”); 二、全局变量在函数外声明的变量没有加var的变量（注意） 三、类型基本类型StringNumber关注NaNnot a number，console.log(“abc”/18);结果是NaN，但实际上是一个number（很尴尬）undefined和任何数值计算都为NaNNaN与任何数值都不相等","text":"一、输出语句console.log(“hello”);document.write(“hello”);alert(“hello”); 二、全局变量在函数外声明的变量没有加var的变量（注意） 三、类型基本类型StringNumber关注NaNnot a number，console.log(“abc”/18);结果是NaN，但实际上是一个number（很尴尬）undefined和任何数值计算都为NaNNaN与任何数值都不相等 Boolean“”，undefined，null为falseundefined == null与任何数值计算，结果仍为undefinednull与任何数值计算，将null看作是0来计算null表示对象不存在，undefined表示未定义，比如var a;此时a的值就是undefined比如document.getElementById(“xxelement”);若元素不存在，则返回null 对象类型ObjectfunctionArrayDateRegExpError 四、数据类型转换转换成String变量+””String(变量)变量.toString() 转换为Number变量-*/一个数字，如”11”-0Number(变量)parseInt(变量)：取整parseFloat(变量)：取浮点数 转换为BooleanBoolean(变量)!!变量：对变量取反再取反 五、函数函数也是一种数据类型，归根结底，它还是属于Object。 声明function foobar() {}var foobar = function() {} 返回值函数如果没有return一个值，则返回值为undefined函数名=整个函数JS在加载的时候，只加载函数名，不加载函数体可以将函数赋给一个变量 变量声明提升和预解析如果一个变量没有声明，直接console.log(a);会报错，引用未定义但是如果定义了var a;但是没赋值，不会报错，会打出undefined 预解析 查看语法错误 变量声明提升和函数整体提升只提升变量名，不提升变量值（相当于提前声明变量，但是赋值语句位置不变）方法是整体提升的（用function直接定义的方法，即function foobar() {}） 函数范围内也适用变量声明提升 函数内只要自己局部有变量声明，就算需要变量声明提升，也是用自己的 匿名函数123(function() &#123; do something.&#125;)();//执行该匿名函数 前面的括号包含函数体，后面的括号就是给匿名函数传递参数并立即执行之。匿名函数的作用是避免全局变量的污染以及函数名的冲突。还有其他写法的匿名函数，不一一例出。匿名函数通常在设置定时器(setInteval)，绑定事件(document.onclick = function(){})，和直接调用（自动执行）时使用。 回调函数简单理解：函数作为参数进行传递和使用12345678fn(test);function fn(demo) &#123; demo();&#125;function test() &#123; alert(\"1\");&#125; 执行函数就等于函数名+(); 整个函数+(); （函数名就等于整个函数）什么情况下使用回调函数？一般用于定义一个规则。规则的传递只能通过函数实现，通过变量无法达成。（被传递的函数叫回调函数）123456789101112131415161718//对两个数按照某个规则进行运算fn(10,5,demoAdd);function fn(num1,num2.demo) &#123; return demo(num1,num2);&#125;//定义四个规则，加减乘除function demoAdd(a,b) &#123; return a + b;&#125;function demoSub(a,b) &#123; return a - b;&#125;function demoTimes(a,b) &#123; return a * b;&#125;function demoOver(a,b) &#123; return a / b;&#125; 五、面向对象编程js基于对象，没有类的概念，只能new出Object对象。12345678 //创建空白对象hero var hero = new Object(); //绑定属性hero.money = 10000;hero.level = 6;hero.attack = function () &#123; console.log(\"英雄攻击\");&#125; 当这样创建单个自定义对象时非常繁琐，因为要不停地绑定属性和方法。如果用for循环又不能修改名字的值。 函数创建对象1234var aaa = new Stu();console.log(aaa);function Stu() &#123;&#125; new做了这样几件事情： 开辟了内存空间，存放新的对象 把this设置为当前对象 执行内部代码，设置对象属性和方法 返回新创建的对象。正是如此stu中才没有return语句，aaa也可以拿到对象。实际上一开始调用这个构造函数的是window，也就是说这个构造函数的this是window，new这个关键字将this改为了新的这个实例，然后再执行构造函数代码 如果要给aaa绑定属性和方法:123456function Stu(name) &#123; this.name = name; this.sayHi = function () &#123; console.log(this.name + \"hi\"); &#125;&#125; 构造函数一般首字母大写。这里的Stu()就是构造函数。但是typeof aaa还是Object。所以我们说js中无法创建自定义类型。 对象属性绑定12345var xiaoming = new Object();xiaoming.name = \"shuaige\";//name:shuaigevar aaa = \"age\";xiaoming[aaa] = 19; //age:19 xiaoming[0] = \"abc\"//'0':abc 对象名.属性或对象名[变量]或对象名[值]注意，如果方括号中是数字，如0或者’0’都会在map中存为’0’:abc，但是引用的时候只能通过xiaoming[0]或者xiaoming[‘0’]，而如果是用的xiaoming[‘name’]或者xiaoming[name]最后都会是name:xiaoming，不会加引号 jsonjs可以直接使用json对象12345var foo = &#123;\"aaa\":1,\"bbb\":2,\"ccc\":3&#125;for(var key in foo)&#123; console.log(key);//aaa bbb ccc console.log(foo[key]);//使用方括号取值&#125; 六、数组API判断数组与转换数组 instanceof: 是一个关键字。判断A是否是B类型。布尔类型值 = A instanceof B ; Array.isArray() //HTML5中新增布尔类型值 = Array.isArray(变量) ; toString()字符串 = 数组.toString(); valueOf() //返回数组对象本身数组本身 = 数组.valueOf(); Join //根据每个字符把数组元素连起来变成字符串字符串 = 数组.join(变量);变量可以有可以没有。不写默认用逗号分隔，无缝连接用空字符串。 数组增删和换位置 push() //在数组最后面插入项，返回数组的长度数组1改后的长度 = 数组1.push(元素1); pop() //取出数组中的最后一项，返回最后一项被删除的元素 = 数组1.pop(); unshift() //在数组最前面插入项，返回数组的长度数组1改后的长度 = 数组1.unshift(元素1); shift() //取出数组中的第一个元素被删除的元素 = 数组1.shift(); reverse() //翻转数组（原数组将被反转，返回值也是被反转后的数组）反转后的数组 = 数组1.reverse(); sort(); //给数组排序，返回排序后的数组。如何排序看参数。 123从小到大排序后的数组 = 数组1.sort(function(a,b)&#123; return a-b; &#125;); 无参：按照数组元素的首字符对应的Unicode编码值从小到大排列数组元素。带参：必须为函数（回调函数—callback）。函数中带有两个参数，代表数组中的前后元素。如果计算后（a-b），返回值为负数，a排b前面。等于0不动。返回值为正数，a排b后面。 了解方法 concat() //把参数拼接到当前数组新数组 = 数组1.concat(数组2); slice() //从当前数组中截取一个新的数组，不影响原来的数组，参数start从0开始,end从1开始新数组 = 数组1.slice(索引1，索引2); splice()//删除或替换当前数组的某些项目，参数start,deleteCount,options(要替换的项目)新数组 = 数组1.splice(起始索引，结束索引，替换内容); indexOf()、lastIndexOf() //如果没找到返回-1索引值 = 数组.indexOf/lastIndexOf(数组中的元素); 迭代方法不会修改原数组123456every()、filter()、forEach()、map()、some()数组/boolean/无 = 数组.every/filter/forEach/map/some( function(element,index,arr)&#123; 程序和返回值； &#125;); 对数组中的每一个元素都进行一些操作，每个关键字都有自己的含义。1234567891011121314151617181920212223242526//对数组中每一项运行以下函数，如果都返回true，every返回true，如果有一项返回false，则停止遍历 every返回false；不写默认返回falsearray.every(function(item,index,arr) &#123;&#125;)//对数组中每一项运行以下函数，该函数返回结果是true的项组成的新数组var arr = array.filter(function(item,index,arr) &#123;&#125;);console.log(arr); //遍历数组array.forEach(function(item,index,arr)&#123;&#125;);//对数组中每一项运行以下函数，返回该函数的结果组成的新数组var arr = array.map(function(item,index,arr) &#123; return \"\\\"\" + item + \"\\\"\";&#125;)//对数组中每一项运行以下函数，如果该函数对某一项返回true，则some返回truevar b = array.some(function(item,index,arr) &#123; if (item == \"ww\") &#123; return true; &#125; return false;&#125;); 清空数组1234var array = [1,2,3,4,5,6]; array.splice(0,array.length); //删除数组中所有项目 array.length = 0; //length属性可以赋值，其它语言中length是只读 array = []; //推荐 构造函数的一个小细节Number是包装类型,可以用var i = new Number(111)创建包装类型，此时i就是Number {[[PrimitiveValue]]: 111}，也可以var i = Number(111)，此时i就为基本数字111，原因是这样的，Number有一个构造函数，而这个函数有返回值，直接调用Number而不new的话就取的是返回值，有new就得到的是一个新的对象。1234function Num(aaa)&#123; this[\"[[PrimitiveValue]]\"] = num/1; return aaa/1;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://gunslingeratlarge.github.io/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://gunslingeratlarge.github.io/tags/前端/"},{"name":"js","slug":"js","permalink":"http://gunslingeratlarge.github.io/tags/js/"}]},{"title":"清除浮动","slug":"清除浮动","date":"2018-03-29T23:48:00.000Z","updated":"2018-06-25T10:21:01.929Z","comments":true,"path":"2018/03/30/清除浮动/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/03/30/清除浮动/","excerpt":"clear:both;添加元素直接在最后一个浮动元素（非失去高度的父元素）后面添加下面的标签。不推荐使用，会增加页面标签，造成结构混乱。如果在父元素下面添加这个标签，依然能够清除浮动，但是父盒子不会被撑大。（为何？我也不知）1&lt;div style=\"clear:both;\"&gt;&lt;div&gt;","text":"clear:both;添加元素直接在最后一个浮动元素（非失去高度的父元素）后面添加下面的标签。不推荐使用，会增加页面标签，造成结构混乱。如果在父元素下面添加这个标签，依然能够清除浮动，但是父盒子不会被撑大。（为何？我也不知）1&lt;div style=\"clear:both;\"&gt;&lt;div&gt; 单伪元素（推荐使用）给父元素加类.clearfix123456789101112.clearfix:after &#123; content:\" \"; clear:both; display:block; visibility:hidden; height:0; line-height:0; &#125;.clearfix &#123; zoom:1;&#125; 双伪元素用来装逼1234567891011.clearfix:before,.clearfix:after &#123; content: \"\"; display: table; &#125;.clearfix:after &#123; clear:both; &#125;.clearfix &#123; *zoom: 1; &#125; overflow:hidden;父元素创建了新的bfc（block formatting context），创建了 bfc的元素就是一个独立的盒子，里面的子元素不会在布局上影响外面的元素，反之亦然，同时bfc仍然然属于文档中的普通流。123.father &#123; overflow:hidden; &#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://gunslingeratlarge.github.io/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://gunslingeratlarge.github.io/tags/前端/"},{"name":"css","slug":"css","permalink":"http://gunslingeratlarge.github.io/tags/css/"}]},{"title":"css补充","slug":"圆角效果","date":"2018-03-29T14:09:00.000Z","updated":"2018-06-25T10:21:01.922Z","comments":true,"path":"2018/03/29/圆角效果/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/03/29/圆角效果/","excerpt":"","text":"实现圆角效果，使用border-radius属性，可以取四个值，分别是左上，右上，右下，左下的角的半径。如果说想实现完全的圆形，就要使宽高相等并且使border-radius成为宽/高的一半。 做logo，给a背景，并给a设置文字移除：text-indent:-5000em;（text-indent对块级元素生效。有人建议加一个overflow:hidden;，text-indent设为负值（向左设），要不然会向右撑大滚动条） 如果给a中的文字设置行高，由于a是行内元素，并不会使得a被撑大，但是a的父元素会被撑大。 margin和padding都可以的场景尽量使用padding少用margin，margin可能涉及到合并和塌陷的问题 要使用z-index必须有定位 父盒子撑开和撑破两回事。有高度只会被撑破，没有高度就会被撑开。 浮动的盒子相互影响，不管是否在同一个盒子中。比如有一个父盒子1，一个子盒子2，还有一个父盒子的兄弟盒子3，盒子2向左浮动和影响到盒子3的向左浮动。 浮动的盒子比标准流盒子高，但是能够遮挡住标准流盒子，遮挡不住里面的图片和文字。","categories":[{"name":"前端","slug":"前端","permalink":"http://gunslingeratlarge.github.io/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://gunslingeratlarge.github.io/tags/前端/"},{"name":"css","slug":"css","permalink":"http://gunslingeratlarge.github.io/tags/css/"}]},{"title":"不用图片实现下拉菜单小三角","slug":"不用图片实现下拉菜单小三角","date":"2018-03-29T08:42:00.000Z","updated":"2018-06-25T10:21:01.918Z","comments":true,"path":"2018/03/29/不用图片实现下拉菜单小三角/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/03/29/不用图片实现下拉菜单小三角/","excerpt":"思路如图所示，这样的小三角是非常常用的，怎样实现起来简单又快捷呢？我们实际上是使用了“◇”这个符号，但是只显示了它的下半部分。1234&lt;li class=\"location\"&gt; 我的京东 &lt;i&gt;&lt;s&gt;◇&lt;/s&gt;&lt;/i&gt;&lt;/li&gt;","text":"思路如图所示，这样的小三角是非常常用的，怎样实现起来简单又快捷呢？我们实际上是使用了“◇”这个符号，但是只显示了它的下半部分。1234&lt;li class=\"location\"&gt; 我的京东 &lt;i&gt;&lt;s&gt;◇&lt;/s&gt;&lt;/i&gt;&lt;/li&gt; 思路是用i标签去盖住s标签要显示的部分，然后设置overflow:hidden;把上面的部分给隐藏掉。其中i标签与s标签都要使用absolute定位。注意s标签绝对定位是按照i标签起算的。123456789101112131415.location i &#123; position:absolute; width:12px; height: 8px; right:0; bottom:10px; overflow: hidden;&#125;.location s &#123; position:absolute; right:0; bottom:-8px; font-weight: normal;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://gunslingeratlarge.github.io/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://gunslingeratlarge.github.io/tags/前端/"},{"name":"css","slug":"css","permalink":"http://gunslingeratlarge.github.io/tags/css/"}]},{"title":"三像素问题","slug":"3像素bug","date":"2018-03-28T12:52:00.000Z","updated":"2018-06-25T10:21:01.888Z","comments":true,"path":"2018/03/28/3像素bug/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/03/28/3像素bug/","excerpt":"","text":"img直接放在div中时，会比div的下边缘高出3个像素，因为img属于行内元素，因此其不是与下边缘对齐而是与基线对齐的。1.img标签增加vertical-align:top123img &#123; vertical-align:top;&#125; 2.img标签的父标签增加font-size:0;123body &#123; font-size:0;&#125; 3.img标签增加display:block;123img &#123; display:block;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://gunslingeratlarge.github.io/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://gunslingeratlarge.github.io/tags/前端/"},{"name":"css","slug":"css","permalink":"http://gunslingeratlarge.github.io/tags/css/"}]},{"title":"css基本功之定位","slug":"css基本功之定位","date":"2018-03-28T10:44:00.000Z","updated":"2018-06-25T10:21:01.899Z","comments":true,"path":"2018/03/28/css基本功之定位/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/03/28/css基本功之定位/","excerpt":"定位的四个属性left、right、top、bottom，可以以像素值、百分比等等为单位。 静态定位默认定位，文档流，从左到右，从上到下。 绝对定位 position:absolute; 若父元素为静态定位，则相对浏览器窗口计算自身位置（滚动滚轮会跟着动） 若父元素为绝对或者相对定位，则相对父元素计算自身位置 使用绝对定位是脱标的，因此会被转换为行内块元素，可以设置宽高 块级元素不再自动填充满父级元素","text":"定位的四个属性left、right、top、bottom，可以以像素值、百分比等等为单位。 静态定位默认定位，文档流，从左到右，从上到下。 绝对定位 position:absolute; 若父元素为静态定位，则相对浏览器窗口计算自身位置（滚动滚轮会跟着动） 若父元素为绝对或者相对定位，则相对父元素计算自身位置 使用绝对定位是脱标的，因此会被转换为行内块元素，可以设置宽高 块级元素不再自动填充满父级元素 相对定位 position:relative; 相对自身的默认位置的定位 子绝父相最常用 父元素相对定位可以避免脱标，子元素绝对定位可以方便确定位置 固定定位 fixed 固定定位之后脱标，因此转换为行内块元素 行内块元素不会自动填充满父级元素的宽度，因此使用width:100%可以解决这个问题 使用固定定位之后从浏览器窗口出发，滚动滚轮不会跟着动，始终展示在页面中 定位的盒子居中显示 margin: 0 auto;只能让不脱标的盒子居中 left:50%; margin-left:-480px; 即向右走父元素宽度的50%,向左走自身宽度的一半（这里自身宽度为960px） 不同的分辨率也可适配 总结若脱标，则不管是行内元素还是块级元素，都转换为行内块元素。块级元素表示为不再具有自动填满父级元素宽度的属性，行内元素表现为可以设置宽高。最常用的是子绝父相，可以满足大多数情况。如果需要一个元素一直在页面上，如固定的导航栏，那么可以使用fixed定位。","categories":[{"name":"前端","slug":"前端","permalink":"http://gunslingeratlarge.github.io/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://gunslingeratlarge.github.io/tags/前端/"},{"name":"css","slug":"css","permalink":"http://gunslingeratlarge.github.io/tags/css/"}]},{"title":"numpy pandas快速入门","slug":"pandas快速入门","date":"2018-03-27T02:43:00.000Z","updated":"2018-06-25T10:21:01.912Z","comments":true,"path":"2018/03/27/pandas快速入门/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/03/27/pandas快速入门/","excerpt":"","text":"https://github.com/QCaudron/pydata_pandas/blob/master/coffee_analysis_exercise.ipynbhttps://www.youtube.com/watch?v=5XGycFIe8qE https://www.youtube.com/watch?v=POe1cufDWFs numpynumpy数组属性123456import numpy as nparray = np.array([[1,2,3], 2,3,4]])array.ndimarray.shapearray.size numpy创建array12345a = np.array([2,23,4], dtype = np.int) #np.int,float32, int32 np.zeros((3,4))np.ones((3,4),dtype = np.int16)np.arrange(10,20,2)np.arrange(12).reshage((3,4))","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://gunslingeratlarge.github.io/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://gunslingeratlarge.github.io/tags/机器学习/"}]},{"title":"特征工程","slug":"特征工程","date":"2018-03-27T00:16:00.000Z","updated":"2018-06-25T10:21:01.929Z","comments":true,"path":"2018/03/27/特征工程/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/03/27/特征工程/","excerpt":"前言特征工程的意义更好的特征意味着更强的灵活度意味着更简单的模型意味着意味着更好的结果","text":"前言特征工程的意义更好的特征意味着更强的灵活度意味着更简单的模型意味着意味着更好的结果 互联网公司机器学习的工作 跑数据 map-reduce hive sql 数据仓库搬砖 数据清洗 分析业务，分析case，找特征… 应用在常见机器学习算法 工业界特征工程作用 两周完成一次特征迭代，有效的情况下auc提升千分之三-五 一个月左右完成模型的小优化，有效的情况下auc提升千分之5 数据采集 哪些数据对最后的结果预测有帮助？ 从多个维度去做思维的发散 数据我们能够采集到吗？ 线上实时计算的时候获取是否快捷？ 存储格式 确定存储格式 时间用时间戳还是年月日？ 一段时间聚合还是单个动作？ 需要关联非常多的hive表和hdfs文件 数据清洗思考角度 简单不可能 身高3米 买脸盆抹布花了10w的人 组合或同级属性判定 判定一个人是否会买篮球鞋，样本中85%女性？ 补齐可对应的缺省值 缺太多 数据采样 很多情况下，正负样本是不均衡的 大多数模型对正负样本比是敏感的（比如LR） 随机采样与分层采样不平衡的处理办法： 正样本&gt;&gt;负样本且量都挺大：下采样 正样本&gt;&gt;负样本 量不大：采集更多数据、上采样、修改损失函数 数据与特征处理数值型特征年龄、商店的销量 统计值max min mean std pandas series的describe 离散化 连续值赋予非线性 分为一段一段的几个区间，落在某个区间位置就取1，比如用pd的cut（按照中位数作切分） 均匀切分或者按频次切分 如60-65的人与65-67的人一样多，则为60,65,67切分 Hash分桶 每个类别下对应的变量同级值histogram（直方图） 试试 数值型-&gt;类别型 幅度调整 归一化 类别型 one-hot编码 pandas的get_dummies可以进行onehot编码 哑变量 Hash与聚类处理 统计每个类别变量下的各个target比例，转成数值型（如[1/3,2/3,0]表示男性，用[0,1/3,2/3]）,21用[1,0,0]等等。 时间型 连续值 持续时间 间隔时间 离散值 一天中哪个时间段 一周中星期几 一年中那个星期 一年中哪个季度等等 文本型 词袋 word2vec 把词袋中的词扩充到n-gram Tf-idf 统计特征 加减平均 分位线数 次序型 比例型：好、中、差评等等 更多特征工程的内容 http://www.cnblogs.com/jasonfreak/p/5448385.html","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://gunslingeratlarge.github.io/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://gunslingeratlarge.github.io/tags/机器学习/"}]},{"title":"了解paxos：保证进展","slug":"了解paxos：保证进展","date":"2018-03-26T11:22:00.000Z","updated":"2018-06-25T10:21:01.918Z","comments":true,"path":"2018/03/26/了解paxos：保证进展/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/03/26/了解paxos：保证进展/","excerpt":"understanding paxos的学习笔记。 面临的问题当我们确保了集群最终会到达一个共识值的时候，但却没有考虑到这个集群可能不会在达成共识上有进展。常见的导致无进展的情况有两种： 节点间的干扰 节点的宕机","text":"understanding paxos的学习笔记。 面临的问题当我们确保了集群最终会到达一个共识值的时候，但却没有考虑到这个集群可能不会在达成共识上有进展。常见的导致无进展的情况有两种： 节点间的干扰 节点的宕机 节点间的干扰比如考虑一种情况： 当A提出了(1,A)的请求消息并得到批准 B提出了(2,B)的请求消息并得到了批准 A提出提议消息被否定 A提出(3,A)的请求消息 B提出提议被否定 B提出(4，B)的请求消息 … 可以一直这样循环下去。这样就不会产生任何进展。我们要尽可能避免这种情况的发生。采用的方法为指数回退法（exponential backoff approach）。每一个节点从一个小的重传窗口开始，比如2ms，每接收到一次Nack消息就将窗口翻倍，要重新提出请求消息的时候，就从0-窗口值中随机选择一个数，然后延迟这么长再开始操作。这样做有两个好处： 随机化可以防止可能导致连续冲突的同步延迟 不断增加的窗口大小可以保证最后一个节点总有足够的时间来完成这整个共识过程 节点宕机我们希望，在一个达成共识的过程中，只有部分节点在推进这个过程，如果所有节点都参与就会变得非常拥挤。最好是当原本在推进这个过程的结点宕机了之后，由新的节点补充进来，继续这个工作。因此，我们可以有最直接的设想即当超过一定时长没有接到请求许可消息或者提议消息，则开始推进。但由于是确定的时间长度，在推进的节点宕机之后，过了这个时间就会有大量的节点开始推进，导致大量的冲突和干扰。因此这个值最好是一个范围内的随机值，比如在局域网的低延迟应用可能选用2-10ms而基于互联网的高延迟应用可能就是2-5s。","categories":[],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://gunslingeratlarge.github.io/tags/区块链/"}]},{"title":"环的定义与性质","slug":"环的定义与性质","date":"2018-03-26T11:05:00.000Z","updated":"2018-06-25T10:21:01.930Z","comments":true,"path":"2018/03/26/环的定义与性质/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/03/26/环的定义与性质/","excerpt":"","text":"环的定义 环 定义两个运算+，*，在第一个运算上是阿贝尔群，在第二个运算上满足结合和分配律 对环的修饰都是针对第二个运算的 交换环与单位环 交换环：第二个运算具有交换律 单位环：第二个运算具有单位元 零因子 a，b属于环R，但a，b都不为0（第一个运算的单位元，也是第二个运算的零元），若a*b = 0，则说a、b分别是零因子 整环 可交换且无零因子的环 除环 有单位元且每个非零元都有逆元的环 除环若关于第二个运算满足交换律，则升级为域 环的性质2条定理 定理一 a0 = 0a = 0 a(-b) = (-a) b = 0 定理二 整环满足消去律（实际上只要环没有零因子就可以满足消去律了）","categories":[{"name":"数学","slug":"数学","permalink":"http://gunslingeratlarge.github.io/categories/数学/"},{"name":"抽象代数","slug":"数学/抽象代数","permalink":"http://gunslingeratlarge.github.io/categories/数学/抽象代数/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://gunslingeratlarge.github.io/tags/数学/"},{"name":"抽象代数","slug":"抽象代数","permalink":"http://gunslingeratlarge.github.io/tags/抽象代数/"}]},{"title":"复数","slug":"带余除法（division-algorithm）","date":"2018-03-24T09:11:00.000Z","updated":"2018-06-25T10:21:01.924Z","comments":true,"path":"2018/03/24/带余除法（division-algorithm）/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/03/24/带余除法（division-algorithm）/","excerpt":"","text":"本笔记是Complex Numbers Part Imaginary, but Really Simple的学习笔记。 复数平面可以通过复数平面来直观地观察复数，横轴为实轴，代表我们的实数所在的轴，竖轴为虚轴。复数平面上的每一个点都可以用a + bi来表示，比如A点就是$\\frac{-1 + i}{\\sqrt2}$,B点就是i，C点就是1。每一个复数还可以用极坐标表示，即a + bi可以表示为r(cosθ+ isinθ)这里r是长度，$r = \\sqrt{a^2 + b^2}$，θ是极坐标的角度。在极坐标中，两个复数运算，是r相乘，θ相加。（用极坐标乘乘便知） 欧拉公式我们将$e^x$展开，有$e^x = 1 + x + \\frac{1}{2}x^2 + \\frac{1}{6}x^3+…$令$x = i\\theta$,$e^{i\\theta } = 1 + i\\theta + \\frac{1}{2}(i\\theta )^2 + \\frac{1}{6}(i\\theta )^3 + … = 1 - \\frac{1}{2}\\theta ^2 + i(\\theta - \\frac{1}{6}\\theta^3)+ … = \\cos\\theta+ i \\sin\\theta$所以就可以把复数表示为$re^{i\\theta }$。","categories":[{"name":"数学","slug":"数学","permalink":"http://gunslingeratlarge.github.io/categories/数学/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://gunslingeratlarge.github.io/tags/数学/"}]},{"title":"凯莱定理与群的同态","slug":"凯莱定理与群的同态","date":"2018-03-24T07:01:00.000Z","updated":"2018-06-25T10:21:01.921Z","comments":true,"path":"2018/03/24/凯莱定理与群的同态/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/03/24/凯莱定理与群的同态/","excerpt":"凯莱定理与群的同态Motivation我们在研究群的时候，有一些群中的元素是集合的映射，比如$S_n$这种n次对称群，我们就有一个问题，是不是所有的群都可以将他们中的元素解读为某些置换呢？这就引出了凯莱（Cayley）定理。","text":"凯莱定理与群的同态Motivation我们在研究群的时候，有一些群中的元素是集合的映射，比如$S_n$这种n次对称群，我们就有一个问题，是不是所有的群都可以将他们中的元素解读为某些置换呢？这就引出了凯莱（Cayley）定理。 aG与Ga设$a\\in G$，则有$aG = {ag \\mid g \\in G}$ ,我们容易证出，aG = Ga = G。 证明如下: 证明G中的每个元素都在aG中 设$g\\in G$，有$aa^{-1}g\\in aG$，$g\\in aG$。 易证aG元素个数与G相同。 因此aG = G，Ga同理。 同构怎么样去理解同态与同构？两个群同态，则大多数运算规则都相同，具有很多相同的性质。而两个群同构，则可以看做是同一个代数系统了。 对于同态映射：$\\phi(a\\circ b) = \\phi(a)\\cdot\\phi(b)$我们要有自己的理解。我们可以这样形象地理解 ，有一个代数系统为S = {孙悟空，贝吉塔，悟吉塔|$\\circ $}，另一个代数系统为T = {超级孙悟空，超级贝吉塔，超级悟吉塔|·}（注意这里其实不满足封闭性），他们的运算分别为“合体”与”超级合体“。这里我们定义从S-&gt;T的映射$\\phi$为“超级赛亚人变身”，那么我们可以说，孙悟空，贝吉塔合体之后再变身，与他俩都变身了再超级合体，得到的结果是一样的，而又满足双射，因此映射$\\phi$是同态映射，这两个代数系统同构。 凯莱定理我们刚开始的时候说过，是不是所有的群都可以将他们的元素解读为置换呢？凯勒定理这样说到：任一有限群必同构于一个同阶置换群。 好大的口气！凯莱敢这样说，必然有他的依仗，他必然知道拿一个有限群G，怎样才能构造出一个与它同构的同阶置换群。我们就设这个有限群为G，而这个将要与它同构的置换群为$\\Sigma$。 凯莱是这样构造这个$\\Sigma$的： 要将G中的元素解读为置换，置换是集合到集合的映射，那么这个集合从哪里找呢？不如就地取材，把这个G中的集合拿出来，把它作为我们的置换的映射基础。也就是说，我们现在想要将G中的元素解读为G-&gt;G的映射。 怎样解读？我们设a是G中的元素，现在我们试图把a解读为映射，联系到上面我们证过aG = G，因此我们把映射a(g)定义为，拿G中的任意元素g，给g左乘a，我们上面证过，左乘之后所有的结果组成一个集合aG，而这个aG = G，因此和G是一一对应的。此时我们的元素a，就变成了置换a()。它对G中的元素进行左乘，是一个一一对应的映射。 同样的道理，G中的每一个元素都被我们解读为了置换，为了更加清晰，我们把这些置换都放进$\\Sigma$中。所以现在G中就是单纯的元素e,a,b,…，而$\\Sigma$中就是置换e()，a()，b() 现在我们需要考虑两件事情，第一，这个$\\Sigma$关于某个运算是群吗？第二，假如是群，那么它俩同构吗？ 答案是yes，$\\Sigma$关于G的运算是群，并且与G同构。 关于以上两点的证明请参看教材的p160 例13.12与p168的例13.21。","categories":[{"name":"数学","slug":"数学","permalink":"http://gunslingeratlarge.github.io/categories/数学/"},{"name":"抽象代数","slug":"数学/抽象代数","permalink":"http://gunslingeratlarge.github.io/categories/数学/抽象代数/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://gunslingeratlarge.github.io/tags/数学/"},{"name":"抽象代数","slug":"抽象代数","permalink":"http://gunslingeratlarge.github.io/tags/抽象代数/"}]},{"title":"商群","slug":"商群","date":"2018-03-24T02:03:00.000Z","updated":"2018-06-25T10:21:01.922Z","comments":true,"path":"2018/03/24/商群/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/03/24/商群/","excerpt":"商群设我们有一个群G，它的正规子群为N，即$N\\lhd G$ ，有G/N。有点像用群G去除以群N。 回顾正规子群 设N是G的子群，当对于任意$g\\in G$，有gN = Ng，则说N是G的正规子群。 设N是G的子群，我们说N是G的正规子群，当且仅当对任意$g\\in G,h\\in N$，有$ghg^{-1}\\in N$。 我们知道，对于群G来说，当$H\\subseteq G$是G的子群时，其所有的左（右）陪集构成一个划分，每一个陪集是一个等价类。每一个陪集中元素等价。对于正规子群N而言，它的左陪集和右陪集相等，因此通常的子群有两个划分，正规子群只有一个划分。","text":"商群设我们有一个群G，它的正规子群为N，即$N\\lhd G$ ，有G/N。有点像用群G去除以群N。 回顾正规子群 设N是G的子群，当对于任意$g\\in G$，有gN = Ng，则说N是G的正规子群。 设N是G的子群，我们说N是G的正规子群，当且仅当对任意$g\\in G,h\\in N$，有$ghg^{-1}\\in N$。 我们知道，对于群G来说，当$H\\subseteq G$是G的子群时，其所有的左（右）陪集构成一个划分，每一个陪集是一个等价类。每一个陪集中元素等价。对于正规子群N而言，它的左陪集和右陪集相等，因此通常的子群有两个划分，正规子群只有一个划分。 商集我们把G关于H的所有不同的陪集放到一个集合里，这个集合就是商集。 商集其实里面的元素就是陪集，所以里面的每个元素都是集合。我们把商集记为G/N。 G/N = {集合,集合,集合,集合,…} 当然，每一个陪集都是一个等价类，因此我们也可以用等价类的方式来表示： G/N = {[e],[a],[b],[c],…} 其中，e来自于陪集eN（也就是N），a来自于陪集aN，a是任意N外的，在G内的元素，b来自于陪集bN，b是任意N外的，aN外的，在G内的元素，以此类推。每个等价类中的元素关于模H同余关系等价。 回顾模H同余关系我们将模H同余关系定义为，对于任意$a,b \\in G$,当且仅当$a\\cdot b^{-1} \\in H$，我们就说a与b模H同余。 复合运算 我们现在想证明G/N是一个群，首先要定义在G/N上的运算。即$[a]\\circ [b] = [a\\cdot b]$，注意，这里$\\circ $是定义在G/N上的运算，而$\\cdot$ 是定义在G上的运算。怎么样去理解这个运算？注意，运算$\\circ$是在G/N层面的，也就是说，这个运算$\\circ$是将各个等价类视为一个实体，而不是集合，将他们进行运算。运算的规则是，两个陪集的复合，等于这两个元素的$\\cdot$ 运算后的元素所在的等价类（陪集）。 但是我们需要证明的是，我们从[a]中任意拿一个元素，从[b]中任意拿一个元素，都能落在[ab]中。我们即是要证明$(a\\cdot n)\\cdot (b \\cdot n{‘}) = (a \\cdot b \\cdot n’’)$。提醒一下aN = {an | n属于N}, 所以an就可以代表[a]这个陪集中的任意一个元素。 证明如下： $(a\\cdot n)\\cdot (b \\cdot n{‘}) = a \\cdot b \\cdot b^{-1} \\cdot n \\cdot b \\cdot n’ $ 有$b^{-1} \\cdot n \\cdot b \\in N$, 所以$(a\\cdot n)\\cdot (b \\cdot n{‘}) = abn’’’n’\\in [ab]$ 得证。 注意 $b^{-1} \\cdot n \\cdot b \\in N$只有正规子群才满足，因此只对于正规子群来说，$\\circ$是G/N上的运算。","categories":[{"name":"数学","slug":"数学","permalink":"http://gunslingeratlarge.github.io/categories/数学/"},{"name":"抽象代数","slug":"数学/抽象代数","permalink":"http://gunslingeratlarge.github.io/categories/数学/抽象代数/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://gunslingeratlarge.github.io/tags/数学/"},{"name":"抽象代数","slug":"抽象代数","permalink":"http://gunslingeratlarge.github.io/tags/抽象代数/"}]},{"title":"怎样去理解子群？","slug":"怎样去理解子群？","date":"2018-03-23T03:07:00.000Z","updated":"2018-06-25T10:21:01.926Z","comments":true,"path":"2018/03/23/怎样去理解子群？/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/03/23/怎样去理解子群？/","excerpt":"子群的定义如果说H是G的非空子集，若H是一个群并且与G有同样的二元运算，我们就可以说H是G的一个子群。包含三个点： H是G的子集 H是一个群 H与G使用同样的二元运算 记号$H\\subseteq G$ H是G的子集 $H \\le G$ H是G的子群","text":"子群的定义如果说H是G的非空子集，若H是一个群并且与G有同样的二元运算，我们就可以说H是G的一个子群。包含三个点： H是G的子集 H是一个群 H与G使用同样的二元运算 记号$H\\subseteq G$ H是G的子集 $H \\le G$ H是G的子群 确定一个群为子群通常来说，我们要确定一个代数系统是一个群，要确定： 封闭性 有单位元 结合律 有逆元 但是对于$H\\subset G$,H是G的子群当且仅当这以下两个条件满足： 封闭性：若$a,b\\in H$，则$ab\\in H$ 有逆元：对于任何$a\\in H$，$a^{-1}\\in H$ 证明： 必要性 H是G的子群，自然满足 充分性 $a\\in H$，$a^{-1}\\in H$，则$a\\cdot a^{-1}\\in H$ ，有单位元，又H是G的子集，因此自然也满足结合律 证毕。 小总结如果你需要证明一个群的子集是子群，只用证明封闭性和有逆元即可。 循环子群引入：有群$\\mathbb{Z}_6$ (模6同余关于加法构成的群) 问题：最少元素的包含2的子群是？ 我们将2拿出来，并让它自己加自己，得到2,4,0(6mod6)，2,4,0,… 所以最少元素的包含2的子群是{0,2,4} 设想 从一个群中拿出一个元素，然后让它自己与自己做运算（因为要满足封闭性） 问题 ​ 这样做产生的总是子群吗？ 设G是一个群并且$a\\in G$，有$\\langle a \\rangle = { a^n\\mid n \\in \\mathbb{Z} }$ ，我们希望它是一个子群，根据前面所说，只需要证明两点: 封闭性。很容易证明有$x,y\\in \\langle a \\rangle$，$x = a^m,y=a^n,xy=a^{m+n}\\in \\langle a\\rangle$ 有逆元。利用上面的思路易证。 我们把$\\langle a \\rangle$称为G的由a生成的循环子群。 因此，从一个群中取出一个元素，由这个元素作为生成元而构成的循环群，始终是一开始的那个群的子群。","categories":[{"name":"数学","slug":"数学","permalink":"http://gunslingeratlarge.github.io/categories/数学/"},{"name":"抽象代数","slug":"数学/抽象代数","permalink":"http://gunslingeratlarge.github.io/categories/数学/抽象代数/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://gunslingeratlarge.github.io/tags/数学/"},{"name":"抽象代数","slug":"抽象代数","permalink":"http://gunslingeratlarge.github.io/tags/抽象代数/"}]},{"title":"了解paxos：形成共识","slug":"Paxos之understanding","date":"2018-03-21T23:08:00.000Z","updated":"2018-06-25T10:21:01.897Z","comments":true,"path":"2018/03/22/Paxos之understanding/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/03/22/Paxos之understanding/","excerpt":"前面有部分内容待补充… 负面反馈就是说在提出提议的时候，节点的提议可能由于它自身的suggestion ID太小而被忽略，但是它不知道它的提议被忽略，只能靠超时、重发等机制发现可能自己的提议无法达成共识，然后再增大suggestion ID。如果有负面反馈，即如果来自另一个节点的提议没有被接受，即向该节点发送“你的提议未被我接受”的消息，这样当收到网络中超过半数的负面回馈时，该节点就知道它的提议没有可能达成共识了，可以更早地增大suggestion ID，开始下一轮的提议。","text":"前面有部分内容待补充… 负面反馈就是说在提出提议的时候，节点的提议可能由于它自身的suggestion ID太小而被忽略，但是它不知道它的提议被忽略，只能靠超时、重发等机制发现可能自己的提议无法达成共识，然后再增大suggestion ID。如果有负面反馈，即如果来自另一个节点的提议没有被接受，即向该节点发送“你的提议未被我接受”的消息，这样当收到网络中超过半数的负面回馈时，该节点就知道它的提议没有可能达成共识了，可以更早地增大suggestion ID，开始下一轮的提议。 达成一致注意：这里我们对一些术语进行定义 权限请求消息：指一个节点向其他节点发送请求，以使他们允许自己进行提议，这条消息也会附带一个id，但是不是消息本身的id，而是如果得到批准的话，将发送的提议消息的提议id 许可/批准：指一个节点批准另一个节点发送的权限请求消息，从而可以向自己发送提议消息 提议消息：提出一个值和一个提议Id，并希望在这个值上达成一致 已批准消息：指一个节点当前最新批准的消息，是该节点所收到所有权限请求消息中的提议id最大的消息 接受：特指接受提议消息，并不会接受权限请求消息，而是许可/批准权限请求消息分为两步：Step 1：节点尝试发送权限请求消息，如果超过半数的结点都给了它许可了，那么它可以进入第二步。如果没有，就增大自己想提出的suggestion的ID，再重新发送权限请求消息Step 2：获得许可之后，节点提出提议，如果被超过半数的结点接受，那么就达成了一致对这两个步骤再详细分析一下，在Step 1中，这个suggestion ID的大小是所有节点全局共用还是每个节点自己有一个suggestion ID的大小呢？答案是自己维护一个suggestion ID的大小，因为如果全局共用你很难获知别的结点的suggestion ID发到什么号了，你甚至还要去同步这个ID，使得整个集群对ID的认识保持一致。如果各管各的就很方便了，我们只要能够保证两个ID能够比较出大小就可以了（如3 B &gt; 3 A &gt; 2 A）。结点是怎么接受一个提议的？当这个提议已经被许可了之后，而且在许可到接受这段时间内这个结点没有批准别的结点进行提议，也就是说，如果提议消息的id等于已批准消息的id，就可以接受这个提议。还有一种情况就是提议消息的id&gt;已批准消息的id，这种情况会直接接受提议的，这一点需要注意一下。 消息处理规则当一个节点收到一条权限请求消息的时候：如果说之前没有接受到任何的权限请求消息，那么就批准这条权限请求消息。如果说这个节点之前已经有批准的消息了，就比较这条新的消息和它已经批准了的消息谁大，如果新的消息大，那么就批准新的消息，此时旧的已批准消息就无效了。如果新的消息小，那么就忽略它或者发送负面反馈。当一个节点收到一条提议消息的时候：如果这条提议消息的提议id和这个节点的已批准消息的id一致（或者更大），那么这个节点就接受这个提议。除此之外，都不接受。如何提出提议：当一个节点获得了超半数的结点批准可以进行提议时，这个节点就可以着手进行提议了。对这个节点来说，提议id是好确定的，因为id是依次增大的，比如A节点，id就从1 A 到 2 A 到3 A…依次增大，并且已经在权限请求消息中带上了提议id。问题在于如何确定提议消息中要携带的企图达成一致的值。在讲述之前我们需要补充的是，每一个节点收到权限请求消息之后，如果它要批准这条消息，除了返回一个“yes”之外，还要携带上它已经接受了的一系列消息的最大id（如果有的话），这是为了使得发送权限请求消息的提议者能够从这些已经被接受了的消息中选择值，而不是自己提出一个新值，选择值的策略依然是最大id。因此现在我们来着手提议。假设我这个节点A发送的权限请求消息(3 A)得到了另外两个个节点B和C的批准，但是节点B同时也告诉我们B接受了id为(2 C)的这个提议消息，值为”git”,节点C告诉我们C接受了id为(1 B)的提议消息，值为”hub”，因此我们的节点A手上有： 能够提出提议消息的权利，并且这个提议消息的id是(3 A) B告诉的(2 C git)和C告诉的(1 B hub)这两条已被接收消息的信息 现在A只能从(2 C git)和(1 B hub)中选择一个，按照最大id的策略，选择(2 C git)，则A的消息的值为git，因此A将它的提议消息(3 A git)向所有节点发送，尝试形成共识值。到现在，A的提议就完成了。","categories":[{"name":"区块链","slug":"区块链","permalink":"http://gunslingeratlarge.github.io/categories/区块链/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://gunslingeratlarge.github.io/tags/区块链/"},{"name":"paxos","slug":"paxos","permalink":"http://gunslingeratlarge.github.io/tags/paxos/"},{"name":"分布式","slug":"分布式","permalink":"http://gunslingeratlarge.github.io/tags/分布式/"}]},{"title":"循环群、交换群、变换群与置换群","slug":"循环群、交换群、变换群与置换群","date":"2018-03-18T10:44:00.000Z","updated":"2018-06-25T10:21:01.925Z","comments":true,"path":"2018/03/18/循环群、交换群、变换群与置换群/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/03/18/循环群、交换群、变换群与置换群/","excerpt":"一、循环群循环群（cyclic group）循环二字从何而来？我们先从其课本上的定义看起： 设群G的运算记做乘法（或加法），如果G的每一个元素能写成G的某一个元素a的整次数幂（或a的整数倍）的形式，那么称G为循环群，把a叫做G的一个生成元","text":"一、循环群循环群（cyclic group）循环二字从何而来？我们先从其课本上的定义看起： 设群G的运算记做乘法（或加法），如果G的每一个元素能写成G的某一个元素a的整次数幂（或a的整数倍）的形式，那么称G为循环群，把a叫做G的一个生成元 其中，循环群又分为有限循环群和无限循环群，循环群的结构完全由其生成元决定，当生成元a的阶为n时，G同构于同余类加法循环群,a为无限阶时，G同构于加法循环群[Z;+]。 循环二字从哪里来呢？是因为在有限循环群中，a从不同的阶生成整个群中的元素的时候，总是会生成重复的元素，比如a的阶是5，那么由a作为生成元的有限循环群集合中的元素为$a^{-4},a^{-3},a^{-2},a^{-1},e,a^{1},a^{2},a^{3},a^{4}$ ,当a的次数到5次时又会变为e，然后6次时其实就是$a^{1}$，所以就这样一直循环下去。 二、交换群交换群又叫阿贝尔群，即群中的元素运算时满足交换律即可。 三、变换群与置换群我们把一一对应的映射称为变换。当一个群中的集合元素为一一对应的映射，这些映射都是从T到T，当它们关于乘法运算构成群时，我们就把这个群叫做交换群。而当T只有有限个元素时，这样的群就是置换群了，因为其集合中的元素都是置换。置换即是从有限个元素的集合T到T的一一对应的映射。变换群与置换群的区别就在于集合T（注意这个集合不是群G中的那个由映射组成的集合）是有限还是无限的。","categories":[{"name":"数学","slug":"数学","permalink":"http://gunslingeratlarge.github.io/categories/数学/"},{"name":"抽象代数","slug":"数学/抽象代数","permalink":"http://gunslingeratlarge.github.io/categories/数学/抽象代数/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://gunslingeratlarge.github.io/tags/数学/"},{"name":"抽象代数","slug":"抽象代数","permalink":"http://gunslingeratlarge.github.io/tags/抽象代数/"}]},{"title":"抽象代数 Lec1","slug":"抽象代数-Lec1","date":"2018-03-17T11:50:00.000Z","updated":"2018-06-25T10:21:01.927Z","comments":true,"path":"2018/03/17/抽象代数-Lec1/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/03/17/抽象代数-Lec1/","excerpt":"一、复习线性代数矩阵是一组线性算子（Linear Operator），每一个矩阵都表示着某种线性变换（Linear Transformation），而矩阵的乘法实际上就是变换的复合。如n维的矩阵就代表着从$R^n$到$R^n$的变换。比如n×n矩阵A，n维向量x，n维向量y， y = A·x，就是从$R^n$到$R^n$的变换，因为$x\\in R^n$并且$y\\in R^n$。 在矩阵运算中，除了乘法的交换律与我们的算术中不同以外，其他的运算律都符合，包括加法的交换律，加法乘法的结合律，以及分布律。 除此之外，A + 0 = 0 + A = A， A × I = I × A = A，这里的0是全部元素为0的矩阵，这里的I是对角线元素为1其他元素全部为0的矩阵。如下就是一个3×3的单位矩阵 \\begin{matrix} 1&0&0\\\\ 0&1&0\\\\ 0&0&1\\\\ \\end{matrix}","text":"一、复习线性代数矩阵是一组线性算子（Linear Operator），每一个矩阵都表示着某种线性变换（Linear Transformation），而矩阵的乘法实际上就是变换的复合。如n维的矩阵就代表着从$R^n$到$R^n$的变换。比如n×n矩阵A，n维向量x，n维向量y， y = A·x，就是从$R^n$到$R^n$的变换，因为$x\\in R^n$并且$y\\in R^n$。 在矩阵运算中，除了乘法的交换律与我们的算术中不同以外，其他的运算律都符合，包括加法的交换律，加法乘法的结合律，以及分布律。 除此之外，A + 0 = 0 + A = A， A × I = I × A = A，这里的0是全部元素为0的矩阵，这里的I是对角线元素为1其他元素全部为0的矩阵。如下就是一个3×3的单位矩阵 \\begin{matrix} 1&0&0\\\\ 0&1&0\\\\ 0&0&1\\\\ \\end{matrix} 矩阵的逆矩阵可逆 &lt;=&gt; 矩阵的行列式不为0 总是存在一个矩阵B可以使得AB = BA = det(A) · I，如果det(A)即矩阵的行列式不为0就等同于矩阵可逆。 矩阵的逆矩阵如果存在则一定唯一，可以通过反证法容易证出。 设$GL_n(R)\\subseteq M_n(R)$，$GL_n(R)$定义为${A:detA\\neq 0}$，即为所有可逆n×n矩阵的集合。在这个集合中对于加法没有封闭性，比如A + (-A) = 0,0矩阵不在这个集合中。但是对于矩阵乘法却具有封闭性。即我们要证明： 设A和B为两个可逆矩阵，则AB也是可逆的。 可以轻易看出$B^{-1}A^{-1}$就是该矩阵的逆矩阵。另一个角度是我们知道det(AB) = det(A)×det(B)，若A、B都可逆则det(A)和det(B)都不为0，自然det(AB)也不为0，即AB可逆。 二、群的定义现在我们考察$GL_n(R)$的性质： 1.它关于乘法有结合律 2.有一个I使得任何集合中元素乘以它仍然是I 3.每个元素都有对应的逆矩阵 这使得$GL_n(R)$成为了一个群。由此我们可以引出群的定义：群由一个集合和在这个集合上定义的运算组成，英文原文是A group G is a set with a product operation。群具有以下性质： 1.满足结合律 2.有单位元e（identity element） 3.每个元素有逆元，元素与它的逆元相乘得到单位元 群不必满足交换律，满足交换律的群又叫做交换群或者是阿贝尔群（Abelian group）。 现在我们有一个集合T，令所有的一一对应映射：$G= {所有的一一对应映射 g：T→T} = Sym(T)$，the symmetric group of T，则[G;●]为一个群。 在中文把全部由一一对应的映射关于合成运算组成的群叫做变换群，变换群的集合是G的子集（同样的T）。下面我们证明[G;●]是一个群： 1.就像矩阵的符合运算一样，实际上映射也是一种变换（transformation），映射的符合运算满足结合律。不管你先变还是后变，只要顺序相同，就能够得到同样的变换结果 2.有单位元e是T到T的不变的映射 3.逆元就是反过来映射，如1映射到2，然过来就是2映射到1。 这个群是最广泛的（the most general）、最通用的一个群，其他所有群，都是来自于给这个群上添加额外的条件。如我们之前讲到的乘法，对应到这里就是T为$R^n$, G为从$R^n$到$R^n$的所有一一对应且保持线性关系的映射的集合（还要加上映射的运算）所构成的一个群。这里的$R^n$和保持线性结构就是额外的条件。因此不是所有的$R^n$到$R^n$的映射都可以，必须是那些行列式不为0的，即线性无关的矩阵（这些矩阵保持了向量空间的结构）才在这个群G中。 为什么说线性无关的矩阵保持了向量空间的结构呢？考虑3个3维向量，我们知道，如果这三个三维向量线性无关，则他们可以表示我们的这个三维的向量空间（比如三条正交的坐标轴），而如果他们线性相关，则其中的向量可以被另外的向量给表示， 则自然没有办法再表示这个三维的空间了，因此一个n×n的线性无关的矩阵就保持了n维向量空间的结构。 我们现在考察一个$T={1,2,…,n}$的情况，对应的G就是从T到T的一一对应的映射组成的集合关于映射的复合运算，映射的数量其实就是G中集合元素的数量，实际上就是1到n排列的数量，如下面这个映射，2 5 7 9 … 1就是排列的一种，所以总共有n!个元素。 \\begin{Bmatrix} 1&2&3&4&{...}&n\\\\ 2&5&7&9&{...}&1\\\\ \\end{Bmatrix}我们把这个群记为$Sym(T)=S_n$，下标的n怎么理解？是指这个群中的集合有n个元素吗？不是，而是它是从n个元素的集合映射到n个元素的集合，又叫n次对称群。","categories":[{"name":"数学","slug":"数学","permalink":"http://gunslingeratlarge.github.io/categories/数学/"},{"name":"抽象代数","slug":"数学/抽象代数","permalink":"http://gunslingeratlarge.github.io/categories/数学/抽象代数/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://gunslingeratlarge.github.io/tags/数学/"},{"name":"抽象代数","slug":"抽象代数","permalink":"http://gunslingeratlarge.github.io/tags/抽象代数/"}]},{"title":"Mybatis快速入门 part1","slug":"Mybatis快速入门-part1","date":"2018-03-17T08:13:00.000Z","updated":"2018-06-25T10:21:01.892Z","comments":true,"path":"2018/03/17/Mybatis快速入门-part1/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/03/17/Mybatis快速入门-part1/","excerpt":"一、Mybatis架构 Mybatis中有一堆配置文件，SqlMapConfig.xml以及对应数据库中各个表的xml比如User.xml、Order.xml等等。其中SqlMapConfig.xml配置了mybatis的运行环境等信息，其他的配置文件映射到各个数据库表中主要配置操作数据库的sql语句。SqlSessionFactory用于创建会话SqlSession，通过SqlSession操作数据库，我们现在只需要知道通过SqlSession我们就可以进行增删查改操作了。","text":"一、Mybatis架构 Mybatis中有一堆配置文件，SqlMapConfig.xml以及对应数据库中各个表的xml比如User.xml、Order.xml等等。其中SqlMapConfig.xml配置了mybatis的运行环境等信息，其他的配置文件映射到各个数据库表中主要配置操作数据库的sql语句。SqlSessionFactory用于创建会话SqlSession，通过SqlSession操作数据库，我们现在只需要知道通过SqlSession我们就可以进行增删查改操作了。 二、配置环境Mybatis主要的配置工作就在我们前面说的几个xml文件中，除此之外就是常规的下载、导包。而由于mybatis是连接数据库的框架，从数据库中读出来的数据可以直接由mybatis帮我们导入到POJO类中（POJO类通常与数据库表的一个条目对应），因此还需要创建POJO类。 下载并加入jar包1.下载地址https://github.com/mybatis/mybatis-3/releases2.导入mybatis核心包mybatis-3.2.7.jar、依赖包（lib文件夹中所有内容）、数据库驱动包mysql-connetctor-java-5.1.7.bin.jar(不在mybatis压缩包中) 创建pojo一个pojo类通常与一个数据库表相对应1234567Public class User &#123; private int id; private String username;// 用户姓名 private String sex;// 性别 private Date birthday;// 生日 private String address;// 地址 getter/setter.. 加入配置文件我们先创建config文件夹，将这些配置文件放在下面 log4jmybatis默认使用log4j来输出日志。创建log4j.properties文件：123456# Global logging configurationlog4j.rootLogger=DEBUG, stdout# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n SqlMapConfig.xml核心配置文件，配置的内容主要有数据源（结合Spring后就不必配置了）、事务处理。123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configurationPUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 和spring整合后 environments配置将废除 --&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;!-- 使用jdbc事务管理 --&gt; &lt;transactionManager type=\"JDBC\" /&gt; &lt;!-- 数据库连接池 --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\" /&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8\" /&gt; &lt;property name=\"username\" value=\"root\" /&gt; &lt;property name=\"password\" value=\"root\" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;/configuration&gt; 添加User.xml在config下创建sqlmap目录，其下添加sql映射文件User.xml。User.xml中就是写我们对User表的sql语句，定义查询的一些规则。1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapperPUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;!-- namespace：命名空间，用于隔离sql，还有一个很重要的作用，后面会讲 --&gt;&lt;mapper namespace=\"test\"&gt;&lt;/mapper&gt; 加载映射文件mybatis并不知道你的User.xml写到哪里去了，因此你需要在SqlMapConfig.xml中提一句。123&lt;mappers&gt; &lt;mapper resource = \"sqlmap/User.xml\"/&gt;&lt;/mappers&gt; 三、实现业务根据用户id查询一个用户要实现查询在mybatis中非常简单，因为mybatis可以直接帮我们映射到pojo中，因此我们只需要在User.xml中写sql语句就可以了。每一条sql语句有自己的id，有传入参数的类型（如这里的id是整型），有传出参数的类型。123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapperPUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- namespace：命名空间，用于隔离sql，还有一个很重要的作用，后面会讲 --&gt;&lt;mapper namespace=&quot;test&quot;&gt; &lt;!-- id:statement的id 或者叫做sql的id--&gt; &lt;!-- parameterType:声明输入参数的类型 --&gt; &lt;!-- resultType:声明输出结果的类型，应该填写pojo的全路径 --&gt; &lt;!-- #&#123;&#125;：输入参数的占位符，相当于jdbc的？ --&gt; &lt;select id=&quot;queryUserById&quot; parameterType=&quot;int&quot; resultType=&quot;cn.itcast.mybatis.pojo.User&quot;&gt; SELECT * FROM `user` WHERE id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 实际上到这里，根据用户id查询一个用户就搞完了，下面我们需要进行一下测试。正如我们一开始说的： SqlSessionFactory用于创建会话SqlSession，通过SqlSession操作数据库，我们现在只需要知道通过SqlSession我们就可以进行增删查改操作了。测试程序的步骤： 创建SqlSessionFactoryBuilder对象 加载SqlMapConfig.xml配置文件 创建SqlSessionFactory对象 创建SqlSession对象 执行SqlSession对象执行查询，获取结果User 打印结果 释放资源12345678910111213141516171819202122232425262728293031public class MybatisTest &#123; private SqlSessionFactory sqlSessionFactory = null; @Before public void init() throws Exception &#123; // 1. 创建SqlSessionFactoryBuilder对象 SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); // 2. 加载SqlMapConfig.xml配置文件(这里要把config文件夹设置为scource folder) InputStream inputStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); // 3. 创建SqlSessionFactory对象 this.sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream); &#125; @Test public void testQueryUserById() throws Exception &#123; // 4. 创建SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); // 5. 执行SqlSession对象执行查询，获取结果User // 第一个参数是User.xml的statement的id，第二个参数是执行sql需要的参数； Object user = sqlSession.selectOne(\"queryUserById\", 1); // 6. 打印结果 System.out.println(user); // 7. 释放资源 sqlSession.close(); &#125;&#125; 根据用户名模糊查询一个用户主要涉及到模糊查询的处理，在mybatis中#{}表示占位符，可以防止sql注入，${}表示拼接字符串，不能防止sql注入。现在我们要模糊查询，因此可以写1select * from user where username like \"%\"#&#123;username&#125;\"%\" 注意，这里是一种防止了sql注入，又可以直接模糊查询的一种方式。这时候我们使用selectList而非selectOne来进行查询，返回的是List&lt;Object&gt; 。其他地方大同小异。一个小细节要注意的是如果传入的参数是基本类型（整型、字符串），那么可以在#{}中写任意字符，但是如果是传入pojo，那只能写value。 增加一个用户User.xml中的配置123456&lt;!-- 保存用户 --&gt;&lt;insert id=\"saveUser\" parameterType=\"cn.itcast.mybatis.pojo.User\"&gt; INSERT INTO `user` (username,birthday,sex,address) VALUES (#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)&lt;/insert&gt; 测试程序12345678910111213141516171819202122@Testpublic void testSaveUser() &#123; // 4. 创建SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); // 5. 执行SqlSession对象执行保存 // 创建需要保存的User User user = new User(); user.setUsername(\"张飞\"); user.setSex(\"1\"); user.setBirthday(new Date()); user.setAddress(\"蜀国\"); sqlSession.insert(\"saveUser\", user); System.out.println(user); // 需要进行事务提交 sqlSession.commit(); // 7. 释放资源 sqlSession.close();&#125; 其他的增删查改都大同小异，不再赘述。","categories":[{"name":"Java","slug":"Java","permalink":"http://gunslingeratlarge.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://gunslingeratlarge.github.io/tags/Java/"},{"name":"Web开发","slug":"Web开发","permalink":"http://gunslingeratlarge.github.io/tags/Web开发/"}]},{"title":"最大似然估计","slug":"最大似然估计","date":"2018-03-17T07:21:00.000Z","updated":"2018-06-25T10:21:01.928Z","comments":true,"path":"2018/03/17/最大似然估计/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/03/17/最大似然估计/","excerpt":"一、概念最大似然估计是用来对数据寻找最能描述数据情况的分布的。","text":"一、概念最大似然估计是用来对数据寻找最能描述数据情况的分布的。 二、过程如我们有一堆数据，比如老鼠的体重，我们希望可以找到最能够描述老鼠体重的一个分布，从而可以在以后判断某个体重出现的概率有多少。那么我们初步选型为正态分布，可是正态分布的两个参数，期望和标准差需要确定，我们就采用最大似然估计来确定这两个值。过程是这样的，我们对这个正态分布使用不同的期望，不同的期望自然就会得到不同的正态分布，我们对每一个正态分布考察它观察到我们样本中的老鼠的可能性，寻找到使这个可能性最大的期望值，并确定下来。对标准差也采用同样的方式，考察不同标准差下的正态分布能否尽可能多地观察到我们样本中的老鼠，即使得我们样本中的老鼠尽量出现在该正态分布的高概率处。 三、总结如果别人提到了最大似然估计，他是想表达这样一件事：他有一堆数据，想从这些数据中“抽象”出一个概率分布他用最大似然估计去确定这些概率分布的参数（方差，期望等等）他找到的这个值所确定的分布能够使得观察到样本中数据的可能性最大了解更多.","categories":[{"name":"数学","slug":"数学","permalink":"http://gunslingeratlarge.github.io/categories/数学/"},{"name":"概率统计","slug":"数学/概率统计","permalink":"http://gunslingeratlarge.github.io/categories/数学/概率统计/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://gunslingeratlarge.github.io/tags/数学/"},{"name":"概率统计","slug":"概率统计","permalink":"http://gunslingeratlarge.github.io/tags/概率统计/"}]},{"title":"java实现区块链","slug":"用400行代码实现区块链","date":"2018-03-17T07:13:00.000Z","updated":"2018-06-25T10:21:01.931Z","comments":true,"path":"2018/03/17/用400行代码实现区块链/","link":"","permalink":"http://gunslingeratlarge.github.io/2018/03/17/用400行代码实现区块链/","excerpt":"","text":"Hello blockchian","categories":[{"name":"区块链","slug":"区块链","permalink":"http://gunslingeratlarge.github.io/categories/区块链/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://gunslingeratlarge.github.io/tags/Java/"},{"name":"区块链","slug":"区块链","permalink":"http://gunslingeratlarge.github.io/tags/区块链/"}]}]}